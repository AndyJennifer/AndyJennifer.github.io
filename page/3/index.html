<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>AndyJennifer‘Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="AndyJennifer">
<meta property="og:type" content="website">
<meta property="og:title" content="AndyJennifer‘Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="AndyJennifer‘Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AndyJennifer‘Blog">
  
    <link rel="alternate" href="/atom.xml" title="AndyJennifer‘Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AndyJennifer‘Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">What would life be if we had no courage to attempt anything?</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android-Handler机制之Handler-、MessageQueue-、Looper" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Android-Handler机制之Handler-、MessageQueue-、Looper/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-8e0074126982e457.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="很随意.jpg"></p>
<blockquote>
<p>该文章属于Android Handler系列文章，如果想了解更多，请点击<br><a href="https://www.jianshu.com/p/43bb31d8a742" target="_blank" rel="noopener">《Android Handler机制之总目录》</a></p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上篇文章，我们讲了ThreadLocal，了解了线程本地变量的实质，如果有小伙伴还是不熟悉ThreadLocal原理的，请参看上篇文章<a href="https://www.jianshu.com/p/2a34d30806d4" target="_blank" rel="noopener">《Android Handler机制之ThreadLocal》</a>。如果你已经阅读 了该文章，那现在我们就一起来了解Handler与MessageQueue与Looper三者之间的关系及其内部原理。</p>
<h3 id="Handler、MessageQueue、Looper三者之间的关系"><a href="#Handler、MessageQueue、Looper三者之间的关系" class="headerlink" title="Handler、MessageQueue、Looper三者之间的关系"></a>Handler、MessageQueue、Looper三者之间的关系</h3><p>在了解其三者关系之前，我先给大家一个全局的关系图，接下来的文章会根据该关系图，进行相应的补充与描述。<br><img src="https://upload-images.jianshu.io/upload_images/2824145-b3c798765233c278.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HandlerLooperMessage关系.png"></p>
<p>从上图中我们可以看出几点</p>
<ul>
<li>Handler的创建是与Looper创建的线程是相同的。</li>
<li>Looper中内部维护了一个MessageQueue(也就是消息队列)。且该队列是通过链表的形式实现的。</li>
<li>Hanlder最终通过sendMessage方法将消息发送到Looper中对应的MessageQueue中。</li>
<li>Looper通过消息循环获取消息后，会调用对应的消息中的target（target对应的是发消息的Handler)的dispatchMessage()方法来处理消息。</li>
</ul>
<h3 id="Looper原理"><a href="#Looper原理" class="headerlink" title="Looper原理"></a>Looper原理</h3><p>因为消息队列（MessageQueue的创建是在Looper中内部创建的，同时Handler消息的发送与处理都是围绕着Looper来进行的，所以我们首先来讲Looper。</p>
<h4 id="Looper是如何与主线程关联的"><a href="#Looper是如何与主线程关联的" class="headerlink" title="Looper是如何与主线程关联的"></a>Looper是如何与主线程关联的</h4><p>在平时开发中，我们使用Handler主要是为了在主线程中去更新UI，那么Looper是如何与主线程进行关联的呢？在Android中，App进程是由Zygote fork 而创建的，而我们的ActivityThread就是运行在该进程下的主线程中，那么在ActivityThread的main方法中，Looper会通过prepareMainLooper（）来创建内部的消息队列（MessageQueue),同时会通过loop（）构建消息循环。具体代码如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">...省略部分代码</span><br><span class="line">      Looper.prepareMainLooper();//</span><br><span class="line">      </span><br><span class="line">      ActivityThread thread = new ActivityThread();</span><br><span class="line">      thread.attach(false);</span><br><span class="line"></span><br><span class="line">      if (sMainThreadHandler == null) &#123;</span><br><span class="line">          sMainThreadHandler = thread.getHandler();</span><br><span class="line">      &#125;</span><br><span class="line">      if (false) &#123;</span><br><span class="line">          Looper.myLooper().setMessageLogging(new</span><br><span class="line">                  LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">      &#125;</span><br><span class="line">      // End of event ActivityThreadMain.</span><br><span class="line">      Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">      Looper.loop();</span><br><span class="line"></span><br><span class="line">      throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>要了解当前Loooper如何与主线程进行关联的，需要继续查看prepareMainLooper（）方法。下述代码中，为了大家方便，我将prepareMainLooper（）方法所涉及到的方法全部罗列了出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> //创建主线程Looper对象</span><br><span class="line"> public static void prepareMainLooper() &#123;</span><br><span class="line">      prepare(false);</span><br><span class="line">      synchronized (Looper.class) &#123;</span><br><span class="line">          if (sMainLooper != null) &#123;</span><br><span class="line">              throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          sMainLooper = myLooper();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">//Looper与当前主线程绑定</span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">      if (sThreadLocal.get() != null) &#123;</span><br><span class="line">          throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      sThreadLocal.set(new Looper(quitAllowed));//创建Looper对象，放入主线程局部变量中</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">//获取当前主线程的Looper对象</span><br><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">      return sThreadLocal.get();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>观察上诉代码，我们发现，prepareMainLooper方法内部调用prepare()方法（这里我们忽略该方法中的参数 quitAllowed），而prepare内部调用的是ThreadLocal的set()方法。如果你阅读了之前我写的<a href="https://www.jianshu.com/p/2a34d30806d4" target="_blank" rel="noopener">《Android Handler机制之ThreadLocal》</a>。，那么大家应该知道了当前Looper对象已经与主线程关联了（也可以说，当前主线程中保存了当前Looper对象的引用）。</p>
<h4 id="Looper内部创建消息队列"><a href="#Looper内部创建消息队列" class="headerlink" title="Looper内部创建消息队列"></a>Looper内部创建消息队列</h4><p>在了解了Looper对象怎么与当前线程关联的后，我们来看看Looper类中的具体方法。之前我们说过，在创建Looper对象的时候，当前Looper对象内部也会创建与之关联的消息队列(MessageQueue)。那么查看Looper对应的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   final MessageQueue mQueue;</span><br><span class="line">//Looper内部会创建MessageQueue对象</span><br><span class="line">   private Looper(boolean quitAllowed) &#123;</span><br><span class="line">       mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">       mThread = Thread.currentThread();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从Looper对象的构造函数中，我们很明显的看出内部创建了MessageQueue对象，也验证了我们之前的说法。</p>
<h4 id="Looper的消息循环"><a href="#Looper的消息循环" class="headerlink" title="Looper的消息循环"></a>Looper的消息循环</h4><p>当前Looper对象与主线程关联后，接着会调用Looper对象中的loop()方法来开启消息循环。具体代码如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  public static void loop() &#123;</span><br><span class="line">      final Looper me = myLooper();</span><br><span class="line">      if (me == null) &#123;</span><br><span class="line">          throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      final MessageQueue queue = me.mQueue;</span><br><span class="line">...省略部分代码</span><br><span class="line">      for (;;) &#123;//一直循环去获取消息队列中的消息</span><br><span class="line">          Message msg = queue.next(); //该方法可能堵塞，</span><br><span class="line">          if (msg == null) &#123;</span><br><span class="line">           //如果没有消息，表示当前消息队列已经退出</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      ...省略部分代码</span><br><span class="line">          try &#123;</span><br><span class="line">           //获取消息后，执行发送消息的handler的dispatchMessage方法。</span><br><span class="line">              msg.target.dispatchMessage(msg);</span><br><span class="line">              end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              if (traceTag != 0) &#123;</span><br><span class="line">                  Trace.traceEnd(traceTag);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      ...省略部分代码</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          msg.recycleUnchecked();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码，我们可以看出，在Looper中的loop()方法中会一直去拿当前消息队列中的消息，如果能取出消息会调用该消息的target去执行dispatchMessage（）方法。如果没有消息，就直接退出消息循环。</p>
<h3 id="MessageQueue原理"><a href="#MessageQueue原理" class="headerlink" title="MessageQueue原理"></a>MessageQueue原理</h3><h4 id="MessageQueue的next-方法"><a href="#MessageQueue的next-方法" class="headerlink" title="MessageQueue的next()方法"></a>MessageQueue的next()方法</h4><p>因为Looper中loop()方法会循环调用MessageQueue中的next方法，接下来带着大家一起查看该方法。代码如下图所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">...省略部分代码</span><br><span class="line"> for (;;) &#123;</span><br><span class="line">     synchronized (this) &#123;</span><br><span class="line">     ...省略部分代码</span><br><span class="line">        if (msg != null) &#123;</span><br><span class="line">          if (now &lt; msg.when) &#123;</span><br><span class="line">               nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                    //遍历消息列表，取出消息</span><br><span class="line">                       mBlocked = false;</span><br><span class="line">                       if (prevMsg != null) &#123;</span><br><span class="line">                           prevMsg.next = msg.next;</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           mMessages = msg.next;</span><br><span class="line">                       &#125;</span><br><span class="line">                       msg.next = null;</span><br><span class="line">                       if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                       msg.markInUse();</span><br><span class="line">                       return msg;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">             ...省略部分代码</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，我省略了很多代码，现在大家不需要关心省略的内容，大家只要关心大的一个方向就够了，关于MessageQueue的next()具体详解，会在下篇文章 <a href="https://www.jianshu.com/p/219701879fe4" target="_blank" rel="noopener">《Android Handler机制之Message的发送与取出》</a>具体介绍。好了，大家把状态调整过来。<br>在上文中，我们说过MessageQueue是以链表的形式来存储消息的，从next()方法中我们能分析出来，next()方法会一直从MessageQueue中去获取消息，直到获取消息后才会退出。</p>
<h4 id="MessageQueue的enqueueMessage（）方法"><a href="#MessageQueue的enqueueMessage（）方法" class="headerlink" title="MessageQueue的enqueueMessage（）方法"></a>MessageQueue的enqueueMessage（）方法</h4><p>通过上文，我们已经了解Message取消息的流程，现在我们来看看消息队列的加入过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">	      ...省略部分代码</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">          ...省略部分代码</span><br><span class="line">            if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">                // New head, wake up the event queue if blocked.</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              ...省略部分代码</span><br><span class="line">                //循环遍历消息队列，把当前进入的消息放入合适的位置（比较等待时间）</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //将消息插入合适的位置</span><br><span class="line">                msg.next = p; </span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">	      ...省略部分代码</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上诉代码中，我们把重心放在for循环中，在for循环中主要干了 一件事，就是根据当前meesag.when的值，来确定当前插入的消息应该放入消息队列的位置。（当前小伙伴肯能会对message.when感到困惑，还是那句话，现阶段我们只用关心主要的流程，具体的方法详解会在下篇文章 <a href="https://www.jianshu.com/p/219701879fe4" target="_blank" rel="noopener">《Android Handler机制之Message的发送与取出》</a>具体介绍）</p>
<h3 id="Handler的原理"><a href="#Handler的原理" class="headerlink" title="Handler的原理"></a>Handler的原理</h3><p>了解了Looper与MessageQueue的原理后，我们大致了解了整个消息处理的关系，现在就剩下发消息与处理消息的流程了。最后一点了，大家坚持看完。</p>
<h4 id="Handler是怎么与Looper进行关联的"><a href="#Handler是怎么与Looper进行关联的" class="headerlink" title="Handler是怎么与Looper进行关联的"></a>Handler是怎么与Looper进行关联的</h4><p>在文章最开始的图中，Handler发消息最终会发送到对应的Looper下的MessageQueue中。那么也就是说Handler与Looper之间必然有关联。那么它是怎么与Looper进行关联的呢？查看Handler的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> //不带Looper的构造函数</span><br><span class="line"> public Handler() &#123;this(null, false);&#125;</span><br><span class="line"> public Handler(boolean async) &#123;this(null, async);&#125;</span><br><span class="line"> public Handler(Callback callback) &#123;this(callback, false);&#125;</span><br><span class="line"> public Handler(boolean async) &#123;this(null, async);&#125;</span><br><span class="line"> public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">       if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">           final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">           if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                   (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">               Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                   klass.getCanonicalName());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	//Looper.myLooper()内部会调用sThreadLocal.get()，获取线程中保存的looper局部变量</span><br><span class="line">       mLooper = Looper.myLooper();</span><br><span class="line">       if (mLooper == null) &#123;</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">               &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">    //获取当前Looper中的MessageQueue</span><br><span class="line">       mQueue = mLooper.mQueue;</span><br><span class="line">       mCallback = callback;</span><br><span class="line">       mAsynchronous = async;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">//带Looper参数的构造函数</span><br><span class="line"> public Handler(Looper looper) &#123; this(looper, null, false); &#125;</span><br><span class="line"> public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false);&#125;</span><br><span class="line"> public Handler(Looper looper, Callback callback, boolean async) &#123;</span><br><span class="line">       mLooper = looper;</span><br><span class="line">       //获取当前Looper中的MessageQueue</span><br><span class="line">       mQueue = looper.mQueue;</span><br><span class="line">       mCallback = callback;</span><br><span class="line">       mAsynchronous = async;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在Handler的构造函数中，主要分为两种类型的构造函数，一种是带Looper参数的构造函数，一种是不带Looper参数的构造函数。</p>
<ul>
<li>在不带Looper参数的构造函数中，是通过Looper.myLooper()来获取当前Looper对象的（也就是说，Handler获取的Looper对象是与当前实例化当前Handler的线程相关的，那么如果Handler对象是在主线程中创建的，那么获取的就是主线程的Looper，<strong>注意前提条件当前线程线程已经通过Looper.prepare()与Looper.loop()构建了循环消息队列，因为只有调用了该方法后，才会将当前Looper对象放入线程的局部变量中</strong>）</li>
<li>在带Looper参数的构造函数中，Looper对象是通过外部直接传入的。（<strong>这里其实给我们提供了一个思路，也就是我们可以构建自己的消息处理循环，具体细节参看类HandlerThread)</strong></li>
</ul>
<h4 id="Handler怎么将消息发送到MessaageQueue-消息队列-中去"><a href="#Handler怎么将消息发送到MessaageQueue-消息队列-中去" class="headerlink" title="Handler怎么将消息发送到MessaageQueue(消息队列)中去"></a>Handler怎么将消息发送到MessaageQueue(消息队列)中去</h4><p>在了解Handler怎么将消息发送到MessageQueue(消息队列)，我们先来了解Handler的发消息的系列方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//发送及时消息</span><br><span class="line">public final boolean sendMessage(Message msg)</span><br><span class="line">public final boolean sendEmptyMessage(int what)</span><br><span class="line">public final boolean post(Runnable r)</span><br><span class="line"></span><br><span class="line">//发送延时消息</span><br><span class="line">public final boolean sendEmptyMessageDelayed(int what, long delayMillis)</span><br><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</span><br><span class="line">public final boolean postDelayed(Runnable r, long delayMillis)</span><br><span class="line"></span><br><span class="line">//发送定时消息</span><br><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis)</span><br><span class="line">public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis)</span><br><span class="line">public final boolean postAtTime(Runnable r, long uptimeMillis)</span><br></pre></td></tr></table></figure>
<p>在Handler发消息的方法中，我们可以总共发消息的种类，分为三种情况，第一种是及时消息，第二种是发送延时消息，第三种是定时消息。其中关于消息怎么在消息队列中排列与处理。具体的方法详解会在下篇文章《Android Handler机制之Message的发送与取出》具体介绍。</p>
<p>通过查看Handler发送消息的几个方法。我们发现内部都调用了MessageQueue的enqueueMessage（）方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">        msg.target = this;//设置message.target为当前Handler对象</span><br><span class="line">        if (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        return queue.enqueueMessage(msg, uptimeMillis);//获取当前MessageQueue.将消息加入队列中</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法内部其实很简单，就是获取当前MessageQueue对象，将消息将入消息队列中去了。其中需要大家需要的注意的是这段代码<strong>msg.target = this</strong>。该代码意思就是当前的消息保存着当前发送消息的Handler对象的应用。该行代码非常重要。因为最后涉及到消息的处理。</p>
<h4 id="Handler怎么处理消息"><a href="#Handler怎么处理消息" class="headerlink" title="Handler怎么处理消息"></a>Handler怎么处理消息</h4><p>通过上文的描述，现在我们已经大致了解Handler是怎么将消息加入到消息队列中去了，现在需要关心的是当前消息是怎么被处理的。大家还记的之前我们讲过的Looper原理吧，Looper会调用loop()方法循环的取消息。当取出消息后会调用message.target.dispatchMessage(Message msg)方法。其中message.target从上文我们已经知道了，就是当前发送消息的Handler。那么最终也就会回到Handler中的dispatchMessage（）方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback != null) &#123;//第一步，判断msg.callback</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback != null) &#123;//第二步、判断Handler的callBack</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);//第三步，执行Handler的handleMessage方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察该方法，我们可以得出，Handler中的dispatchMessage（）方法主要处理了三个步骤，下面分别对这三个步骤进行讲解</p>
<h4 id="第一步，执行message-callback"><a href="#第一步，执行message-callback" class="headerlink" title="第一步，执行message.callback"></a>第一步，执行message.callback</h4><p>在Handler中的dispatchMessage（）方法中，我们已经知道如果msg.callback != null,那么我们会直接走handleCallback(msg)方法。在了解该方法之前，首先我们要知道msg.callback对于的类是什么。这里我就直接给大家列出来了。其实msg.callback对应是以下四个方法的Runnable对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final boolean post(Runnable r)</span><br><span class="line">public final boolean postAtTime(Runnable r, long uptimeMillis)</span><br><span class="line">public final boolean postAtTime(Runnable r, Object token, long uptimeMillis)</span><br><span class="line">public final boolean postDelayed(Runnable r, long delayMillis)</span><br></pre></td></tr></table></figure></p>
<p>以上四个方法在发送Runnable对象时，都会调用getPostMessage(Runnable r) 方法，且该方法都会将Runnable封装在Message对象的callback属性上。具体如下getPostMessage(Runnable r) 方法所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">      Message m = Message.obtain();</span><br><span class="line">      m.callback = r;</span><br><span class="line">      return m;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在了解了Message的callback到底什么过后，我们再来看看handleCallback(Message message)方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static void handleCallback(Message message) &#123;</span><br><span class="line">       message.callback.run();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法其实很简单，就是调用相应Runnable的run()方法。</p>
<h4 id="第二步，执行Handler的callBack"><a href="#第二步，执行Handler的callBack" class="headerlink" title="第二步，执行Handler的callBack"></a>第二步，执行Handler的callBack</h4><p>如果当前Message.callback为空，接下来会判断Handler中的Callback回调是否为空，如果不为空则执行Callback的handleMessage(Message msg)方法。Callback的具体声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//避免创建Handler对象重新HandlerMessage方法，你可以直接传入Callback接口实现</span><br><span class="line">public interface Callback &#123;</span><br><span class="line">      public boolean handleMessage(Message msg);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中在Handler的几个构造函数中，可以传入相应Callback接口实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Callback callback) </span><br><span class="line">public Handler(Looper looper, Callback callback) </span><br><span class="line">public Handler(Callback callback, boolean async)</span><br><span class="line">public Handler(Looper looper, Callback callback, boolean async)</span><br></pre></td></tr></table></figure></p>
<h4 id="第三步，执行Handler的handleMessage）"><a href="#第三步，执行Handler的handleMessage）" class="headerlink" title="第三步，执行Handler的handleMessage）"></a>第三步，执行Handler的handleMessage）</h4><p>如果都不满足上面描述的第一、第二情况时，会最终调用Handler的handleMessage(Message msg)方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Handler内部该方法是空实现，需要子类具体实现</span><br><span class="line">public void handleMessage(Message msg) &#123;  &#125;</span><br></pre></td></tr></table></figure></p>
<p>为了方便大家记忆，我将Handler中的dispatchMessage（）具体的逻辑流程画了出来。大家按需观看。<br><img src="https://upload-images.jianshu.io/upload_images/2824145-d005ec9b8f4353b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatchMessage步骤.png"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>看到最后大家已经发现该篇文章主要着重于将Handler机制的整个流程，对于很多的代码细节并没有过多的描述，特别是关于Looper从MessageQueue（消息队列）中取消息与MessageQueue（消息队列）怎么放入消息的具体细节。不用担心，关于这两个知识点将会在下篇文章<a href="https://www.jianshu.com/p/219701879fe4" target="_blank" rel="noopener">《Android Handler机制之Message的发送与取出》</a>具体描述。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Android-Handler机制之Handler-、MessageQueue-、Looper/" data-id="cjsheb86r000kdsr7o5doyr9i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-BAT大厂Android面试知识点，请客官拿好" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/BAT大厂Android面试知识点，请客官拿好/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-b25f520b367237d1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bat.jpeg"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>年年寒冬，年年也挡不住一个安卓程序员追求大厂的决心。想要进入大厂，我们需要掌握哪些知识点呢？这里，我为大家梳理了一个整体的知识架构。整体包括Java、Android、算法、网络等，并且我也在相应知识点下推荐了与该知识点相关的书籍与博客。希望大家阅读之后，能帮助大家完善与整理自己的知识体系。祝大家早日进入自己理想的公司~~</p>
<blockquote>
<p>注意，整篇文章是知识点的概括，不包含答案，需要大家多看源码，知识只有自己去探索与发现，才会弥足珍贵！</p>
</blockquote>
<h3 id="Java基础知识点"><a href="#Java基础知识点" class="headerlink" title="Java基础知识点"></a>Java基础知识点</h3><h4 id="Jvm相关"><a href="#Jvm相关" class="headerlink" title="Jvm相关"></a>Jvm相关</h4><ul>
<li>Java内存结构及分区</li>
<li>Java对象的创建、存储及访问</li>
<li>Java判断对象是否存活及垃圾回收算法（GC）</li>
<li>Jvm中的常见的垃圾回收器</li>
<li>Java类加载过程</li>
<li>Java类加载器（双亲委派模型）</li>
</ul>
<p>推荐阅读：<br>《深入理解Java虚拟机JVM高级特性及最佳实践》 第二章 Java内存区域与内存溢出异常<br>《深入理解Java虚拟机JVM高级特性及最佳实践》 第三章 垃圾收集器与内存分配策略<br>《深入理解Java虚拟机JVM高级特性及最佳实践》 第六章 类文件结构<br>《深入理解Java虚拟机JVM高级特性及最佳实践》 第七章 虚拟机类加载机制<br>《Java虚拟机规范 JAVA SE 8版》</p>
<h4 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h4><ul>
<li>ArrayList分析</li>
<li>LinkedList分析</li>
<li>HashMap分析</li>
<li>HashTable分析</li>
<li>LinkedHashMap分析</li>
<li>HashSet分析</li>
<li>LinkedHashSet分析</li>
<li>ArrayMap、SparseMap、与HashMap的对比</li>
<li>ConcurrentHashMap分析</li>
</ul>
<p>推荐阅读<br>如果大家不嫌弃，可以看看我的–&gt;<a href="https://www.jianshu.com/p/9c12c4d5455d" target="_blank" rel="noopener">ArrayList分析</a><br>如果大家不嫌弃，可以看看我的–&gt;<a href="https://www.jianshu.com/p/bb4eda651703" target="_blank" rel="noopener">LinkedList分析</a><br>如果大家不嫌弃，可以看看我的–&gt;<a href="https://www.jianshu.com/p/345019b77571" target="_blank" rel="noopener">哈希表初识</a><br><a href="https://blog.csdn.net/justloveyou_/article/details/72862373" target="_blank" rel="noopener">彻头彻尾理解 HashTable</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=504261609&amp;idx=1&amp;sn=cdc762fe7c9050e7e9a2554d8c3337a4&amp;mpshare=1&amp;scene=23&amp;srcid=0217AGtnvS7RimagXJQkmTXc#rd" target="_blank" rel="noopener">美团技术团队-Java8系列之重新认识HashMap</a><br><a href="https://blog.csdn.net/justloveyou_/article/details/71713781" target="_blank" rel="noopener">Map 综述（二）：彻头彻尾理解 LinkedHashMap</a><br>《Java并发编程的艺术》第六章6.1节CocurrrentHashMap（基于JDK 1.6，1.7分析的）实现原理及使用<br><a href="https://www.jianshu.com/p/c0642afe03e0" target="_blank" rel="noopener">深入浅出ConcurrentHashMap1.8</a></p>
<h4 id="并发相关"><a href="#并发相关" class="headerlink" title="并发相关"></a>并发相关</h4><ul>
<li>Java内存模型</li>
<li>volatile原理</li>
<li>Synchronized的原理</li>
<li>AQS原理</li>
<li>Condition原理</li>
<li>ReentrantLock 原理</li>
<li>公平锁与非公平锁</li>
<li>ReentrantReadWriteLock原理</li>
</ul>
<p>推荐阅读：<br>《Java并发编程的艺术》第二章 Java并发机制的底层实现原理<br>《Java并发编程的艺术》第三章 内存模型<br>《Java并发编程的艺术》第五章 Java中的锁<br><a href="https://www.jianshu.com/p/355b91f7baa8" target="_blank" rel="noopener">Java并发编程之Java内存模型</a><br><a href="https://www.jianshu.com/p/0a82c764e694" target="_blank" rel="noopener">Java并发编程之Java CAS操作</a><br><a href="https://www.jianshu.com/p/e34469924714" target="_blank" rel="noopener">Java并发编程之Volatile</a><br><a href="https://www.jianshu.com/p/712e27f8c977" target="_blank" rel="noopener">Java并发编程之synchronized</a><br><a href="https://www.jianshu.com/p/4ead70bdab56" target="_blank" rel="noopener">Java并发编程之锁机制之引导篇</a><br><a href="https://www.jianshu.com/p/6874d9b4f3d8" target="_blank" rel="noopener"> Java并发编程之锁机制之Lock接口</a><br><a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener"> Java并发编程之锁机制之AQS(AbstractQueuedSynchronizer)</a><br><a href="https://www.jianshu.com/p/d0e84096d108" target="_blank" rel="noopener">Java并发编程之锁机制之LockSupport工具</a><br><a href="https://www.jianshu.com/p/a22855b8820a" target="_blank" rel="noopener">Java并发编程之锁机制之Condition接口</a><br><a href="https://www.jianshu.com/p/1068960ecd64" target="_blank" rel="noopener">Java并发编程之锁机制之重入锁</a><br><a href="https://www.jianshu.com/p/416e16eea7da" target="_blank" rel="noopener">Java并发编程之锁机制之读写锁</a></p>
<h4 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h4><ul>
<li>线程和进程的区别</li>
<li>线程的启动和终止</li>
<li>线程间通信</li>
<li>等待/通知机制</li>
</ul>
<p>推荐阅读：<br>《Java并发编程的艺术》第四章 Java并发编程基础</p>
<h4 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a>线程池相关</h4><ul>
<li>使用线程池的原因</li>
<li>线程池内部原理</li>
<li>线程池中的几种重要的参数及流程说明</li>
<li>线程池中几种常见的工作队列</li>
<li>几种常见的线程池及使用场景。</li>
</ul>
<p>推荐阅读：<br>《Java并发编程的艺术》第九章 Java中的线程池</p>
<h4 id="IO相关"><a href="#IO相关" class="headerlink" title="IO相关"></a>IO相关</h4><ul>
<li>IO相关面试问题-Socket</li>
<li>IO相关面试问题-BIO／NIO</li>
</ul>
<p>推荐阅读：<br><a href="https://blog.csdn.net/lirenzuo/article/details/78764696" target="_blank" rel="noopener">NIO相关基础篇一</a><br><a href="https://blog.csdn.net/lirenzuo/article/details/78838717" target="_blank" rel="noopener">NIO相关基础篇二</a><br><a href="https://blog.csdn.net/lirenzuo/article/details/78898430" target="_blank" rel="noopener">NIO相关基础篇三</a><br>《UNIX 网络编程，卷1：套接字联网API 第三版》第六章 I/O复用：select和poll<br>《深入理解Java虚拟机JVM高级特性及最佳实践》 第二章 Java内存区域与内存溢出异常 2.2.7节直接内存介绍</p>
<h3 id="Android基础知识点"><a href="#Android基础知识点" class="headerlink" title="Android基础知识点"></a>Android基础知识点</h3><h4 id="Activity相关"><a href="#Activity相关" class="headerlink" title="Activity相关"></a>Activity相关</h4><ul>
<li>典型状况下的生命周期 </li>
<li>异常情况下的生命周期</li>
<li>异常情况下的数据保存</li>
<li>各种情况下跳转到某个Activity时目标Activity及当前Activity的生命周期</li>
<li>Activity的启动模式及应用场景</li>
<li>进程和应用生命周期</li>
</ul>
<p>推荐阅读：<br>《Android开发艺术探索》 第一章 Activity的生命周期和启动模式<br>《Android开发艺术探索》 第九章 9.2节Activity的工作过程<br><a href="https://developer.android.google.cn/guide/components/activities/process-lifecycle" target="_blank" rel="noopener">Google-进程和应用生命周期</a><br><a href="https://developer.android.google.cn/guide/components/activities/tasks-and-back-stack" target="_blank" rel="noopener">Google-任务和返回栈</a></p>
<h4 id="Service相关"><a href="#Service相关" class="headerlink" title="Service相关"></a>Service相关</h4><ul>
<li>Service的定义及作用</li>
<li>Service两种启动方式  startService、 bindService 区别及生命周期</li>
<li>Service绑定服务的三种实现方式，扩展Binder类、使用Messenger、使用AIDL</li>
<li>关于启动服务与绑定服务间的转换问题 先绑定服务后启动服务、先启动服务后绑定服务</li>
<li>服务Service与线程Thread的区别</li>
<li>Android 5.0以上的隐式启动问题及其解决方案</li>
<li>如何保证服务不被杀死</li>
<li>IntentService的使用及原理</li>
</ul>
<p>推荐阅读：<br>《Android开发艺术探索》 第九章 9.3节Service的工作过程<br><a href="https://blog.csdn.net/javazejian/article/details/52709857" target="_blank" rel="noopener">关于Android Service真正的完全详解，你需要知道的一切</a><br><a href="https://blog.csdn.net/javazejian/article/details/52426425" target="_blank" rel="noopener">Android 多线程之IntentService 完全详解</a><br><a href="https://blog.csdn.net/javazejian/article/details/52426353" target="_blank" rel="noopener">Android 多线程之HandlerThread 完全详解</a></p>
<h4 id="BroadcastReceiver相关"><a href="#BroadcastReceiver相关" class="headerlink" title="BroadcastReceiver相关"></a>BroadcastReceiver相关</h4><ul>
<li>BroadcastReceiver定义及作用、应用场景</li>
<li>BroadcastReceiver的注册方式，静态方式、动态方式</li>
<li>BroadcastReceiver注册与取消的时机</li>
<li>BroadcastReceiver的不同类型，普通广播，系统广播、有序广播、粘性广播、应用类广播</li>
</ul>
<p>推荐阅读：<br>《Android开发艺术探索》 第九章 9.4节BroadcastReceiver 的工作过程<br><a href="https://www.jianshu.com/p/ca3d87a4cdf3" target="_blank" rel="noopener">BroadcastReceiver史上最全面解析</a><br><a href="https://developer.android.google.cn/guide/components/broadcasts" target="_blank" rel="noopener">广播在7.0、8.0、9.0下的适配</a></p>
<h4 id="Fragment相关"><a href="#Fragment相关" class="headerlink" title="Fragment相关"></a>Fragment相关</h4><ul>
<li>Fragment生命周期</li>
<li>Fragment的懒加载 </li>
<li>Fragment之间的通信</li>
<li>FragmentPagerAdapter与FragmentStatePagerAdapter的区别</li>
<li>为什么不建议直接通过使用new Fragment的方式传入数据</li>
</ul>
<p>推荐阅读：<br><a href="https://www.jianshu.com/p/d9143a92ad94" target="_blank" rel="noopener">Fragment全解析系列（一）：那些年踩过的坑</a><br><a href="https://developer.android.google.cn/guide/components/fragments" target="_blank" rel="noopener">Google-Fragment概览</a><br><a href="https://developer.android.google.cn/training/basics/fragments/communicating" target="_blank" rel="noopener">Google-与其他Fragment通信</a></p>
<h4 id="序列化相关"><a href="#序列化相关" class="headerlink" title="序列化相关"></a>序列化相关</h4><ul>
<li>序列化与反序列化的定义及区别</li>
<li>Serializable中serialVersionUID及transient关键字的作用</li>
<li>序列化：Parcelable和Serializable差异</li>
</ul>
<p>推荐阅读：<br><a href="https://blog.csdn.net/javazejian/article/details/52665164" target="_blank" rel="noopener">序列化与反序列化之Parcelable和Serializable浅析</a><br>《Android开发艺术探索》 第二章 IPC基础概念介绍</p>
<h4 id="IPC相关"><a href="#IPC相关" class="headerlink" title="IPC相关"></a>IPC相关</h4><ul>
<li>在Android中什么样的情况下会使用多进程模式，如何开启多进程</li>
<li>Android为什么采用Binder做为IPC机制</li>
<li>IPC常用方式 使用Bundle、使用文件共享、使用Messenger、使用AIDL、使用ContentProvider、使用Socket </li>
<li>AIDL的语义</li>
<li>AIDL如何创建</li>
<li>AIDL生成Java文件详细分析</li>
</ul>
<p>推荐阅读：<br>《Android开发艺术探索》 第二章 IPC机制<br>《深如理解LINUX内核 第三版涵盖2.6版》 第三章 进程 3.2节进程描述符<br><a href="https://www.jianshu.com/p/429a1ff3560c" target="_blank" rel="noopener">写给 Android 应用工程师的 Binder 原理剖析</a><br><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">如果需要深入了解，推荐GitYuan大大的 Binder 系列文章</a></p>
<h4 id="View事件机制相关"><a href="#View事件机制相关" class="headerlink" title="View事件机制相关"></a>View事件机制相关</h4><ul>
<li>View的坐标体系</li>
<li>View滑动的几种方式，使用ScrollTo/ScrollBy、使用动画、改变布局参数</li>
<li>弹性滑动的原理及实现 </li>
<li>View的事件分发机制，点击事件的传递规则，事件分发的源码解读</li>
<li>处理滑动冲突的场景及解决方法</li>
</ul>
<p>推荐阅读：<br>《Android开发艺术探索》 第三章 View的事件体系</p>
<h4 id="View绘制相关"><a href="#View绘制相关" class="headerlink" title="View绘制相关"></a>View绘制相关</h4><ul>
<li>DecorView、Window、ViewRootImpl等概念</li>
<li>MeasureSpec概念</li>
<li>View的工作流程，measure过程、layout过程、draw过程</li>
<li>自定义View需要注意的事项</li>
<li>Activity、Window、View三者之间的关系</li>
</ul>
<p>推荐阅读：<br>《Android开发艺术探索》第四章 View的工作原理<br>《Android开发艺术探索》第八章 理解Window和WindowManager<br><a href="https://blog.csdn.net/harvic880925/article/details/50995268" target="_blank" rel="noopener">Android自定义控件三部曲文章索引</a></p>
<h4 id="View动画相关"><a href="#View动画相关" class="headerlink" title="View动画相关"></a>View动画相关</h4><ul>
<li>常用动画View动画（补间动画）、属性动画与帧动画</li>
<li>补间动画与属性动画区别</li>
<li>差值器和估值器理解</li>
<li>属性动画的工作原理</li>
</ul>
<p>推荐阅读：<br><a href="https://blog.csdn.net/harvic880925/article/details/50995268" target="_blank" rel="noopener">Android自定义控件三部曲文章索引</a><br>《Android开发艺术探索》 第七章 Android动画深入分析</p>
<h4 id="Handler相关"><a href="#Handler相关" class="headerlink" title="Handler相关"></a>Handler相关</h4><ul>
<li>Handler机制之ThreadLocal</li>
<li>Handler机制之Looper、Handler、消息队列如何理解</li>
<li>Handler机制之Message的发送与取出</li>
<li>Handler机制之Message及Message的回收机制</li>
<li>Handler机制之循环消息队列的退出</li>
<li>Handler机制之内存泄漏</li>
<li>Handler机制之IdleHandle的理解及使用</li>
</ul>
<p>推荐阅读：<br>《Android开发艺术探索》第十章 10.2节 Android的消息机制<br>IdleHandle的奇思妙想—–&gt;<a href="https://mp.weixin.qq.com/s/KpeBqIEYeOzt_frANoGuSg" target="_blank" rel="noopener">你知道android的MessageQueue.IdleHandler吗？</a><br>Handler面试常问题目—–&gt;<a href="https://www.jianshu.com/p/f70ee1765a61" target="_blank" rel="noopener">你真的懂Handler吗？Handler问答</a><br>如果大家不嫌弃，可以看看我的Handler机制总结—–&gt;<a href="https://www.jianshu.com/p/43bb31d8a742" target="_blank" rel="noopener">Anroid Handler机制总目录</a></p>
<h4 id="AsyncTask相关"><a href="#AsyncTask相关" class="headerlink" title="AsyncTask相关"></a>AsyncTask相关</h4><ul>
<li>AsyncTask的使用和注意事项</li>
<li>AsyncTask几个重要的方法 doInBackgound、onProgressUpdate、onPostExecute等</li>
<li>AsyncTask的工作原理及源码理解</li>
</ul>
<p>推荐阅读：<br>《Android开发艺术探索》第十一章 Android的线程和线程池<br>《Java并发编程的艺术》第九章 Java中的线程池，第十章 Executor框架</p>
<h4 id="Bitmap压缩机回收相关"><a href="#Bitmap压缩机回收相关" class="headerlink" title="Bitmap压缩机回收相关"></a>Bitmap压缩机回收相关</h4><ul>
<li>Bitmap所占内存</li>
<li>常用压缩图片方式</li>
<li>LruCache原理</li>
<li>DiskLruCache原理</li>
<li>LinkedHashMap原理</li>
</ul>
<p>推荐阅读：<br><a href="https://mp.weixin.qq.com/s/ufOjtKURP8QERWw1pn_m1Q" target="_blank" rel="noopener">图片占内存公式：分辨率 * 每个像素大小，严谨吗？</a><br><a href="https://github.com/Curzibn/Luban" target="_blank" rel="noopener">鲁班图片压缩</a><br><a href="https://blog.csdn.net/justloveyou_/article/details/71713781" target="_blank" rel="noopener">Map 综述（二）：彻头彻尾理解 LinkedHashMap</a></p>
<h4 id="ListView与RecyclerView相关"><a href="#ListView与RecyclerView相关" class="headerlink" title="ListView与RecyclerView相关"></a>ListView与RecyclerView相关</h4><ul>
<li>ListView的原理和复用机制</li>
<li>ListView和RecyclerView的区别</li>
</ul>
<p>推荐阅读：<br><a href="https://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="noopener">Android ListView工作原理完全解析，带你从源码的角度彻底理解</a><br><a href="https://juejin.im/post/5a7569676fb9a063435eaf4c" target="_blank" rel="noopener">深入理解Android中的缓存机制(二)RecyclerView跟ListView缓存机制对比</a></p>
<h4 id="数据存储相关"><a href="#数据存储相关" class="headerlink" title="数据存储相关"></a>数据存储相关</h4><ul>
<li>常用数据库框架GreenDao,官方Room</li>
<li>数据库数据迁移问题</li>
<li>GreenDao中一对一，一对多，多对多关系</li>
<li>SharedPreferences使用及源码，commit与apply()方法的区别</li>
</ul>
<p>推荐阅读：<br><a href="https://code.tutsplus.com/articles/sql-for-beginners--net-8200" target="_blank" rel="noopener">数据库基础1</a><br><a href="https://code.tutsplus.com/articles/sql-for-beginners-part-2--net-8274" target="_blank" rel="noopener">数据库基础2</a><br><a href="https://code.tutsplus.com/articles/sql-for-beginners-part-3-database-relationships--net-8561" target="_blank" rel="noopener">数据库基础3</a><br><a href="http://greenrobot.org/greendao/documentation/" target="_blank" rel="noopener">GreenDao官方帮助文档</a><br><a href="https://juejin.im/post/5c34615bf265da614171bf8a" target="_blank" rel="noopener">面试高频题：一眼看穿 SharedPreferences</a><br><a href="https://stackoverflow.com/questions/13373170/greendao-schema-update-and-data-migration/30334668#30334668" target="_blank" rel="noopener">GreenDao数据库迁移帮助类 MigrationHelper </a></p>
<h3 id="Android开源框架知识点"><a href="#Android开源框架知识点" class="headerlink" title="Android开源框架知识点"></a>Android开源框架知识点</h3><h4 id="OkHttp相关"><a href="#OkHttp相关" class="headerlink" title="OkHttp相关"></a>OkHttp相关</h4><ul>
<li>OkHttp的优点</li>
<li>OkHttp执行请求的整个流程</li>
<li>OkHttp中的拦截器</li>
<li>OkHttp中的同步请求与异步请求的理解及其源码</li>
<li>OkHttp中涉及到的设计模式</li>
<li>OkHttp底层网络请求实现，socket还是URLConnection</li>
</ul>
<p>推荐阅读：<br><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/index.html" target="_blank" rel="noopener">拆轮子系列-拆OkHttp</a></p>
<h4 id="Retrofit相关"><a href="#Retrofit相关" class="headerlink" title="Retrofit相关"></a>Retrofit相关</h4><ul>
<li>Retrofit执行请求的整个流程</li>
<li>Retrofit中ConverterFactory、CallAdapterFactory的理解</li>
<li>Retrofit中CallAdapter的适配器模式</li>
</ul>
<p>推荐阅读：<br><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/index.html" target="_blank" rel="noopener">拆轮子系列：拆Retrofit</a></p>
<h4 id="RxJava相关"><a href="#RxJava相关" class="headerlink" title="RxJava相关"></a>RxJava相关</h4><ul>
<li>RxJava常用创建操作符 create、from、just、interval、range等</li>
<li>RxJava常用组合、合并操作符 combineLatest、join、merge、zip等</li>
<li>RxJava错误处理操作符 onErrorReturn、onErrorResumeNext、onExceptionResumeNext等</li>
<li>RxJava过滤操作符 filter、ofType、sample、take等</li>
<li>Rxjava背压相关理解</li>
<li>RxJava实际开发中的使用：网络请求轮询、网络请求嵌套回调、从磁盘 / 内存缓存中 获取缓存数据等</li>
</ul>
<p>推荐阅读：<br><a href="https://www.jianshu.com/p/a406b94f3188" target="_blank" rel="noopener">Android Rxjava：这是一篇 清晰 &amp; 易懂的Rxjava 入门教程</a><br>如果大家想直接写Demo，这里我已经写好了一份—&gt;<a href="https://github.com/AndyJennifer/RxJavaSummary" target="_blank" rel="noopener">RxJava操作符总结</a></p>
<h4 id="Glide相关"><a href="#Glide相关" class="headerlink" title="Glide相关"></a>Glide相关</h4><ul>
<li>Glide的执行流程</li>
<li>Glide的缓存机制</li>
<li>Glide图片转换</li>
<li>Glide带进度的图片加载功能</li>
<li>Glide内存、磁盘缓存，优先级使用</li>
</ul>
<p>推荐阅读：<br><a href="https://blog.csdn.net/guolin_blog/article/details/53759439" target="_blank" rel="noopener">Android图片加载框架最全解析（一），Glide的基本用法</a><br><a href="https://blog.csdn.net/guolin_blog/article/details/53939176" target="_blank" rel="noopener">Android图片加载框架最全解析（二），从源码的角度理解Glide的执行流程</a><br><a href="https://blog.csdn.net/guolin_blog/article/details/54895665" target="_blank" rel="noopener">Android图片加载框架最全解析（三），深入探究Glide的缓存机制</a><br><a href="https://blog.csdn.net/guolin_blog/article/details/70215985" target="_blank" rel="noopener">Android图片加载框架最全解析（四），玩转Glide的回调与监听</a><br><a href="https://blog.csdn.net/guolin_blog/article/details/71524668" target="_blank" rel="noopener">Android图片加载框架最全解析（五），Glide强大的图片变换功能</a><br><a href="https://blog.csdn.net/guolin_blog/article/details/78179422" target="_blank" rel="noopener">Android图片加载框架最全解析（六），探究Glide的自定义模块功能</a></p>
<h4 id="ButterKnife相关"><a href="#ButterKnife相关" class="headerlink" title="ButterKnife相关"></a>ButterKnife相关</h4><ul>
<li>Java注解相关Annotation</li>
<li>Java注解相关之APT工具</li>
<li>ButterKnife注解框架原理</li>
</ul>
<p>推荐阅读：<br><a href="https://www.jianshu.com/p/fcba7013b0b0" target="_blank" rel="noopener">Android 注解系列之APT工具（三）</a><br><a href="https://www.jianshu.com/p/65c4af2ce8f0" target="_blank" rel="noopener">Android 注解系列之Annotation（二）</a><br><a href="https://www.jianshu.com/p/39fc66aa3297" target="_blank" rel="noopener">ButterKnife 原理解析</a></p>
<h4 id="EventBus相关"><a href="#EventBus相关" class="headerlink" title="EventBus相关"></a>EventBus相关</h4><ul>
<li>EventBus原理，及索引类的使用</li>
</ul>
<p>推荐阅读：<br><a href="https://www.jianshu.com/p/fcba7013b0b0" target="_blank" rel="noopener">Android 注解系列之APT工具（三）</a><br><a href="https://www.jianshu.com/p/65c4af2ce8f0" target="_blank" rel="noopener">Android 注解系列之Annotation（二）</a><br><a href="https://blog.csdn.net/Tencent_Bugly/article/details/51354693" target="_blank" rel="noopener">腾讯Bugly干货-老司机教你“飙”EventBus3</a></p>
<h3 id="Android性能优化"><a href="#Android性能优化" class="headerlink" title="Android性能优化"></a>Android性能优化</h3><ul>
<li>性能优化:布局优化、绘制优化、线程优化等</li>
<li>ANR异常:主线程执行了耗时操作，如BroadcastReceiver(前台广播10s,后台广播为60s)、Service(前台20s,后台200s)没有处理完相关任务等</li>
<li>OOM异常：内存溢出的原因</li>
<li>内存泄漏：内存泄露的几种场景，如单例模式引出的泄露、静态变量导致的泄露、属性动画导致的内存泄露等</li>
</ul>
<p>推荐阅读：<br>《Android开发艺术探索》第十五章 Android性能优化<br><a href="https://developer.android.google.cn/studio/profile/memory-profiler.html#record-allocations" target="_blank" rel="noopener">Memory Profiler的使用</a><br><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary库相关介绍</a></p>
<h3 id="Android打包知识点"><a href="#Android打包知识点" class="headerlink" title="Android打包知识点"></a>Android打包知识点</h3><ul>
<li>安卓签名的理解</li>
<li>Gradle多渠道打包</li>
</ul>
<p>推荐阅读：<br>《Android Gradle权威指南》</p>
<h3 id="Android架构知识点"><a href="#Android架构知识点" class="headerlink" title="Android架构知识点"></a>Android架构知识点</h3><ul>
<li>MVC架构设计模式面试问题讲解</li>
<li>MVP架构设计模式面试问题讲解 </li>
<li>MVVM架构设计模式面试问题讲解</li>
</ul>
<p>推荐阅读：<br><a href="https://en.wikipedia.org/wiki/Model–view–presenter" target="_blank" rel="noopener">mvp架构设计</a><br><a href="https://en.wikipedia.org/wiki/Model–view–viewmodel" target="_blank" rel="noopener">mvvm架构设计</a><br><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">googlesamples/android-architecture</a></p>
<h3 id="Android不同版本特性知识点"><a href="#Android不同版本特性知识点" class="headerlink" title="Android不同版本特性知识点"></a>Android不同版本特性知识点</h3><p>推荐阅读：<br><a href="https://developer.android.google.cn/about/versions/pie/" target="_blank" rel="noopener">Android不同版本下的特性</a><br><a href="https://developer.android.google.cn/guide/components/broadcasts" target="_blank" rel="noopener">广播在7.0、8.0、9.0下的适配</a><br><a href="https://developer.android.google.cn/guide/topics/permissions/overview" target="_blank" rel="noopener">Android 6.0 权限下的适配</a><br><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-changes" target="_blank" rel="noopener">Android 7.0 应用共享文件（FileProvider)</a><br><a href="https://developer.android.google.cn/reference/android/support/v4/content/FileProvider.html" target="_blank" rel="noopener">Android 7.0 共享文件的使用方式</a></p>
<h3 id="网络知识点"><a href="#网络知识点" class="headerlink" title="网络知识点"></a>网络知识点</h3><ul>
<li>计算机网络三种体系架构，OSI体系架构（7层）、TCP/IP体系架构(4层)，五层体系架构</li>
<li>TCP的连接管理（三报文握手，四报文握手）</li>
<li>TCP与UDP的理解与区别</li>
<li>Http（HyberText Transfer Protocol）基本概念及报文结构</li>
<li>Http常见错误码</li>
<li>Http1.0与Http1.1与Http2.0的区别</li>
<li>Http中get请求与post请求的区别</li>
<li>Http中cookie与session的区别</li>
<li>Http与Https的区别</li>
<li>Https加密算法相关面试问题，签名证书，公钥私钥、数字摘要的理解</li>
</ul>
<p>推荐阅读：<br>体系架构—&gt;《计算机网络第七版 谢希仁》第一章 1.7.1节到1.7.5节<br>TCP三报文握手与四报文握手—&gt;《计算机网络第七版 谢希仁》第五章 5.9节 TCP的运输连接管理<br>TCP与UDP理解—&gt;《计算机网络第七版 谢希仁》 第五章 运输层<br>《计算机网络第七版 谢希仁》 第六章 应用层 第七章 网络安全<br><a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A" target="_blank" rel="noopener">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a><br><a href="https://www.jianshu.com/p/45d27f3e1196" target="_blank" rel="noopener">清晰的计算机网络基础 学习指南</a></p>
<h3 id="设计模式知识点"><a href="#设计模式知识点" class="headerlink" title="设计模式知识点"></a>设计模式知识点</h3><ul>
<li>单例模式 </li>
<li>Builder模式</li>
<li>装饰模式</li>
<li>策略模式</li>
<li>模板方法</li>
<li>观察者模式</li>
<li>等…..</li>
</ul>
<p>推荐阅读：<br>《Android源码设计模式解析与实战》</p>
<h3 id="算法知识点"><a href="#算法知识点" class="headerlink" title="算法知识点"></a>算法知识点</h3><ul>
<li>常见的八大排序方式</li>
<li>时间复杂度的计算</li>
<li>链表相关算法，链表翻转，链表合并等</li>
<li>二叉树相关算法前序、中序、后序遍历（递归，迭代）</li>
<li>红黑树与BL树</li>
<li>等</li>
</ul>
<p>推荐阅读：<br>《Java 数据结构和算法 第二版》<br><a href="https://juejin.im/post/5bbb5754e51d450e8d769e80" target="_blank" rel="noopener">时间复杂度学习（上)</a><br><a href="https://juejin.im/post/5bbd79a0f265da0aa74f46a6" target="_blank" rel="noopener">时间复杂度学习（下)</a><br>刷题—-&gt;<a href="https://leetcode.com/" target="_blank" rel="noopener">LeetCode</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/BAT大厂Android面试知识点，请客官拿好/" data-id="cjsheb86s000ldsr7qefg0xv3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程之Java-CAS操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之Java-CAS操作/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-edf382cbd2befdee.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="你猜.jpeg"></p>
<blockquote>
<p>该文章属于《Java并发编程》系列文章，如果想了解更多，请点击《Java并发编程之总目录》</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上一篇文章中我们描述过，物理机计算机的数据缓存不一致的时候，我们一般采用两种方式来处理。一，通过总线加锁的形式，二，通过缓存一致性协议来操作。而体现缓存一致性的正是CAS操作，CAS操作在整个Java并发框架中起着非常重要的作用。如果大家能把CAS的由来和原理彻底搞清楚，我相信对于其他关于Java中并发的问题都能迎刃而解。</p>
<h3 id="缓存锁"><a href="#缓存锁" class="headerlink" title="缓存锁"></a>缓存锁</h3><p>在<a href="https://www.jianshu.com/p/355b91f7baa8" target="_blank" rel="noopener">Java并发编程之Java内存模型</a>文章中，在物理机计算机中当处理器中数据缓存不一致的时候，一般采用总线锁。但是总线锁把CPU和内存之前的通信锁住了，那么在锁定期间，其他的处理器是不能操作其他内存地址的数据。所以总线锁的开销比较大， 所以随着技术的进步，现在计算机已经采用了缓存锁来替代总线锁来进行性能的优化。</p>
<h4 id="缓存锁的原理"><a href="#缓存锁的原理" class="headerlink" title="缓存锁的原理"></a>缓存锁的原理</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-b514647393adbdb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cpu高速缓存.jpg"></p>
<p>我们都知道在CPU数据处理中，频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么数据的操作都在处理器内部缓存中进行。并不需要声明总线锁，在目前的处理器中可以使用“缓存锁定”的方式来处理数据不一致的情况，这里所谓的“缓存锁定”是指内存区域如果被缓存在处理器的缓存中，并且在操作期间被锁定，那么当它执行锁操作会写到内存时，处理器并不会像锁总线的那样声明LOCK#信号，而是修改其对应的内存地址。同时最重要的是<strong>其允许缓存一致性来保证数据的一致性。</strong></p>
<blockquote>
<p>缓存一致性核心思想：在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理通过嗅探在总线上传播的数据来检查自己的缓存的值是不是过期了，当处理器发现自己缓存的数据对应的内存地址被修改，就会将当前处理器缓存的数据处理为无效，当处理器对这个数据进行修改的操作的时候，会重新从系统内存中把数据读到处理器缓存中。</p>
</blockquote>
<h3 id="缓存锁与CAS-Compare-and-Swap-的关系"><a href="#缓存锁与CAS-Compare-and-Swap-的关系" class="headerlink" title="缓存锁与CAS(Compare-and-Swap)的关系"></a>缓存锁与CAS(Compare-and-Swap)的关系</h3><p>为了实现缓存锁，在物理计算机中，Intel处理器提供了很多Lock<strong>前缀</strong>（注意是带Lock前缀，前缀，前缀）的指令。例如，位测试和修改指令：BTS、BTR、BTC；交换指令XADD、<strong>CMPXCHG</strong>，以及其他一些操作数和逻辑指令（如ADD、OR）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。（不同的处理器实现缓存锁的指令不同，在sparc-TSO使用casa指令，而在ARM和PowerPc架构下，则需要使用一对ldrex/strex指令。）</p>
<p>而在Java中涉及到缓存锁的主要是CAS操作，CAS操作正是使用了不同处理器下提供的缓存锁的指令。</p>
<h3 id="CAS-Compare-and-Swap-简介"><a href="#CAS-Compare-and-Swap-简介" class="headerlink" title="CAS(Compare-and-Swap)简介"></a>CAS(Compare-and-Swap)简介</h3><p>CAS指令需要三个操作数，分别是内存地址（<strong>在Java内存模型中可以简单理解为主内存中变量的内存地址</strong>）、旧值（<strong>在Java内存模型中，可以理解工作内存中缓存的主内存的变量的值</strong>）和新值。CAS操作执行时，当且仅当主内存对应的值等于旧值时，处理器用新值去更新旧值，否则它就不执行更新。但是无论是否更新了主内存中的值，都会返回旧值，上述的处理过程是一个原子操作。</p>
<p>对于概念类的东西，大家理解起来比较困难，这里简单举个例子如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-fa9d21aa7e16f0df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CAS操作与缓存一致性.png"><br>在上图中，分别有两条线程A与B，<strong>其中线程A优先与线程B执行a++操作</strong>，,线程A工作内存缓存a的值为10，主内存中的a的值也为10，这个时候如果进行CAS操作，会与主内存中的a的值进行对比，如果相等会将执行a++操作后的值也就是11同步到主内存中，这个时候主内存中的值为11。当线程A执行完后，线程B接着执行，可是线程B中工作内存中缓存的a的值为8，根据缓存一致性原则。会重新去主内存读取a的值（11），此时线程B中工作内存中缓存的a的值为11，接着执行a++运算后a的值为12，此时将a的值12同步到主内存中。</p>
<h4 id="CAS在Java中的实现"><a href="#CAS在Java中的实现" class="headerlink" title="CAS在Java中的实现"></a>CAS在Java中的实现</h4><p>在Java中，CAS操作由sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()，compareAndSwapObject几个方法实现。这里我们就使用compareAndSwapInt来讲解，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//native层</span><br><span class="line"> private static final jdk.internal.misc.Unsafe theInternalUnsafe</span><br><span class="line">  = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  public final boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                         int expected,</span><br><span class="line">                                         int x) &#123;</span><br><span class="line">      return theInternalUnsafe.compareAndSetInt(o, offset, expected, x);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在sun.misc.Unsafe方法中，compareAndSwapInt有4个参数，第一个参数object是当前对象，第二个参数offest表示该变量在内存中的偏移地址（CAS底层是根据内存偏移位置来获取的），第三个参数expected为旧值，第四个参数x为新值。在该方法具体的细节是交给jdk.internal.misc.Unsafe类的compareAndSetInt（）方法来处理的。继续查看theInternalUnsafe下的compareAndSetInt（）方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSetInt(Object o, long offset,</span><br><span class="line">                                                int expected,</span><br><span class="line">                                                int x);</span><br></pre></td></tr></table></figure></p>
<p>在jdk.internal.misc.Unsafe中的compareAndSetInt也是一个本地方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public final native boolean compareAndSetInt(Object o, long offset,</span><br><span class="line">                                             int expected,</span><br><span class="line">                                             int x);</span><br></pre></td></tr></table></figure></p>
<p>这里具体的本地方法是在hotspot下的unsafe.cpp类具体实现的。compareAndSetInt调用unsafe.cpp中的JNI方法具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) &#123;</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  if (p == NULL) &#123;</span><br><span class="line">    volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);</span><br><span class="line">    return RawAccess&lt;&gt;::atomic_cmpxchg(x, addr, e) == e;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    assert_field_offset_sane(p, offset);</span><br><span class="line">    return HeapAccess&lt;&gt;::atomic_cmpxchg_at(x, p, (ptrdiff_t)offset, e) == e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; UNSAFE_END</span><br></pre></td></tr></table></figure></p>
<p>unsafe.cpp最终会调用atomic.cpp而atomic.cpp会根据不同的处理调用不同的处理器指令，这里我们还是以Intel的处理器为例，atomic.cpp最终会调用atomic_windows_x86.cpp中的operator()方法。（这里我省略了unsafe.cpp与atomic.cpp的内部细节，本身这里对C++也不是很很熟，不想误导大家，如果大家对源码比较感兴趣，这里把相关jdk源码分享给大家<a href="https://pan.baidu.com/s/1Lk9yp8cEpSAnLvw5NJdqZg" target="_blank" rel="noopener">jdk源码</a>）。</p>
<p>atomic_windows_x86.cpp中operator()方法具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline T Atomic::PlatformCmpxchg&lt;4&gt;::operator()(T exchange_value,</span><br><span class="line">                                                T volatile* dest,</span><br><span class="line">                                                T compare_value,</span><br><span class="line">                                                atomic_memory_order order) const &#123;</span><br><span class="line">  STATIC_ASSERT(4 == sizeof(T));</span><br><span class="line">  // alternative for InterlockedCompareExchange</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx, dest </span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value</span><br><span class="line">    lock cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单的对atomic_windows_x86.cpp中的operator()的方法进行介绍，第一个参数exchange_value为新值，第二个参数volatile* dest为变量内存地址（也就是主内存中变量地址），第三个参数compare_value为旧值（也就是工作内存中缓存的变量值）。其中在方法中，<strong>asm是C++中的关键字</strong>，主要作用为启动内联汇编，同时其能写在任何C++合法语句之处。它不能单独出现，必须接汇编指令、一组被大括号包含的指令或一对空括号。</p>
<p>那么针对于operrator中的汇编语句块进行分析，要内容分为四个部分（这里我们就把edx，ecx，eax当做存储数据的容器）：</p>
<ol>
<li>mov edx, dest 将变量的内存地址赋值到edx中。</li>
<li>mov ecx, exchange_value 将新值赋值到ecx中。</li>
<li>mov eax,compare_value  将旧值赋值到eax中。</li>
<li>lock cmpxchg dword ptr [edx], ecx  ，在了解该语句之前，我们先说三个知识点：</li>
</ol>
<p><strong>cmpxchg汇编指令:</strong>主要操作逻辑是比较eax与第一操作数的值，如果相等，那么第二操作数的值装载到第一操作数，如果不相等，那么第一操作数的值装载到eax中，其中cmpxchg 格式如下：cmpxchg 第一操作数,第二个操作数。举个例子:</p>
<h5 id="eax对应的值与第一操作数的值相等"><a href="#eax对应的值与第一操作数的值相等" class="headerlink" title="eax对应的值与第一操作数的值相等"></a>eax对应的值与第一操作数的值相等</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">	int a=0,b=0,c=0;</span><br><span class="line"> </span><br><span class="line">	__asm&#123;</span><br><span class="line">		mov eax,100; //eax 赋值为100</span><br><span class="line">		mov a,eax; //将eax的值赋值给变量a，那么a的值为100</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;a := &quot; &lt;&lt; a &lt;&lt; endl;//打印a的值</span><br><span class="line">	b = 99;</span><br><span class="line">	c = 11;</span><br><span class="line">	__asm&#123;</span><br><span class="line">		mov ebx,b //ebx赋值为99</span><br><span class="line">		cmpxchg c,ebx// eax为100，c为11，不相等，那么eax的值为11</span><br><span class="line">		mov a,eax //将eax的值赋值给变量a，那么a最终的值为11</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;b := &quot; &lt;&lt; b &lt;&lt; endl;//打印b的值</span><br><span class="line">	cout &lt;&lt; &quot;c := &quot; &lt;&lt; c &lt;&lt; endl;//打印c的值</span><br><span class="line">	cout &lt;&lt; &quot;a := &quot; &lt;&lt; a &lt;&lt; endl;//打印a的值</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应输出结果为a= 100,b=99,c =99,a =11。</p>
<h5 id="eax对应的值与第一操作数的值不相等"><a href="#eax对应的值与第一操作数的值不相等" class="headerlink" title="eax对应的值与第一操作数的值不相等"></a>eax对应的值与第一操作数的值不相等</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int a=0,b=0,c=0;</span><br><span class="line"> </span><br><span class="line">	__asm&#123;</span><br><span class="line">		mov eax,100;</span><br><span class="line">		mov a,eax// a的值为99</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;a := &quot; &lt;&lt; a &lt;&lt; endl;//打印a的值</span><br><span class="line">	b = 99;</span><br><span class="line">	c = 99;</span><br><span class="line">	__asm&#123;</span><br><span class="line">		mov eax,99 //eax 值为99</span><br><span class="line">		mov ebx,777// ebx 值为777</span><br><span class="line">		cmpxchg c,ebx// 比较eax与c的值，相等 那么c对应的值为ebx的值，也就是777</span><br><span class="line">		mov a,eax//将eax的值赋值给变量a </span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;b := &quot; &lt;&lt; b &lt;&lt; endl;//打印b的值</span><br><span class="line">	cout &lt;&lt; &quot;c := &quot; &lt;&lt; c &lt;&lt; endl;//打印c的值</span><br><span class="line">	cout &lt;&lt; &quot;a := &quot; &lt;&lt; a &lt;&lt; endl;//打印a的值</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应输出结果为a= 100,b=99,c =777,a =99。</p>
<p><strong>dword汇编指令：</strong>dword ptr [edx] 简单来说，就是获取edx中内存地址中的具体的数据值。</p>
<p><strong>lock汇编指令</strong>：lock指令做的事情比较多。这里要分为三个部分。</p>
<ul>
<li>在Pentium及之前的处理器中，带有lock前缀的指令在执行期间会锁住总线。在新的处理器中，Intel使用缓存锁定来保证指令执行的原子性，缓存锁定将大大降低lock前缀指令的执行开销。</li>
<li>禁止该指令与前面和后面的读写指令重排序。</li>
<li>把写缓冲区的所有数据刷新到内存中。<br>额外提一句。上面的第2点和第3点所具有的内存屏障效果，保证了CAS同时具有volatile读和volatile写的内存语义。</li>
</ul>
<p>在了解了上诉知识点后，我们再来理解语句4就很好理解了。如果主内存中的值与旧值（也就是工作内存中缓存的变量值）不同，那么工作内存中的缓存的变量值（也就是旧值）就为主内存中的值。如果相同。那么主内存中的值就为最新的值。</p>
<h3 id="CAS会出现的三大问题"><a href="#CAS会出现的三大问题" class="headerlink" title="CAS会出现的三大问题"></a>CAS会出现的三大问题</h3><p>虽然通过CAS操作可以很好的提高我们在处理数据的时候的效率，但是任然会出现许多问题。但是Java的开发团队已经为我们提供了一些处理方案，现在我们就来看看CAS有哪三大问题。</p>
<h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。关于AtomicStampedReference的使用，有兴趣的小伙伴可以自行查看相关源码实现。</p>
<h4 id="循环时间开销太大"><a href="#循环时间开销太大" class="headerlink" title="循环时间开销太大"></a>循环时间开销太大</h4><p>在后期的文章我们会讲述自旋CAS，关于自旋CAS,因为后期关于锁的文章会具体描述，这里我就简单描述一下，在Java中有很多的并发框架都使用了自旋CAS来获取相应的锁，会一直循环直到获取到相应的锁后，然后执行相应的操作。那么当其自旋时CAS，会一直占用CPU的资源。如果自旋CAS长时间不成功，会给CPU带来非常大的执行开销。</p>
<h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，自旋CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。关于AtomicReference的使用，有兴趣的小伙伴可以自行查看相关源码实现。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>对于物理计算机中的缓存锁，在Java中是使用CAS操作来实现的。</li>
<li>CAS操作中会出现三个问题，ABA问题。循环时间开销太大，只能保证一个共享变量的原子操作。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之Java-CAS操作/" data-id="cjsheb865000cdsr76nfjxqzi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程之Volatile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之Volatile/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-358b7664b318447b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="认真.png"></p>
<blockquote>
<p>该文章属于《Java并发编程》系列文章，如果想了解更多，请点击《Java并发编程之总目录》</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前面的文章中,我们已经了解了Java的内存模型，了解了其可见性问题及指令重排序及Happen-Before原则，现在我们来了解一下关键字<strong>volatile</strong>。在Java中volatile可以算是Java提供的轻量级同步实现机制，但是在平时开发中，我们更多的是使用synchronized来进行同步。对于volatile，大家总是不能正确的且完整的理解。所以下面，我就和大家一起来了解一下volatile。</p>
<h3 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h3><h4 id="线程的可见性"><a href="#线程的可见性" class="headerlink" title="线程的可见性"></a>线程的可见性</h4><p>当一个变量定义为volatile后，那么该变量对所有线程都是“可见的”，其中“可见的”是指当一条线程修改了这个变量的值，那么新值对于其他线程来说是可以立即知道的。可能大家还是不好的理解。如果你阅读过上篇文章<a href="https://www.jianshu.com/p/355b91f7baa8" target="_blank" rel="noopener">Java并发编程之Java内存模型</a>，你应该很快的理解。不过没有大碍，通过下列图片大家应该很快的了解。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-1f1b6e527993d110.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile可见性.png"></p>
<p>我们已经知道在Java内存模型中，内存分为了线程的工作内存及主内存。在上图中，线程A与线程B分别从主内存中获取变量a(<strong>用volatile修饰</strong>)到自己的工作内存中，也就是现在线程A与线程B中工作内存中的a现在的变量为12，当线程A修改a的值为8时，会将修改后的值（a=8)同步到主内存中，同时那么会导致线程B中的<strong>缓存a变量的值（a=12)无效</strong>，会让线程B重新重主内存中<strong>获取新的值(a=8)</strong>。</p>
<h4 id="volatile可见性的原理"><a href="#volatile可见性的原理" class="headerlink" title="volatile可见性的原理"></a>volatile可见性的原理</h4><p>在上篇文章<a href="https://www.jianshu.com/p/355b91f7baa8" target="_blank" rel="noopener">Java并发编程之Java内存模型</a>中我们曾经讲过，物理计算机为了处理缓存不一致的问题。提出了缓存一致性的协议，其中缓存一致性的核心思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<p>既然volatile修饰的变量能具有“可见性”，那么volatile内部肯定是走的底层，同时也肯定满足缓存一致性原则。因为涉及到底层汇编，这里我们不要去了解汇编语言，我们只要知道当用volatile修饰变量时，生成的汇编指令会比普通的变量声明会多一个<strong>Lock</strong>指令。那么<strong>Lock</strong>指令会在多核处理器下会做两件事情。</p>
<ul>
<li>将当前处理器缓存行的数据直接写会到系统内存中（从Java内存模型来理解，就是将线程中的工作内存的数据直接写入到主内存中）</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效（从Java内存模型理解，当线程A将工作内存的数据修改后（新值），同步到主内存中，那么线程B从主内存中初始的值（旧值）就无效了）</li>
</ul>
<h4 id="防止重排序"><a href="#防止重排序" class="headerlink" title="防止重排序"></a>防止重排序</h4><p>同样的在上篇文章《Java并发编程之内存模型》中，我们提到了为了提高CPU(处理器)的处理数据的速度，CPU(处理器)会对没有数据依赖性的指令进行重排序，但是CPU(处理器)的重排序会对多线程带来问题。具体问题我们用下列伪代码来阐述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    private int a = 0;</span><br><span class="line">    private boolean isInit = false;</span><br><span class="line">    private Config config;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        config = readConfig();//1</span><br><span class="line">        isInit = true;//2</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        if (isInit) &#123;//3</span><br><span class="line">            doSomethingWithconfig();//4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>isInit用来标志是否已经初始化配置。其中1，2操作是没有数据依赖性，同理3、4操作也是没有数据依赖性的。那么CPU(处理器)可能对1、2操作进行重排序。对3、4操作进行重排序。现在我们加入线程A操作Init()方法，线程B操作doSomething()方法，那么我们看看重排序对多线程情况下的影响。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-a8134e7dee718eea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="程序执行顺序.png"></p>
<p>上图中2操作排在了1操作前面。当CPU时间片转到线程B。线程B判断 if (isInit)为true,接下来接着执行 doSomethingWithconfig(),但是我们Config还没有初始化。所以在多线程的情况下。重排序会影响程序的执行结果。所以为了防止重排序带来的问题。Java内存模型规定了使用volatile来修饰相应变量时，可以防止CPU(处理器)在处理指令的时候禁止重排序。具体如下图所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    private int a = 0;</span><br><span class="line">    private volatile boolean isInit = false;</span><br><span class="line">    private Config config;</span><br><span class="line">	 public void init() &#123;</span><br><span class="line">        config = readConfig();//1</span><br><span class="line">        isInit = true;//2</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        if (isInit) &#123;//3</span><br><span class="line">            doSomethingWithconfig();//4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="volatile防止重排序规则"><a href="#volatile防止重排序规则" class="headerlink" title="volatile防止重排序规则"></a>volatile防止重排序规则</h4><p>那么为了处理CPU重排序的问题。Java定义了以下规则防止CPU的重排序。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-1c644c59dafc8ac9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile重排序规则.png"></p>
<p>从上表我们可以看出</p>
<ul>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序，这个规则确保voatile写之前的操作不会被编译器排序到volatile之后。</li>
<li>当第二个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当第一个操作是volatile写，第二个操作如果是volatile读时，不能进行重排序。</li>
</ul>
<h4 id="volatile防止重排序原理"><a href="#volatile防止重排序原理" class="headerlink" title="volatile防止重排序原理"></a>volatile防止重排序原理</h4><p>为了具体实现上诉我们提到的重排序规则，在Java中对于volatile修饰的变量，编译器在生成字节码时，会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序问题。在了解<strong>内存屏障</strong>之前，我们先复习之前的主内存与工作内存交互的8种原子操作，因为内存屏障主要是对Java内存模型的几种原子操作进行限制的。具体内存8种原子操作，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-c71aa78c0a3ca6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8种操作.png"><br>上述8中原子操作中，我们所涉及的是store与load操作，如果需要了解剩余6种操作，请参看上篇文章<a href="https://www.jianshu.com/p/355b91f7baa8" target="_blank" rel="noopener">Java并发编程之Java内存模型</a>。</p>
<p>这里对内存屏障所涉及到的两种操作进行解释：</p>
<ul>
<li>load：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存变量副本中。</li>
<li>store：作用于工作内存的变量，它把工作内存中一个变量值传送到主内存中。以便随后的write操作。</li>
</ul>
<h5 id="内存屏障插入策略"><a href="#内存屏障插入策略" class="headerlink" title="内存屏障插入策略"></a>内存屏障插入策略</h5><p>下面是基于volatile修饰的变量，编译器在指令序列插入的内存屏障<strong>保守插入策略</strong>如下：</p>
<ul>
<li>在每个volatile写操作的前面插入一个storestore屏障。</li>
<li>在每个volatile写操作的后面插入一个storeload屏障。</li>
<li>在每个volatile读操作的后面插入一个loadload屏障。</li>
<li>在每个volatile读操作的后面插入一个loadstore屏障。</li>
</ul>
<h4 id="volatile写内存屏障"><a href="#volatile写内存屏障" class="headerlink" title="volatile写内存屏障"></a>volatile写内存屏障</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-e82e7109769d664a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile写屏障.png"></p>
<ul>
<li>storestore屏障：对于这样的语句store1; storestore; store2，在store2及后续写入操作执行前，保证store1的写入操作对其它处理器可见。(也就是说如果出现storestore屏障，那么store1指令一定会在store2之前执行，CPU不会store1与store2进行重排序)</li>
<li>storeload屏障：对于这样的语句store1; storeload; load2，在load2及后续所有读取操作执行前，保证store1的写入对所有处理器可见。(也就是说如果出现storeload屏障，那么store1指令一定会在load2之前执行,CPU不会对store1与load2进行重排序)</li>
</ul>
<h4 id="volatile读内存屏障"><a href="#volatile读内存屏障" class="headerlink" title="volatile读内存屏障"></a>volatile读内存屏障</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-09aecb1676378953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile读屏障.png"></p>
<ul>
<li>loadload屏障：对于这样的语句load1; loadload; load2，在load2及后续读取操作要读取的数据被访问前，保证load1要读取的数据被读取完毕。（也就是说，如果出现loadload屏障，那么load1指令一定会在load2之前执行，CPU不会对load1与load2进行重排序）</li>
<li>loadstore屏障：对于这样的语句load1; loadstore; store2，在store2及后续写入操作被刷出前，保证load1要读取的数据被读取完毕。（也就是说，如果出现loadstore屏障，那么load1指令一定会在store2之前执行，CPU不会对load1与store2进行重排序）</li>
</ul>
<h4 id="编译器内存屏障的优化"><a href="#编译器内存屏障的优化" class="headerlink" title="编译器内存屏障的优化"></a>编译器内存屏障的优化</h4><p>上面我们讲到了在插入内存屏障时，编译器如果<strong>采用保守策略的情况下</strong>，分别会在volatile写与volatile读插入不同的内存屏障，那现在我们来看一下，在实际开发中，编译器在使用内存屏障时的优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileBarrierDemo &#123;</span><br><span class="line">    int a;</span><br><span class="line">    volatile int v1 = 1;</span><br><span class="line">    volatile int v2 = 2;</span><br><span class="line"></span><br><span class="line">    public void readAndWrite() &#123;</span><br><span class="line">        int i = v1;//第一个volatile读</span><br><span class="line">        int j = v2;//第二个volatile读</span><br><span class="line">        a = i + j;//普通写</span><br><span class="line">        v1 = i + 1;//第一个volatile写</span><br><span class="line">        v2 = j * 2;//第二个volatile写</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么针对上述代码，我们生成相应的屏障（图片在手机端观看可能会不太清除，建议在pc端上观看）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-1c33efb57c437b3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏障优化图.png"></p>
<p>观察上图，我们发现，在编译器生成屏障时，省略了第一个volatile读下的loadstore屏障，省略了第二个volatile读下的loadload屏障，省略了第一个volatile写下的storeload屏障。结合上诉我们所讲的loadstore屏障、loadload屏障、storeload屏障下的语义，我们能得到省略以下屏障的原因。</p>
<ul>
<li>省略第一个volatile读下的loadstore屏障：因为第一个volatile读下的下一个操作是第二个volatile的读，并不涉及到写的操作（也就是store)。所以可以省略。</li>
<li>省略第二个volatile读下的loadload屏障：因为第二个volatile读的下一个操作是普通写，并不涉及到读的操作（也就是load)。所以可以省略</li>
<li>省略第一个volatile写下的storeload屏障：因为第一个volatile写的下一个操作是第二个volatile的写，并不涉及到读的操作（也就是load)。所以可以省略。</li>
</ul>
<p><strong>其中大家要注意的是，优化结束后的storeload屏障时不能省略的，因为在第二个volatile写之后，方法理解return,此时编译器可能无法确定后面是否会有读写操作，为了安全起见，编译器通常会在这里加入一个storeload屏障。</strong></p>
<h4 id="处理器内存屏障的优化"><a href="#处理器内存屏障的优化" class="headerlink" title="处理器内存屏障的优化"></a>处理器内存屏障的优化</h4><p>上面我们讲了编译器在生成屏障的时候，会根据程序的逻辑操作省略不必要的内存屏障。但是由于不同的处理器有不同的“松耦度”的内存模型，内存屏障的优化根据不同的处理器有着不同的优化方式。以x86处理器为例。针对我们上面所描述的编译器内存屏障优化图。在x86处理器中，除最后的storeload屏障外，其他的屏障都会省略。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-e20b80eb434f66ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="x86处理器优化后.png"></p>
<p>x86处理器与其他处理器的内存屏障的优化，这里不过的描述，有兴趣的小伙伴可以查阅相关资料继续研究。</p>
<h3 id="volatile的使用注意事项"><a href="#volatile的使用注意事项" class="headerlink" title="volatile的使用注意事项"></a>volatile的使用注意事项</h3><p> <strong>在volatile使用的时候，需要注意volatile只保证可见性，并不能保证原子性</strong>，这里所提到的<strong>原子性</strong>需要给大家补充一个知识点。</p>
<h4 id="原子性定义"><a href="#原子性定义" class="headerlink" title="原子性定义"></a>原子性定义</h4><blockquote>
<p>在Java中，对基本的数据类型的变量的<strong>访问和读写</strong>操作都是原子性操作，且这些操作在CPU中不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p>
</blockquote>
<p>直接通过定义来理解确实比较困难，通过下面这个例子，让我们一起来了解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 10;         //语句1</span><br><span class="line">x++;           //语句2</span><br><span class="line">x = x + 1;     //语句3</span><br></pre></td></tr></table></figure></p>
<p>大家可以来猜一猜，以上3个语句有哪些是具有原子性呢。好了。我告诉答案吧，<strong>只有语句1具有原子性。</strong>大家对此会感到很疑惑。</p>
<p>对于语句1：是直接将数值10赋给x,也就是直接将数值10赋值到工作内存中。<br>对于语句2：先去读取x的值，然后计算x加上1后的值，最后将计算后的值赋值给x，<br>对于语句3：同语句3。</p>
<p>对于语句2，3因为涉及到多个操作，且在多线程的情况下，CPU可以进行时间片的切换操作（也就是可以暂停在某个操作后）。那么就可能出现线程安全的问题。</p>
<h4 id="volatile为什么不具备原子性"><a href="#volatile为什么不具备原子性" class="headerlink" title="volatile为什么不具备原子性"></a>volatile为什么不具备原子性</h4><p>描述了原子性后，相信大家都会有个疑问“volatile不具备原子性有什么关系呢？其实原因很简单，虽然volatile是具备可见性的（也就是指当一条线程修改了这个变量的值，那么新值对于其他线程来说是可以立即知道的），<strong>但是对于该变量有可能有多个操作例如上文提到的x++。那么在有多个操作的情况下，CPU任然可以先暂停然后在调度的。既然能被暂停后继续在调度，那么volatile肯定是不具备原子性的了。</strong></p>
<h4 id="volatile的使用场景"><a href="#volatile的使用场景" class="headerlink" title="volatile的使用场景"></a>volatile的使用场景</h4><p>现在我们已经了解了volatile的相关特性，那么就来说说，volatile的具体使用场景，因为volatie变量只能保证可见性，并不能保证原子性，所以在轻量级线程同步中我们可以使用volatile关键字。但是有两个前提条件：</p>
<ul>
<li>第一个条件：运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>第二个条件：变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<p>直接理解上述两个条件，可能会有点困难，下面分别对着两个前提条件进行解释：</p>
<h4 id="针对第一个条件"><a href="#针对第一个条件" class="headerlink" title="针对第一个条件"></a>针对第一个条件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> volatile int a  = 0;</span><br><span class="line">//在多线程情况下错误，在单线程情况下正确的方式</span><br><span class="line">   public void doSomeThingA() &#123;</span><br><span class="line">   //在单线程情况下，不会出现线程安全的问题，正确</span><br><span class="line">//在多线程情况下，a最终的值依赖于当前a的值，错误</span><br><span class="line">        a++;     </span><br><span class="line">   &#125;</span><br><span class="line">   //正确的使用方式</span><br><span class="line">   public void doSomeThingB() &#123;</span><br><span class="line">    //不管是在单线程还是多线程的情况下，都不会出现线程安全的问题</span><br><span class="line">	if(a==0)&#123;</span><br><span class="line">	 a = 1;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在上述伪代码中，我们能明确的看出，只要volatile修饰的变量不涉及与运算结果的依赖，那么不管是在多线程，还是单线程的情况下，都是正确的。当然我这里只是将a变量定义成成int，对于其他剩下的基础类型数据也是适用的。</p>
<h4 id="针对第二个条件"><a href="#针对第二个条件" class="headerlink" title="针对第二个条件"></a>针对第二个条件</h4><p>其实理解第二个条件，大家可以反过来理解，即使用volatile的变量不能包含在其他变量的不变式中，下面伪代码将会通过反例说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	private volatile int lower;</span><br><span class="line">    private volatile int upper;  </span><br><span class="line">  </span><br><span class="line">    public void setLower(int value) &#123;   </span><br><span class="line">        if (value &gt; upper)   </span><br><span class="line">            throw new IllegalArgumentException(...);  </span><br><span class="line">        lower = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void setUpper(int value) &#123;   </span><br><span class="line">        if (value &lt; lower)   </span><br><span class="line">            throw new IllegalArgumentException(...);  </span><br><span class="line">        upper = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，我们明显发现其中包含了一个不变式 —— 下界总是小于或等于上界（也就是lower&lt;=upper)。那么在多线程的情况下，两个线程在同一时间使用不一致的值执行 setLower 和 setUpper 的话，则会使范围处于不一致的状态。例如，如果初始状态是(0, 5)，同一时间内，线程 A 调用setLower(4) 并且线程 B 调用setUpper(3)，显然这两个操作交叉存入的值是不符合条件的，那么两个线程都会通过用于保护不变式的检查，使得最后的范围值是(4, 3)。很显然这个结果是错误的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>volatile具有可见性不具有原子性，同时能防止指令重排序。</li>
<li>volatile之所以具有可见性，是因为底层中的Lock指令，该指令会将当前处理器缓存行的数据直接写会到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。</li>
<li>volatile之所以能防止指令重排序，是因为Java编译器对于volatile修饰的变量，会插入内存屏障。内存屏障会防止CPU处理指令的时候重排序的问题</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之Volatile/" data-id="cjsheb86t000mdsr7f8a4drqh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程之原子类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之原子类/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-040b2bf4b2848263.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="天天.jpeg"></p>
<blockquote>
<p>该文章属于《Java并发编程》系列文章，如果想了解更多，请点击《Java并发编程之总目录》</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上篇文章<a href="https://www.jianshu.com/p/712e27f8c977" target="_blank" rel="noopener">Java并发编程之synchronized</a>中，曾描述Java提供了两种方式来处理线程安全的问题。第一种是互斥同步（悲观锁），第二种是采用非阻塞式同步（乐观锁）。虽然以上两种方案都能解决线程安全的问题。但是在JDK1.5开始，就提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了更为简单高效、线程安全的方式来更新一个变量的值。例如AtomicBoolean、AtomicLong、AtomicInteger等。（这里提到的Atomic系列类原理都是CAS操作，如果你对CAS操作并不是是很熟悉，建议先阅读<a href="https://www.jianshu.com/p/0a82c764e694" target="_blank" rel="noopener">Java并发编程之Java CAS操作</a></p>
<h4 id="原子类的使用方式"><a href="#原子类的使用方式" class="headerlink" title="原子类的使用方式"></a>原子类的使用方式</h4><p>既然我们提到Atomic系列类是简单高效且线程安全的。光说没用，我们直接来实际例子，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class AtomicDemo &#123;</span><br><span class="line">    private AtomicInteger mAtomicInteger = new AtomicInteger();//如果没有指定值，默认是1</span><br><span class="line">    </span><br><span class="line">    private void doAdd() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            int value = mAtomicInteger.addAndGet(1);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicDemo demo = new AtomicDemo();</span><br><span class="line">        new Thread(demo::doAdd, &quot;线程1&quot;).start();</span><br><span class="line">        new Thread(demo::doAdd, &quot;线程2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出结果</span><br><span class="line">线程1---&gt;1</span><br><span class="line">线程1---&gt;2</span><br><span class="line">线程1---&gt;3</span><br><span class="line">线程2---&gt;4</span><br><span class="line">线程1---&gt;5</span><br><span class="line">线程2---&gt;6</span><br><span class="line">线程1---&gt;7</span><br><span class="line">线程2---&gt;8</span><br><span class="line">线程2---&gt;9</span><br><span class="line">线程2---&gt;10</span><br></pre></td></tr></table></figure></p>
<p>在上述代码逻辑非常简单，主要是想通过通过2个线程将mAtomicInteger 的值分别加1,每个线程执行加1并操作5次。</p>
<blockquote>
<p>这里简单对AtomicInteger 中的addAndGet（int delta）方法进行介绍，该方法是以原子的方式将输入的值与ActomicInteger中的值进行相加，返回相加后ActomicInteger中的值。</p>
</blockquote>
<p>通过执行代码我们发现，结果最后打印的结果是我们预期的10。但是如果我们将ActomicInteger修改为普通的int类型，我们会发现结果是千奇百怪（这里我就不贴代码了）有兴趣的小伙伴可以自己去试一试。</p>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>在Java中的并发包中了提供了以下几种类型的原子类来来解决线程安全的问题。分为基本数据类型原子类、数组类型原子类、引用类型原子类、字段类型原子类。因为其内部原理都差不多一致。这里会对每种类型的原子类抽一个来介绍。</p>
<h4 id="基本数据类型原子类"><a href="#基本数据类型原子类" class="headerlink" title="基本数据类型原子类"></a>基本数据类型原子类</h4><p>基本数据类型原子类主要为以下几种：</p>
<ul>
<li>AtomicBoolen: boolean类型原子类</li>
<li>AtomicInteger: int类型原子类</li>
<li>AtomicLong:  long类型原子类</li>
</ul>
<p>这里我们以AtomicInteger来进行讲解，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">  </span><br><span class="line">    private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">    private static final long VALUE;</span><br><span class="line"></span><br><span class="line">    private volatile int value;//注意该值用volatile修饰</span><br><span class="line"></span><br><span class="line">    public AtomicInteger(int initialValue) &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    //以原子的方式将输入的值与ActomicInteger中的值进行相加，</span><br><span class="line">    //注意：返回相加前ActomicInteger中的值</span><br><span class="line">    public final int getAndAdd(int delta) &#123;</span><br><span class="line">        return U.getAndAddInt(this, VALUE, delta);</span><br><span class="line">    &#125;</span><br><span class="line">    //以原子的方式将输入的值与ActomicInteger中的值进行相加，</span><br><span class="line">    //注意：返回相加后的结果</span><br><span class="line">    public final int addAndGet(int delta) &#123;</span><br><span class="line">        return U.getAndAddInt(this, VALUE, delta) + delta;</span><br><span class="line">    &#125;</span><br><span class="line">    //以原子方式将当前ActomicInteger中的值加1,</span><br><span class="line">    //注意：返回相加前ActomicInteger中的值</span><br><span class="line">    public final int getAndIncrement() &#123;</span><br><span class="line">        return U.getAndAddInt(this, VALUE, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    //以原子方式将当前ActomicInteger中的值加1,</span><br><span class="line">    //注意：返回相加后的结果</span><br><span class="line">    public final int incrementAndGet() &#123;</span><br><span class="line">        return U.getAndAddInt(this, VALUE, 1) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //省略部分代码...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我只留了AtomicInteger 类一部分常用的方法。大家在使用其内部方法时一定要注意其返回的结果。例如<strong>getAndAdd（）与addAndGet（）方法之间的返回值的区别</strong>。既然我们已经说过了使用Actomic系列原子类是线程安全的。那么现在我们就来看看其具体原理。这里我们以getAndAdd（）方法为例进行讲解。</p>
<p>AtomicInteger内部会调用其中sun.misc.Unsafe方法中getAndAddInt的方法。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndAdd(int delta) &#123;</span><br><span class="line">       return U.getAndAddInt(this, VALUE, delta);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>而sun.misc.Unsafe方法中getAndAddInt方法又会调用jdk.internal.misc.Unsafe的getAndAddInt，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">       return theInternalUnsafe.getAndAddInt(o, offset, delta);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>jdk.internal.misc.Unsafe的getAndAddInt（）方法的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">        int v;</span><br><span class="line">        do &#123;</span><br><span class="line">            v = getIntVolatile(o, offset);//先获取内存中存储的值</span><br><span class="line">        &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta));//如果不是期望的结果值，就一直循环</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//该函数返回值代表CAS操作是否成功    </span><br><span class="line">public final boolean weakCompareAndSetInt(Object o, long offset,</span><br><span class="line">                                          int expected,</span><br><span class="line">                                          int x) &#123;</span><br><span class="line">     return compareAndSetInt(o, offset, expected, x);//执行CAS操作</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述代码中我们可以得出，会先获取内存中存储的值，最终会调用compareAndSetInt（）方法来完成最终的原子操作。其中compareAndSetInt（）方法的返回值代表着该次CAS操作是否成功。如果不成功。那么会一直循环。直到成功为止（也就是循环CAS操作）。</p>
<p>这里简要的对CAS操作进行描述：CAS操作内部实现原理是缓存锁，在其操作期间，会修改对应操作对象的内存地址。同时其会保证各个处理器的缓存是一致的，如果处理器发现自己的数据对应的内存地址被修改，就会将当前缓存的数据处理为无效，同时该处理器会重新从系统内存中把数据处理到缓存中。如果你对CAS操作还是不熟悉，建议先阅读<a href="https://www.jianshu.com/p/0a82c764e694" target="_blank" rel="noopener">Java并发编程之Java CAS操作</a>，在回过头来看这篇文章。</p>
<blockquote>
<p>这里有一个小的问题，大家可以思考一下。我们都知道对于long与double数据类型，在java内存模型中long与double具有非原子协定。但是现在商用的虚拟机都把关于long和double变量的读写操作视为具有原子性的操作。那这里为什么会出现一个AtomicLong？或者出现了AtomicLong为什么没有出现ActomicDouble这个类呢？</p>
</blockquote>
<h4 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h4><p>对于数组类型的原子类，在Java中，主要通过原子的方式更新数组里面的某个元素，数组类型原子类主要有以下几种：</p>
<ul>
<li>AtomicIntegerArray：Int数组类型原子类</li>
<li>AtomicLongArray：long数组类型原子类</li>
<li>AtomicReferenceArray：引用类型原子类（关于AtomicReferenceArray即引用类型原子类会在下文介绍）</li>
</ul>
<p>这里我们还是以AtomicIntegerArray为例，因为其内部原理都是循环CAS操作，所以我们这里就描述其使用方式，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class AtomicDemo &#123;</span><br><span class="line"></span><br><span class="line">    private int[] value = new int[]&#123;0, 1, 2&#125;;</span><br><span class="line">    private AtomicIntegerArray mAtomicIntegerArray = new AtomicIntegerArray(value);</span><br><span class="line"></span><br><span class="line">    private void doAdd() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            int value = mAtomicIntegerArray.addAndGet(0, 1);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicDemo demo = new AtomicDemo();</span><br><span class="line">        new Thread(demo::doAdd, &quot;线程1&quot;).start();</span><br><span class="line">        new Thread(demo::doAdd, &quot;线程2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">  //程序输出结果如下：</span><br><span class="line">线程1---&gt;1</span><br><span class="line">线程1---&gt;2</span><br><span class="line">线程1---&gt;4</span><br><span class="line">线程2---&gt;3</span><br><span class="line">线程1---&gt;5</span><br><span class="line">线程2---&gt;6</span><br><span class="line">线程1---&gt;7</span><br><span class="line">线程2---&gt;8</span><br><span class="line">线程2---&gt;9</span><br><span class="line">线程2---&gt;10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h4><p>在<a href="https://www.jianshu.com/p/0a82c764e694" target="_blank" rel="noopener">Java并发编程之Java CAS操作</a>文章中我们曾经提到过两个问题，<strong>第一个问题</strong>：虽然我们能通过循环CAS操作来完成对一个变量的原子操作，但是对于多个变量进行操作时，自旋CAS操作就不能保证其原子性。<strong>第二个问题</strong>：ABA问题，因为CAS在操作值的时候，需要检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现她的值并没有发生变化。那么会导致程序出问题。</p>
<p>为了解决上述提到的两个问题，Java为我们提供了AtomicReference等系列引用类型原子类，来保证引用对象之间的原子性，即可以把多个变量放在一个对象里来进行CAS操作与ABA问题。主要类型原子类如下：</p>
<ul>
<li>AtomicReference：</li>
<li>AtomicReferenceFieldUpdater：</li>
<li>AtomicMarkableReference：</li>
<li>AtomicStampedReference：</li>
</ul>
<h5 id="多个变量的CAS操作"><a href="#多个变量的CAS操作" class="headerlink" title="多个变量的CAS操作"></a>多个变量的CAS操作</h5><p>这里我们先解决第一个问题，关系多个变量的CAS操作，我们先以AtomicReference来进行讲解，具体代码如下所示：<br>（这里提一嘴，关于引用类型的原子类，内部都调用的是<strong>compareAndSwapObject</strong>（）方法来实现CAS操作的。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class AtomicDemo &#123;</span><br><span class="line"></span><br><span class="line">    Person mPerson = new Person(&quot;红红&quot;, 1);</span><br><span class="line">    private AtomicReference&lt;Person&gt; mAtomicReference = new AtomicReference&lt;&gt;(mPerson);</span><br><span class="line"></span><br><span class="line">    private class Person &#123;</span><br><span class="line">        String name;</span><br><span class="line">        int age;</span><br><span class="line"></span><br><span class="line">        Person(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void updatePersonInfo(String name, int age) throws Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;更新前---&gt;&quot; + mAtomicReference.get().name + &quot;----&gt;&quot; + mAtomicReference.get().age);</span><br><span class="line">        mAtomicReference.getAndUpdate(person -&gt; new Person(name, age));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicDemo demo = new AtomicDemo();</span><br><span class="line">        new Thread(() -&gt; demo.updatePersonInfo(&quot;蓝蓝&quot;, 2), &quot;线程1&quot;).start();</span><br><span class="line">   </span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;暂停一秒---&gt;&quot; + demo.mAtomicReference.get().name + &quot;----&gt;&quot; + demo.mAtomicReference.get().age);</span><br><span class="line">     </span><br><span class="line">        System.out.println(&quot;更新后----&gt;&quot; + demo.mAtomicReference.get().name + &quot;----&gt;&quot; + demo.mAtomicReference.get().age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//输出结果</span><br><span class="line">线程1更新前---&gt;红红----&gt;1</span><br><span class="line">暂停一秒---&gt;蓝蓝----&gt;2</span><br><span class="line">更新后----&gt;蓝蓝----&gt;2</span><br></pre></td></tr></table></figure></p>
<p>上述代码中创建了Person 类，且当前AtomicReference传入的是当前 mPerson =new Person(“红红”, 1)，在Main方法中创建线程1使其调用mAtomicReference.getAndUpdate(new Person(“蓝蓝”，2))来更新Person信息。更新完成后休眠一秒后，获取更新结果并打印。从结果上来看，的确是对多个变量进行了更新的操作。</p>
<h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>关于ABA问题，大家已经知道其出现的原因，现在我们就用具体例子让大家来了解一下。ABA会引发的问题。<br>这里我们以具体的例子来进行讲解。具体例子如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-2ec245c061aea68e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aba.png"></p>
<p>观察上图，我们初始化了一个单向的链表结构，其中Header指向链表头节点，其中A节点的下一节点为B节点。<br>这个时候我们希望通过线程1，通过CAS操作将链表中的B节点放入头节点中,且B的next节点为A节点。具体为代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(header.compareAndSet(A,B))&#123;</span><br><span class="line">	B.next = A;</span><br><span class="line">	A.next = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当线程1已经拿到header.compareAndSet(A,B)的结果正准备执行下一行代码时，突然线程2介入，将A、B两个节点移除，同时重新将A、C、D三个节点依次加入链表中。当线程2操作完毕的时候，这个时候线程1接着执行。线程1在执行的时候，会检查当前链表中A是否为头节点，当前情况A是头节点（通过线程2添加的）。那么就会执行剩余代码也就是（B.next =A, A.next = null)。那么通过线程1操作完成后，就出现上图中当前链表中C、D两个节点丢失的情况。所以为了解决ABA问题，Java中提供了<strong>AtomicStampedReference</strong>来解决。</p>
<p>为了方便大家理解对AtomicStampedReference类的使用，提供了以下例子：具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class AtomicDemo &#123;</span><br><span class="line"></span><br><span class="line">    Person mPerson = new Person(&quot;红红&quot;, 1);</span><br><span class="line">    private AtomicStampedReference&lt;Person&gt; mAtomicReference = new AtomicStampedReference&lt;&gt;(mPerson, 1);</span><br><span class="line"></span><br><span class="line">    private class Person &#123;</span><br><span class="line">        String name;</span><br><span class="line">        int age;</span><br><span class="line"></span><br><span class="line">        Person(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 更新信息</span><br><span class="line">     *</span><br><span class="line">     * @param name     名称</span><br><span class="line">     * @param age      年龄</span><br><span class="line">     * @param oldStamp CAS操作比较的旧的版本</span><br><span class="line">     * @param newStamp 希望更新后的版本</span><br><span class="line">     */</span><br><span class="line">    private void updatePersonInfo(String name, int age, int oldStamp, int newStamp) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;更新前---&gt;&quot; + mAtomicReference.getReference().name + &quot;----&gt;&quot; + mAtomicReference.getReference().age);</span><br><span class="line">        mAtomicReference.compareAndSet(mPerson, new Person(name, age), oldStamp, newStamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        AtomicDemo demo = new AtomicDemo();</span><br><span class="line">        new Thread(() -&gt; demo.updatePersonInfo(&quot;蓝蓝&quot;, 2, 1, 2), &quot;线程1&quot;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;暂停一秒---&gt;&quot; + demo.mAtomicReference.getReference().name + &quot;----&gt;&quot; + demo.mAtomicReference.getReference().age);</span><br><span class="line">        new Thread(() -&gt; demo.updatePersonInfo(&quot;花花&quot;, 3, 1, 3), &quot;线程2&quot;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;更新后----&gt;&quot; + demo.mAtomicReference.getReference().name + &quot;----&gt;&quot; + demo.mAtomicReference.getReference().age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//输出结果</span><br><span class="line">线程1更新前---&gt;红红----&gt;1</span><br><span class="line">暂停一秒---&gt;蓝蓝----&gt;2</span><br><span class="line">线程2更新前---&gt;蓝蓝----&gt;2</span><br><span class="line">更新后----&gt;蓝蓝----&gt;2</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，我们使用AtomicStampedReference类，其中在使用该类的时候，需要传入一个类似于版本（你也可以叫做邮戳，时间戳等，随你喜欢）的int类型的属性。在Main方法中我们分别创建了2个线程来进行CAS操作，其中线程1想做的操作是将版本为1的mPerson(“红红”，1)修改为版本为2的Person(“蓝蓝，2”)。当线程1执行完毕后，紧接着线程2开始执行，线程2想做的操作是将版本为1的mPerson(“红红”，1)修改为版本3的Person(“花花”，3)。从程序输出结果可以看出，线程2的操作是没有执行的。也就验证了AtomicStampedReference确实解决了ABA的问题。</p>
<h4 id="字段类型原子类"><a href="#字段类型原子类" class="headerlink" title="字段类型原子类"></a>字段类型原子类</h4><p>如果需要更新某个类中的某个字段，在Actomic系列中，Java提供了以下几个类来实现：</p>
<ul>
<li>AtomicIntegerFieldUpdater：int类型字段原子类</li>
<li>AtomicLongFieldUpdater：long类型字段原子类</li>
<li>AtomicReferenceFieldUpdater：引用型字段原子类</li>
</ul>
<p>上面所说的三个类原理都差不多，这里我们以AtomicIntegerFieldUpdate类来讲解，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class AtomicDemo &#123;</span><br><span class="line"></span><br><span class="line">    Person mPerson = new Person(&quot;红红&quot;, 1);</span><br><span class="line">    private AtomicIntegerFieldUpdater&lt;Person&gt; mFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Person.class, &quot;age&quot;);</span><br><span class="line"></span><br><span class="line">    private class Person &#123;</span><br><span class="line">        String name;</span><br><span class="line">        volatile int age;//使用volatile修饰</span><br><span class="line"></span><br><span class="line">        Person(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 更新信息</span><br><span class="line">     *</span><br><span class="line">     * @param age 年龄</span><br><span class="line">     */</span><br><span class="line">    private void updatePersonInfo(int age) &#123;</span><br><span class="line">        System.out.println(&quot;更新前---&gt;&quot; + mPerson.age);</span><br><span class="line">        mFieldUpdater.addAndGet(mPerson, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getUpdateInfo() &#123;</span><br><span class="line">        return mFieldUpdater.get(mPerson);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        AtomicDemo demo = new AtomicDemo();</span><br><span class="line">        new Thread(() -&gt; demo.updatePersonInfo(12), &quot;线程1&quot;).start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;更新后---&gt;&quot; + demo.getUpdateInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//输出结果</span><br><span class="line">更新前---&gt;1</span><br><span class="line">更新后---&gt;13</span><br></pre></td></tr></table></figure></p>
<p>这里对AtomicIntegerFieldUpdate不在进行过多的描述，大家需要主要的是在使用字段类型原子类的时候，<strong>需要进行更新的字段，需要通过volatile来修饰。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Atomic系列类为我们提供了简单高效、线程安全的方式来更新一个变量的值或一个引用的值。</li>
<li>Atomic为处理多个变量原子更新的问题，为我们提供了AtomicReference类，为了解决ABA问题提供了AtomicStampedReference。在实际使用中，根据代码情况来使用不同Atomic的系列类。</li>
<li>在使用字段类型原子类的时候，需要将需要更新的字段，通过volatile来修饰。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之原子类/" data-id="cjsheb86u000odsr7sj2sxgus" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程之锁机制之ReentrantReadWriteLock（读写锁）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之锁机制之ReentrantReadWriteLock（读写锁）/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-12d950ee54698c34.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="蓝天.jpg"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前面的文章中，我们讲到了ReentrantLock(重入锁)，接下来我们讲<code>ReentrantReadWriteLock（读写锁）</code>，该锁具备重入锁的<code>可重入性</code>、<code>可中断获取锁</code>等特征，但是与<code>ReentrantLock</code>不一样的是，在<code>ReentrantReadWriteLock</code>中，维护了一对锁，一个<code>读锁</code>一个<code>写锁</code>，而读写锁在同一时刻允许多个<code>读</code>线程访问。但是在写线程访问时，所有的读线程和其他的写线程均被阻塞。在阅读本片文章之前，希望你已阅读过以下几篇文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/6874d9b4f3d8" target="_blank" rel="noopener"> Java并发编程之锁机制之Lock接口</a></li>
<li><a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener"> Java并发编程之锁机制之AQS(AbstractQueuedSynchronizer)</a></li>
<li><a href="https://www.jianshu.com/p/d0e84096d108" target="_blank" rel="noopener">Java并发编程之锁机制之LockSupport工具</a></li>
<li><a href="https://www.jianshu.com/p/a22855b8820a" target="_blank" rel="noopener">Java并发编程之锁机制之Condition接口</a></li>
<li><a href="https://www.jianshu.com/p/1068960ecd64" target="_blank" rel="noopener">Java并发编程之锁机制之（ReentrantLock)重入锁</a></li>
</ul>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>在具体了解<code>ReentrantReadWriteLock</code>之前，我们先看一下其整体结构，具体结构如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-fbf5a4a890fd66f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ReentrantReadWriteLock.png"></p>
<p>从整体图上来看，<code>ReentrantReadWriteLock</code>实现了<code>ReadWriteLock</code>接口，其中在<code>ReentrantReadWriteLock</code>中分别声明了以下几个静态内部类：</p>
<ul>
<li><code>WriteLock</code>与<code>ReadLock</code>（维护的一对读写锁）：单从类名我们可以看出这两个类的作用，就是控制读写线程的锁</li>
<li><code>Sync</code>及其子类<code>NofairSync</code>与<code>FairSync</code>：如果你阅读过 <a href="https://www.jianshu.com/p/1068960ecd64" target="_blank" rel="noopener">Java并发编程之锁机制之（ReentrantLock)重入锁</a>中公平锁与非公平锁的介绍，那么我们也可以猜测出<code>ReentrantReadWriteLock（读写锁）</code>是支持公平锁与非公平锁的。</li>
<li><code>ThreadLoclHoldCounter</code>及<code>HoldCounter</code>：涉及到锁的重进入，在下文中我们会具体进行描述。</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>在使用某些种类的<code>Collection</code>时，可以使用<code>ReentrantReadWriteLock</code> 来提高并发性。通常，在预期<code>Collection</code> 很大，且<code>读取线程</code>访问它的次数<code>多于写入线程</code>的情况下，且所承担的操作开销高于同步开销时，这很值得一试。例如，以下是一个使用 TreeMap（我们假设预期它很大，并且能被同时访问） 的字典类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class RWDictionary &#123;</span><br><span class="line">    private final Map&lt;String, Data&gt; m = new TreeMap&lt;String, Data&gt;();</span><br><span class="line">    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">    private final Lock r = rwl.readLock();//获取读锁</span><br><span class="line">    private final Lock w = rwl.writeLock();//获取写锁</span><br><span class="line">    </span><br><span class="line">	//读取Map中的对应key的数据</span><br><span class="line">    public Data get(String key) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123; return m.get(key); &#125;</span><br><span class="line">        finally &#123; r.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //读取Map中所有的key</span><br><span class="line">    public String[] allKeys() &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123; return m.keySet().toArray(); &#125;</span><br><span class="line">        finally &#123; r.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //往Map中写数据</span><br><span class="line">    public Data put(String key, Data value) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123; return m.put(key, value); &#125;</span><br><span class="line">        finally &#123; w.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //清空数据</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123; m.clear(); &#125;</span><br><span class="line">        finally &#123; w.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述例子中，我们分别对TreeMap中的读取操作进行了加锁的操作。当我们调用<code>get(String key)</code>方法，去获取<code>TreeMap</code>中对应key值的数据时，需要先获取读锁。那么其他线程对于<code>写锁的获取将会被阻塞</code>，而对获取读锁的线程不会阻塞。同理，当我们调用<code>put(String key, Data value)</code>方法，去更新数据时，我们需要获取写锁。那么其他线程对于写锁与读锁的获取都将会被阻塞。只有当获取写锁的线程释放了锁之后。其他读写操作才能进行。</p>
<p>这里可能会有小伙伴会有疑问，<code>为什么当获取写锁成功后，会阻塞其他的读写操作？</code>，这里其实是为了保证数据可见性。如果不阻塞其他读写操作，假如读操作优先与写操作，那么在数据更新之前，读操作获取的数据与写操作更新后的数据就会产生不一致的情况。</p>
<blockquote>
<p>需要注意的是：<code>ReentrantReadWriteLock</code>最多支持 <code>65535</code> 个递归写入锁和<code>65535</code>个读取锁。试图超出这些限制将导致锁方法抛出 Error。具体原因会在下文进行描述。</p>
</blockquote>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>到现在为止，我们已经基本了解了<code>ReentrantReadWriteLock</code>的基本结构与基本使用。我相信大家肯定对其内部原理感到好奇，下面我会带着大家一起去了解其内部实现。这里我会对整体的一个原理进行分析，内部更深的细节会在下文进行描述。因为我觉得只有理解整体原理后，再去理解其中的细节。那么对整个<code>ReentrantReadWriteLock（读写锁）</code>的学习来说，要容易一点。</p>
<h4 id="整体原理"><a href="#整体原理" class="headerlink" title="整体原理"></a>整体原理</h4><p>在前文中，我们介绍了<code>ReentrantReadWriteLock</code>的基本使用，我们发现整个读写锁对线程的控制是交给了<code>WriteLock</code>与<code>ReadLock</code>。当我们调用读写锁的<code>lock()</code>方法去获取相应的锁时，我们会执行以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123; sync.acquireShared(1);&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是会调用<code>sync.acquireShared(1)</code>，而<code>sync</code>又是什么呢？从其构造函数中我们也可以看出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantReadWriteLock(boolean fair) &#123;</span><br><span class="line">       sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">       readerLock = new ReadLock(this);</span><br><span class="line">       writerLock = new WriteLock(this);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中关于<code>FairSync</code>与<code>NonfairSync</code>的声明如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//同步队列</span><br><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;省略部分代码...&#125;</span><br><span class="line">//非公平锁</span><br><span class="line">static final class NonfairSync extends Sync&#123;省略部分代码...&#125;</span><br><span class="line">//公平锁</span><br><span class="line">static final class FairSync extends Sync &#123;省略部分代码...&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们又看到了我们熟悉的<code>AQS</code>，也就是说<code>WriteLock</code>与<code>ReadLock</code>这两个锁，其实是通过AQS中的同步队列来对线程的进行控制的。那么结合我们之前的AQS的知识，我们可以得到下图：</p>
<blockquote>
<p>（如果你对AQS不熟，那么你可以阅读该篇文章—–&gt;<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener"> Java并发编程之锁机制之AQS(AbstractQueuedSynchronizer)</a>).</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-1a0de5f2e62b3ed7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="读写锁状态关系图.png"><br>这里我省略了<code>为什么维护的是同一个同步队列的原因</code>，这个问题留给大家。</p>
<h4 id="读写状态设计"><a href="#读写状态设计" class="headerlink" title="读写状态设计"></a>读写状态设计</h4><p>虽然现在我们已经知道了，<code>WriteLock</code>与<code>ReadLock</code>这两个锁维护了<code>同一个同步队列</code>，但是我相信大家都会有个疑问，同步队列中只有一个<code>int</code>类型的<code>state</code>变量来表示当前的同步状态。那么其内部是怎么将两个读写状态分开，并且达到控制线程的目的的呢？</p>
<p>在<code>ReentrantReadWriteLock</code>中的同步队列，其实是将同步状态分为了两个部分，其中<code>高16位</code>表示<code>读状态</code>，<code>低16位</code>表示<code>写状态</code>，具体情况如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-d6fb58d42d2a34ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="读写锁状态划分.png"></p>
<p>在上图中，我们能得知，读写状态能表示的最大值为<code>65535(排除负数)</code>，也就是说允许锁重进入的次数为65535次。</p>
<p>接下来 我们单看高16位，这里表示当前线程已经获取了写锁，且重进入了七次。同样的这里如果我们也只但看低16位，那么就表示当前线程获取了读锁，且重进入了七次。<code>这里大家需要注意的是，在实际的情况中，读状态与写状态是不能被不同线程同时赋值的。因为根据ReentrantReadWriteLock的设计来说，读写操作线程是互斥的。上图中这样表示，只是为了帮助大家理解同步状态的划分</code>。</p>
<p>到现在为止我们已经知道同步状态的划分，那接下来又有新的问题了。<code>如何快速的区分及获取读写状态呢？</code>其实也非常简单。</p>
<ul>
<li>读状态：想要获取读状态，只需要将当前同步变量<code>无符号右移16位</code></li>
<li>写状态：我们只需要将当前同步状态（这里用S表示）进行这样的操作<code>S&amp;0x0000FFFF)</code>，也就是<code>S&amp;(1&lt;&lt;16-1)</code>。</li>
</ul>
<p>也就是如下图所示（可能图片不是很清楚，建议在pc端上观看）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-114bde4afbe4afed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="读写锁状态原理.png"></p>
<h3 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h3><p>在了解了<code>ReentrantReadWriteLock</code>的整体原理及读写状态的划分后，我们再来理解其内部的读写线程控制就容易的多了，下面的文章中，我会对读锁与写锁的获取分别进行讨论。</p>
<h4 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h4><p>因为当调用<code>ReentrantReadWriteLock</code>中的<code>ReadLock</code>的lock()方法时，最终会走<code>Sync</code>中的<code>tryAcquireShared(int unused)</code>方法，来判断能否获取写锁。那现在我们就来看看该方法的具体实现。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">         Thread current = Thread.currentThread();</span><br><span class="line">         int c = getState();</span><br><span class="line">         //（1）判断当前是否有写锁，有直接返回</span><br><span class="line">         if (exclusiveCount(c) != 0 &amp;&amp;</span><br><span class="line">             getExclusiveOwnerThread() != current)</span><br><span class="line">             return -1;</span><br><span class="line">            </span><br><span class="line">         int r = sharedCount(c);</span><br><span class="line">          //(2)获取当前读锁的状态，判断是否小于最大值，</span><br><span class="line">          //同时根据公平锁，还是非公平锁的模式，判断当前线程是否需要阻塞，</span><br><span class="line">         if (!readerShouldBlock() &amp;&amp;</span><br><span class="line">             r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">              compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">             //（3)如果是不要阻塞，且写状态小于最大值，则设置当前线程重进入的次数</span><br><span class="line">             if (r == 0) &#123;</span><br><span class="line">        //如果当前读状态为0，则设置当前读线程为，当前线程为第一个读线程。</span><br><span class="line">                 firstReader = current;</span><br><span class="line">                 firstReaderHoldCount = 1;</span><br><span class="line">             &#125; else if (firstReader == current) &#123;</span><br><span class="line">           //计算第一个读线程，重进入的次数</span><br><span class="line">                 firstReaderHoldCount++;</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">              //通过ThreadLocl获取读线程中进入的锁</span><br><span class="line">                 HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                 if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                     cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                 else if (rh.count == 0)</span><br><span class="line">                     readHolds.set(rh);</span><br><span class="line">                 rh.count++;</span><br><span class="line">             &#125;</span><br><span class="line">             return 1;//获取共享同步状态成功</span><br><span class="line">         &#125;</span><br><span class="line">         //(4)当获取读状态失败后，继续尝试获取读锁，</span><br><span class="line">         return fullTryAcquireShared(current);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>（1）根据当前的同步状态，判断是否存在写锁，且当前拥有写锁的线程不是当前线程，那么直接返回<code>-1</code>，需要注意的是如果该方法返回值为负数，那么会将<strong>该请求线程加入到AQS的同步队列</strong>中。（对该方法不是很熟的小伙伴，建议查看 <a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener"> Java并发编程之锁机制之AQS(AbstractQueuedSynchronizer)</a></li>
<li>（2）获取当前读锁的状态，判断是否小于最大值，同时根据公平锁，还是非公平锁的模式，判断当前线程是否需要阻塞</li>
<li>（3）如果条件（2）满足，则设置分别<code>第一个读取线程重进入的次数</code>及<code>后续线程</code>重进入的次数</li>
<li>（4）如果条件（2）不满足，在再次尝试获取读锁。</li>
</ul>
<p>在读锁的获取中，涉及到的方法较为复杂，所以下面会对每个步骤中涉及到的方法，进行介绍。</p>
<h5 id="步骤（1）中如何判断是否有写锁？"><a href="#步骤（1）中如何判断是否有写锁？" class="headerlink" title="步骤（1）中如何判断是否有写锁？"></a>步骤（1）中如何判断是否有写锁？</h5><p>在读锁的获取中的步骤（1）中，代码中会调用<code>exclusiveCount(int c)</code>方法来判当前是否存在写锁。而该方法是属于<code>Sync</code>中的方法，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">    static final int SHARED_SHIFT   = 16;</span><br><span class="line">    static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;//最大状态数为2的16次方-1</span><br><span class="line">    static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line"></span><br><span class="line">    /*返回当前的读状态*/</span><br><span class="line">    static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">    /*返回当前的写状态 */</span><br><span class="line">    static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中我们可以看出，只是简单的执行了<code>c &amp; EXCLUSIVE_MASK</code>，也就是<code>S&amp;0x0000FFFF</code>，结合我们上文中我们所讲的读写状态的区分，我相信<code>exclusiveCount(int c)</code>与<code>sharedCount(int c)</code>方法是不难理解的。</p>
<h5 id="步骤（2）中如何判断是公平锁与非公平锁。"><a href="#步骤（2）中如何判断是公平锁与非公平锁。" class="headerlink" title="步骤（2）中如何判断是公平锁与非公平锁。"></a>步骤（2）中如何判断是公平锁与非公平锁。</h5><p>在步骤（2）中，我们发现调用了<code>readerShouldBlock()</code>方法，而该方法是<code>Sync</code>类中的抽象方法。在ReentrantReadWriteLock类中，公平锁与非公平锁进行了相应的实现，具体代码如下图所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//公平锁</span><br><span class="line">   static final class FairSync extends Sync &#123;</span><br><span class="line">       private static final long serialVersionUID = -2274990926593161451L;</span><br><span class="line">       final boolean writerShouldBlock()&#123;return hasQueuedPredecessors();&#125;</span><br><span class="line">       final boolean readerShouldBlock()&#123;return hasQueuedPredecessors();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //非公平锁</span><br><span class="line">   static final class NonfairSync extends Sync &#123;</span><br><span class="line">       final boolean writerShouldBlock() &#123; return false;&#125;</span><br><span class="line">       final boolean readerShouldBlock() &#123;return apparentlyFirstQueuedIsExclusive();&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就不再对公平锁与非公平锁进行分析了。在文章 <a href="https://www.jianshu.com/p/1068960ecd64" target="_blank" rel="noopener">Java并发编程之锁机制之（ReentrantLock)重入锁</a>中已经对这个知识点进行了分析。有兴趣的小伙伴可以参考该文章。</p>
<h5 id="步骤（3）中为毛要记录第一个获取写锁的线程？线程的重进入是如何实现的？"><a href="#步骤（3）中为毛要记录第一个获取写锁的线程？线程的重进入是如何实现的？" class="headerlink" title="步骤（3）中为毛要记录第一个获取写锁的线程？线程的重进入是如何实现的？"></a>步骤（3）中为毛要记录第一个获取写锁的线程？线程的重进入是如何实现的？</h5><p>在ReentrantReadWriteLock类中分别定义了<code>Thread firstReader</code>与<code>int firstReaderHoldCount</code>变量来记录当前<code>第一个</code>获取写锁的线程以及其重进入的次数。官方的给的解释是<code>便于跟踪与记录线程且这种记录是非常廉价的</code>。也就是说，之所以单独定义一个变量来记录第一个获取获取写锁的线程，是为了在众多的读线程中区分线程，也是为了以后的调试与跟踪。</p>
<p>当我们解决了第一个问题后，现在我们来解决第二个问题。这里我就不在对第一个线程如何记录重进入次数进行分析了。我们直接看其他读线程的重进入次数设置。这里因为篇幅的限制，我就直接讲原理，其他线程的重进入的次数判断是通过<code>ThreadLocal</code>来实现的。通过在每个线程中的内存空间保存<code>HodlerCount</code>类（用于记录当前线程获取锁的次数），来获取相应的次数。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static final class HoldCounter &#123;</span><br><span class="line">         int count;//记录当前线程进入的次数</span><br><span class="line">         final long tid = getThreadId(Thread.currentThread());</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">static final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt; &#123;</span><br><span class="line">         public HoldCounter initialValue() &#123;</span><br><span class="line">             return new HoldCounter();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">private transient ThreadLocalHoldCounter readHolds;</span><br></pre></td></tr></table></figure></p>
<p>如果有小伙伴不熟悉<code>ThreadLocal</code>，可以参看该篇文章<a href="https://www.jianshu.com/p/2a34d30806d4" target="_blank" rel="noopener">《Android Handler机制之ThreadLocal》</a></p>
<h5 id="步骤（4）中继续尝试获取读锁？"><a href="#步骤（4）中继续尝试获取读锁？" class="headerlink" title="步骤（4）中继续尝试获取读锁？"></a>步骤（4）中继续尝试获取读锁？</h5><p>当第一次获取读锁失败的时候，会调用<code>fullTryAcquireShared(Thread current)</code>方法会继续尝试获取锁。该函数返回的三个条件为：</p>
<ul>
<li>当前已经存在写锁了。直接加入AQS中的同步队列中。</li>
<li>当前写锁的次数超过最大值，直接抛出异常</li>
<li>获取读锁成功。直接返回</li>
</ul>
<p>具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">final int fullTryAcquireShared(Thread current) &#123;</span><br><span class="line">        HoldCounter rh = null;</span><br><span class="line">        for (;;) &#123;//注意这里的for循环</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (exclusiveCount(c) != 0) &#123;//（1）存在写锁直接返回</span><br><span class="line">                if (getExclusiveOwnerThread() != current)</span><br><span class="line">                    return -1;</span><br><span class="line">            &#125; else if (readerShouldBlock()) &#123;</span><br><span class="line">                // Make sure we&apos;re not acquiring read lock reentrantly</span><br><span class="line">                if (firstReader == current) &#123;</span><br><span class="line">                    // assert firstReaderHoldCount &gt; 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (rh == null) &#123;</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                        if (rh == null || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                            if (rh.count == 0)</span><br><span class="line">                                readHolds.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (rh.count == 0)</span><br><span class="line">                        return -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sharedCount(c) == MAX_COUNT)//(2)锁迭代次数超过最大值。抛出异常</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            if (compareAndSetState(c, c + SHARED_UNIT)) &#123;//(3)获取锁成功，记录次数</span><br><span class="line">                if (sharedCount(c) == 0) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = 1;</span><br><span class="line">                &#125; else if (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (rh == null)</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                    if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                    else if (rh.count == 0)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                    cachedHoldCounter = rh; // cache for release</span><br><span class="line">                &#125;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>因为该方法和上文提到的<code>tryAcquireShared(int unused)</code>方法较为类似。所以这里就不再对其中的逻辑再次讲解。大家需要注意的是该方法会<code>自旋式的获取锁</code>。</p>
<h4 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h4><p>了解了读锁的获取，再来了解写锁的获取就非常简单了。写锁的获取最终会走<code>Sync</code>中的<code>tryAcquire(int acquires)</code>方法。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">         Thread current = Thread.currentThread();</span><br><span class="line">         //（1）获取同步状态 = 写状态+读状态，单独获取写状态</span><br><span class="line">         int c = getState();</span><br><span class="line">         int w = exclusiveCount(c);</span><br><span class="line">         //（2）如果c!=0则表示有线程操作</span><br><span class="line">         if (c != 0) &#123;</span><br><span class="line">             // （2.1）没有写锁线程，则表示有读线程，则直接获取失败，并返回</span><br><span class="line">             if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">                 return false;</span><br><span class="line">                 </span><br><span class="line">              //（2.2）如果w&gt;0则，表示当前线程为写线程，则计算当前重进入的次数，如果已经饱和，则抛出异常</span><br><span class="line">             if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                 throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                 </span><br><span class="line">             // （2.3）获取成功，直接记录当前写状态</span><br><span class="line">             setState(c + acquires);</span><br><span class="line">             return true;</span><br><span class="line">         &#125;</span><br><span class="line">         //（3）没有线程获取读写锁，根据当前锁的模式与设置写状态是否成功，判断是否需要阻塞线程</span><br><span class="line">         if (writerShouldBlock() ||</span><br><span class="line">             !compareAndSetState(c, c + acquires))</span><br><span class="line">             return false;</span><br><span class="line">         //(4)第一次进入，获取成功   </span><br><span class="line">         setExclusiveOwnerThread(current);</span><br><span class="line">         return true;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>为了帮助大家理解，我这里将该方法分为了一下几个步骤：</p>
<ul>
<li>（1）获取同步状态 <code>c</code>（写状态+读状态），并单独获取写状态<code>w</code>。</li>
<li>（2）如果<code>c!=0</code>则表示有线程操作。</li>
<li>（2.1）没有写锁线程，则表示有读线程，则直接获取失败，并返回。</li>
<li>（2.2）如果<code>w&gt;0</code>则，表示当前线程为写线程，则计算当前重进入的次数，如果已经饱和，<code>则抛出异常</code>。</li>
<li>（2.3）获取成功，直接记录当前写状态。</li>
<li>（3）在（2）条件不满足的条件下，没有线程获取读写锁，根据当前锁的模式与设置写状态是否成功，判断是否需要阻塞线程</li>
<li>（4）在（2）（3）条件都不满足的情况下，则为第一次进入，那么就获取成功 。</li>
</ul>
<p>相信结合以上步骤。再来理解代码就非常容易了。</p>
<h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p>读写锁除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁也能简化读写交互的编程方式，试想一种情况，在程序中我们需要定义一个共享的用作缓存数据结构，并且其大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是我们又希望写操作完成之后的更新需要对后续的读操作可见。那么该怎么实现呢？参看如下例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CachedData &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    volatile boolean cacheValid;</span><br><span class="line">    final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">    </span><br><span class="line">    void processCachedData() &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        if (!cacheValid) &#123;</span><br><span class="line">            //如果缓存过期，释放读锁，并获取写锁</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();（1）</span><br><span class="line">            try &#123;</span><br><span class="line">                //重新检查缓存是否过期，因为有可能在当前线程操作之前，其他写线程有可能改变缓存状态</span><br><span class="line">                if (!cacheValid) &#123;</span><br><span class="line">                    data = ...//重新写入数据</span><br><span class="line">                    cacheValid = true;</span><br><span class="line">                &#125;</span><br><span class="line">                // 获取读锁</span><br><span class="line">                rwl.readLock().lock();（2）</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">	            //释放写锁</span><br><span class="line">                rwl.writeLock().unlock(); （3）</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            use(data);//操作使用数据</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            rwl.readLock().unlock();//最后释放读锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述例子中，如果数据缓存过期，也就是cacheValid变量（volatile 修饰的布尔类型）被设置为false，那么所有调用processCachedData（）方法的线程都能感知到变化，但是只有一个线程能过获取到写锁。其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁（上述代码的（1）（2）（3）三个步骤），<strong>这种在拥有写锁的情况下，在获取读锁。随后释放写锁的过程，称之为锁降级（在读写锁内部实现中，是支持锁锁降级的）</strong>。</p>
<p>那接下来，我个问题想问大家，<code>为什么当线程获取写锁，修改数据完成后，要先获取读锁呢，而不直接释放写锁呢？</code>，其实原因很简单，如果当前线程直接释放写锁，那么这个时候如果有其他线程获取了写锁，并修改了数据。那么对于当前释放写锁的线程是无法感知数据变化的。先获取读锁的目的，就是保证没有其他线程来修改数据啦。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>ReentrantReadWriteLock最多支持 <code>65535</code> 个递归写入锁和<code>65535</code>个读取锁。</li>
<li>ReentrantReadWriteLock中用同一<code>int</code>变量的<code>高16位</code>表示<code>读状态</code>，<code>低16位</code>表示<code>写状态</code>。</li>
<li>ReentrantReadWriteLock支持公平锁与非公平锁模式。</li>
<li>ReentrantReadWriteLock支持锁的降级。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之锁机制之ReentrantReadWriteLock（读写锁）/" data-id="cjsheb86v000pdsr7n17eklvy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程之锁机制之LockSupport工具" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之锁机制之LockSupport工具/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-77a37f0a5b7690cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="长鼻子.jpg"></p>
<blockquote>
<p>关于文章涉及到的jdk源码，这里把最新的jdk源码分享给大家—–&gt;<a href="https://pan.baidu.com/s/1Lk9yp8cEpSAnLvw5NJdqZg" target="_blank" rel="noopener">jdk源码</a></p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上篇文章<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">《Java并发编程之锁机制之AQS(AbstractQueuedSynchronizer)》</a>中我们了解了整个AQS的内部结构，与其独占式与共享式获取同步状态的实现。但是并没有详细描述线程是如何进行阻塞与唤醒的。我也提到了线程的这些操作都与<code>LockSupport</code>工具类有关。现在我们就一起来探讨一下该类的具体实现。</p>
<h3 id="LockSupport类"><a href="#LockSupport类" class="headerlink" title="LockSupport类"></a>LockSupport类</h3><p>了解线程的阻塞和唤醒，我们需要查看LockSupport类。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public class LockSupport &#123;</span><br><span class="line">    private LockSupport() &#123;&#125; // Cannot be instantiated.</span><br><span class="line"></span><br><span class="line">    private static void setBlocker(Thread t, Object arg) &#123;</span><br><span class="line">        U.putObject(t, PARKBLOCKER, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void unpark(Thread thread) &#123;</span><br><span class="line">        if (thread != null)</span><br><span class="line">            U.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void park(Object blocker) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        U.park(false, 0L);</span><br><span class="line">        setBlocker(t, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void parkNanos(Object blocker, long nanos) &#123;</span><br><span class="line">        if (nanos &gt; 0) &#123;</span><br><span class="line">            Thread t = Thread.currentThread();</span><br><span class="line">            setBlocker(t, blocker);</span><br><span class="line">            U.park(false, nanos);</span><br><span class="line">            setBlocker(t, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void parkUntil(Object blocker, long deadline) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        U.park(true, deadline);</span><br><span class="line">        setBlocker(t, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    public static Object getBlocker(Thread t) &#123;</span><br><span class="line">        if (t == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        return U.getObjectVolatile(t, PARKBLOCKER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void park() &#123;</span><br><span class="line">        U.park(false, 0L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void parkNanos(long nanos) &#123;</span><br><span class="line">        if (nanos &gt; 0)</span><br><span class="line">            U.park(false, nanos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void parkUntil(long deadline) &#123;</span><br><span class="line">        U.park(true, deadline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //省略部分代码</span><br><span class="line">    private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">    private static final long PARKBLOCKER;</span><br><span class="line">    private static final long SECONDARY;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            PARKBLOCKER = U.objectFieldOffset</span><br><span class="line">                (Thread.class.getDeclaredField(&quot;parkBlocker&quot;));</span><br><span class="line">            SECONDARY = U.objectFieldOffset</span><br><span class="line">                (Thread.class.getDeclaredField(&quot;threadLocalRandomSecondarySeed&quot;));</span><br><span class="line">        &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码中，我们可以知道LockSupport中的对外提供的方法都是<code>静态方法</code>。这些方法提供了最基本的线程阻塞和唤醒功能，在LockSupport类中定义了一组以park开头的方法用来阻塞当前线程。以及<code>unPark(Thread thread)</code>方法来唤醒一个被阻塞的线程。关于park开头的方法具体描述如下表所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-291438fe9894d7c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="park.png"></p>
<p>其中<code>park(Object blocker)</code>与<code>parkNanos(Object blocker, long nanos)</code>及<code>parkUntil(Object blocker, long deadline)</code>三个方法是Java 6中新增加的方法。其中参数blocker是用来标识当前线程等待的对象（下文简称为阻塞对象），<code>该对象主要用于问题排查和系统监控</code>。</p>
<blockquote>
<p>由于在Java 5之前，当线程阻塞时（使用synchronized关键字）在一个对象上时，通过线程dump能够查看到该线程的阻塞对象。方便问题定位，而Java 5退出的Lock等并发工具却遗漏了这一点，致使在线程dump时无法提供阻塞对象的信息。因此，在Java 6中，LockSupport新增了含有阻塞对象的park方法。用以替代原有的park方法。</p>
</blockquote>
<h3 id="LockSupport中的blocker"><a href="#LockSupport中的blocker" class="headerlink" title="LockSupport中的blocker"></a>LockSupport中的blocker</h3><p> 可能有很多读者对Blocker的原理有点好奇，既然线程都被阻塞了，<code>是通过什么办法将阻塞对象设置到线程中去的呢？</code> 不急不急，我们继续查看含有阻塞对象(Object blocker)的park方法。 我们发现内部都调用了<code>setBlocker(Thread t, Object arg)</code>方法。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static void setBlocker(Thread t, Object arg) &#123;</span><br><span class="line">     U.putObject(t, PARKBLOCKER, arg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>U</code>为sun.misc.包下的<code>Unsafe</code>类。而其中的<code>PARKBLOCKER</code>是在静态代码块中进行赋值的，也就是如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">  static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            PARKBLOCKER = U.objectFieldOffset</span><br><span class="line">                (Thread.class.getDeclaredField(&quot;parkBlocker&quot;));</span><br><span class="line">		   //省略部分代码</span><br><span class="line">        &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Thread.class.getDeclaredField(&quot;parkBlocker&quot;)</code>方法其实很好理解，就是获取线程中的<code>parkBlocker</code>字段。如果有则返回其对应的Field字段，如果没有则抛出<code>NoSuchFieldException</code>异常。那么关于Unsafe中的<code>objectFieldOffset(Field f)</code>方法怎么理解呢？ </p>
<p>在描述该方法之前，需要给大家讲一个知识点。在JVM中，可以自由选择如何实现Java对象的<code>&quot;布局&quot;</code>,也就Java对象的各个部分分别放在内存那个地方，JVM是可以感知和决定的。 在sun.misc.Unsafe中提供了<code>objectFieldOffset()</code>方法用于获取某个字段相对 Java对象的“起始地址”的偏移量,也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。</p>
<p> 有可能大家理解起来比较困难，这里给大家画了一个图，帮助大家理解，具体如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-7636697f1503ed60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="blocker.png"></p>
<p>在上图中，我们创建了两个Thread对象，其中Thread对象1在内存中分配的地址为<code>0x10000-0x10100</code>,Thread对象2在内存中分配的地址为<code>0x11000-0x11100</code>,其中<code>parkBlocker</code>对应内存偏移量为2（这里我们假设相对于其对象的“起始位置”的偏移量为2）。那么通过<code>objectFieldOffset(Field f)</code>就能获取该字段的偏移量。需要注意的是<code>某字段在其类中的内存偏移量总是相同的</code>，也就是对于Thread对象1与Thread对象2，parkBlocker字段在其对象所在的内存偏移量始终是相同的。</p>
<p>那么我们再回到<code>setBlocker(Thread t, Object arg)</code>方法，当我们获取到<code>parkBlocker</code>字段在其对象内存偏移量后，<br>接着会调用<code>U.putObject(t, PARKBLOCKER, arg);</code>，该方法有三个参数,第一个参数是操作对象，第二个参数是内存偏移量，第三个参数是实际存储值。该方法理解起来也很简单，就是<code>操作某个对象中某个内存地址下的数据</code>。那么结合我们上面所讲的。该方法的实际操作结果如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-8094f6979df5fe6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="blocker_set.png"></p>
<p>到现在，我们就应该懂了，<code>尽管当前线程已经阻塞</code>，但是我们还是能直接操控线程中<code>实际存储该字段的内存区域</code>来达到我们想要的结果。</p>
<h3 id="LockSupport底层代码实现"><a href="#LockSupport底层代码实现" class="headerlink" title="LockSupport底层代码实现"></a>LockSupport底层代码实现</h3><p>通过阅读源代码我们可以发现，LockSupport中关于线程的阻塞和唤醒，主要调用的是sun.misc.Unsafe 中的<code>park(boolean isAbsolute, long time)</code>与<code>unpark(Object thread)</code>方法，也就是如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   private static final jdk.internal.misc.Unsafe theInternalUnsafe =   </span><br><span class="line">     jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line">     </span><br><span class="line">public void park(boolean isAbsolute, long time) &#123;</span><br><span class="line">       theInternalUnsafe.park(isAbsolute, time);</span><br><span class="line">   &#125;</span><br><span class="line">   public void unpark(Object thread) &#123;</span><br><span class="line">       theInternalUnsafe.unpark(thread);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>查看sun.misc.包下的Unsafe.java文件我们可以看出，内部其实调用的是jdk.internal.misc.Unsafe中的方法。继续查看jdk.internal.misc.中的Unsafe.java中对应的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public native void unpark(Object thread);</span><br><span class="line"></span><br><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public native void park(boolean isAbsolute, long time);</span><br></pre></td></tr></table></figure></p>
<p>通过查看方法，我们可以得出最终调用的是JVM中的方法，也就是会调用<code>hotspot.share.parims</code>包下的<code>unsafe.cpp</code>中的方法。继续跟踪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(void, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time)) &#123;</span><br><span class="line">  //省略部分代码</span><br><span class="line">  thread-&gt;parker()-&gt;park(isAbsolute != 0, time);</span><br><span class="line">  //省略部分代码</span><br><span class="line">&#125; UNSAFE_END</span><br><span class="line"></span><br><span class="line">UNSAFE_ENTRY(void, Unsafe_Unpark(JNIEnv *env, jobject unsafe, jobject jthread)) &#123;</span><br><span class="line">  Parker* p = NULL;</span><br><span class="line">  //省略部分代码</span><br><span class="line">  if (p != NULL) &#123;</span><br><span class="line">    HOTSPOT_THREAD_UNPARK((uintptr_t) p);</span><br><span class="line">    p-&gt;unpark();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; UNSAFE_END</span><br></pre></td></tr></table></figure></p>
<p>通过观察代码我们发现，线程的阻塞和唤醒其实是与<code>hotspot.share.runtime</code>中的<code>Parker类</code>相关。我们继续查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Parker : public os::PlatformParker &#123;</span><br><span class="line">private:</span><br><span class="line">  volatile int _counter ;//该变量非常重要，下文我们会具体描述</span><br><span class="line">	 //省略部分代码</span><br><span class="line">protected:</span><br><span class="line">  ~Parker() &#123; ShouldNotReachHere(); &#125;</span><br><span class="line">public:</span><br><span class="line">  // For simplicity of interface with Java, all forms of park (indefinite,</span><br><span class="line">  // relative, and absolute) are multiplexed into one call.</span><br><span class="line">  void park(bool isAbsolute, jlong time);</span><br><span class="line">  void unpark();</span><br><span class="line">  //省略部分代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，<code>volatile int _counter</code>该字段的值非常重要，<code>一定要注意其用volatile修饰</code>（在下文中会具体描述，接着当我们通过<code>SourceInsight</code>工具(推荐大家阅读代码时，使用该工具)点击其park与unpark方法时，我们会得到如下界面：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-41e5cbf9d13ed218.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="parker.png"></p>
<p>从图中红色矩形中我们可也看出，针对线程的阻塞和唤醒，<code>不同操作系统有着不同的实现</code>。众所周知Java是跨平台的。针对不同的平台，做出不同的处理。也是非常理解的。因为作者对windows与solaris操作系统不是特别了解。所以这里我选择对Linux下的平台下进行分析。也就是选择<code>hotspot.os.posix</code>包下的<code>os_posix.cpp</code>文件进行分析。</p>
<h4 id="Linux下的park实现"><a href="#Linux下的park实现" class="headerlink" title="Linux下的park实现"></a>Linux下的park实现</h4><p>为了方便大家理解Linux下的阻塞实现，在实际代码中我省略了一些不重要的代码，具体如下图所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">void Parker::park(bool isAbsolute, jlong time) &#123;</span><br><span class="line"></span><br><span class="line">  //(1)如果_counter的值大于0，那么直接返回</span><br><span class="line">  if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;</span><br><span class="line">    </span><br><span class="line">  //获取当前线程</span><br><span class="line">  Thread* thread = Thread::current();</span><br><span class="line">  JavaThread *jt = (JavaThread *)thread;</span><br><span class="line">  </span><br><span class="line">  //(2)如果当前线程已经中断，直接返回。</span><br><span class="line">  if (Thread::is_interrupted(thread, false)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //(3)判断时间，如果时间小于0，或者在绝对时间情况下，时间为0直接返回</span><br><span class="line">  struct timespec absTime;</span><br><span class="line">  if (time &lt; 0 || (isAbsolute &amp;&amp; time == 0)) &#123; // don&apos;t wait at all</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  //如果时间大于0，判断阻塞超时时间或阻塞截止日期，同时将时间赋值给absTime</span><br><span class="line">  if (time &gt; 0) &#123;</span><br><span class="line">    to_abstime(&amp;absTime, time, isAbsolute);</span><br><span class="line">  &#125;</span><br><span class="line">  //(4)如果当前线程已经中断，或者申请互斥锁失败，则直接返回</span><br><span class="line">  if (Thread::is_interrupted(thread, false) ||</span><br><span class="line">      pthread_mutex_trylock(_mutex) != 0) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //(5)如果是时间等于0,那么就直接阻塞线程，</span><br><span class="line">  if (time == 0) &#123;</span><br><span class="line">    _cur_index = REL_INDEX; // arbitrary choice when not timed</span><br><span class="line">    status = pthread_cond_wait(&amp;_cond[_cur_index], _mutex);</span><br><span class="line">    assert_status(status == 0, status, &quot;cond_timedwait&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  //(6)根据absTime之前计算的时间，阻塞线程相应时间</span><br><span class="line">  else &#123;</span><br><span class="line">    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;</span><br><span class="line">    status = pthread_cond_timedwait(&amp;_cond[_cur_index], _mutex, &amp;absTime);</span><br><span class="line">    assert_status(status == 0 || status == ETIMEDOUT,</span><br><span class="line">                  status, &quot;cond_timedwait&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //省略部分代码</span><br><span class="line">  //(7)当线程阻塞超时，或者到达截止日期时，直接唤醒线程  </span><br><span class="line">  _counter = 0;</span><br><span class="line">  status = pthread_mutex_unlock(_mutex);</span><br><span class="line"></span><br><span class="line"> //省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从整个代码来看其实关于Linux下的park方法分为以下七个步骤：</p>
<ul>
<li>（1）调用<code>Atomic::xchg</code>方法，将<code>_counter</code>的值赋值为0，其方法的返回值为<code>之前_counter的值</code>，如果返回值<code>大于0</code>（因为有其他线程操作过_counter的值，也就是其他线程调用过<code>unPark</code>方法)，那么就直接返回。</li>
<li>（2）如果当前线程已经中断，直接返回。也就是说如果当前线程已经中断了，那么调用park()方法来阻塞线程就会无效。</li>
<li>（3） 判断其设置的时间是否合理，如果合理，判断<code>阻塞超时时间</code>或<code>阻塞截止日期</code>，同时将时间赋值给<code>absTime</code></li>
<li>（4） 在实际对线程进行阻塞前，再一次判断如果当前线程已经中断，或者申请互斥锁失败，则直接返回</li>
<li>（5） 如果是时间等于0（时间为0，表示一直阻塞线程，除非调用unPark方法唤醒），那么就直接阻塞线程，</li>
<li>（6）根据absTime之前计算的时间，并调用<code>pthread_cond_timedwait</code>方法阻塞线程相应的时间。</li>
<li>（7） 当线程阻塞相应时间后，通过<code>pthread_mutex_unlock</code>方法直接唤醒线程,同时将<code>_counter</code>赋值为0。</li>
</ul>
<p>因为关于Linux的阻塞涉及到其内部函数，这里将用到的函数都进行了声明。大家可以根据下表所介绍的方法进行理解。具体方法如下表所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-95dfa50270728585.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="linux方法.png"></p>
<h4 id="Linux下的unpark实现"><a href="#Linux下的unpark实现" class="headerlink" title="Linux下的unpark实现"></a>Linux下的unpark实现</h4><p>在了解了Linux的park实现后，再来理解Linux的唤醒实现就非常简单了，查看相应方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Parker::unpark() &#123;</span><br><span class="line">  int status = pthread_mutex_lock(_mutex);</span><br><span class="line">  assert_status(status == 0, status, &quot;invariant&quot;);</span><br><span class="line">  const int s = _counter;</span><br><span class="line">  //将_counter的值赋值为1</span><br><span class="line">  _counter = 1;</span><br><span class="line">  // must capture correct index before unlocking</span><br><span class="line">  int index = _cur_index;</span><br><span class="line">  status = pthread_mutex_unlock(_mutex);</span><br><span class="line">  assert_status(status == 0, status, &quot;invariant&quot;);</span><br><span class="line">  //省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实从代码整体逻辑来讲，最终唤醒其线程的方法为<code>pthread_mutex_unlock(_mutex)</code>（关于该函数的作用，我已经在上表进行介绍了。大家可以参照Linux下的park实现中的图表进行理解）。同时将<code>_counter的值赋值为1</code>, 那么结合我们上文所讲的park(将线程进行阻塞)方法，那么我们可以得知整个线程的唤醒与阻塞，在Linux系统下，其实是受到<code>Parker类中的_counter的值的影响的</code>。</p>
<h3 id="LockSupport的使用"><a href="#LockSupport的使用" class="headerlink" title="LockSupport的使用"></a>LockSupport的使用</h3><p>现在我们基本了解了LockSupport的基本原理。现在我们来看看它的基本使用吧。在例子中，为了方便大家顺便弄清blocker的作用，这里我调用了带blocker的park方法。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class LockSupportDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread a = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                LockSupport.park(&quot;线程a的blocker数据&quot;);</span><br><span class="line">                System.out.println(&quot;我是被线程b唤醒后的操作&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        //让当前主线程睡眠1秒，保证线程a在线程b之前执行</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        Thread b = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                </span><br><span class="line">                String before = (String) LockSupport.getBlocker(a);</span><br><span class="line">                System.out.println(&quot;阻塞时从线程a中获取的blocker------&gt;&quot; + before);</span><br><span class="line">                LockSupport.unpark(a);</span><br><span class="line">                </span><br><span class="line">                //这里睡眠是，保证线程a已经被唤醒了</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    String after = (String) LockSupport.getBlocker(a);</span><br><span class="line">                    System.out.println(&quot;唤醒时从线程a中获取的blocker------&gt;&quot; + after);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中，创建了两个线程，线程a与线程b（线程a优先运行与线程b），在线程a中，通过调用<code>LockSupport.park(&quot;线程a的blocker数据&quot;);</code>给线程a设置了一个String类型的blocker，当线程a运行的时候，直接将线程a阻塞。在线程b中，先会获取线程a中的blocker，打印输出后。再通过<code>LockSupport.unpark(a);</code>唤醒线程a。当唤醒线程a后。最后输出并打印线程a中的blocker。  实际代码运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">阻塞时从线程a中获取的blocker------&gt;线程a的blocker数据</span><br><span class="line">我是被线程b唤醒后的操作</span><br><span class="line">唤醒时从线程a中获取的blocker------&gt;null</span><br></pre></td></tr></table></figure></p>
<p>从结果中，我们可以看出，线程a被阻塞时，后续就不会再进行操作了。当线程a被线程b唤醒后。之前设置的blocker也变为null了。同时如果在线程a中park语句后还有额外的操作。那么会继续运行。关于为毛之前的blocker之前变为null，具体原因如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void park(Object blocker) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    U.park(false, 0L);//当线程被阻塞时，会阻塞在这里</span><br><span class="line">    setBlocker(t, null);//线程被唤醒时，会将blocer置为null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上述例子，我们完全知道了blocker可以在线程阻塞的时候，获取数据。也就证明了当我们对线程进行问题排查和系统监控的时候blocker的有着非常重要的作用。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>该文章参考以下博客，站在巨人的肩膀上。可以看得更远。</p>
<p><a href="https://www.cnblogs.com/Jimmy1988/p/7822478.html" target="_blank" rel="noopener">Linux 多线程 - 线程异步与同步机制</a></p>
<p><a href="https://blog.csdn.net/secsf/article/details/78560013" target="_blank" rel="noopener">LockSupport解析与使用</a></p>
<p><a href="https://www.cnblogs.com/qingquanzi/p/8228422.html" target="_blank" rel="noopener">自己动手写把”锁”—LockSupport深入浅出</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之锁机制之LockSupport工具/" data-id="cjsheb86v000qdsr7e3oc1p4h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程之锁机制之（ReentrantLock)重入锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之锁机制之（ReentrantLock)重入锁/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-b990e9d2f1578e83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小兔子.jpg"></p>
<blockquote>
<p>最近在忙公司的项目，现在终于有时间来写博客啦~开心开心</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>通过前面的文章，我们已经了解了<code>AQS(AbstractQueuedSynchronizer)</code>内部的实现与基本原理。现在我们来了解一下，Java中为我们提供的Lock机制下的锁实现–<code>ReentrantLock（重入锁）</code>，阅读该篇文章之前，希望你已阅读以下文章。</p>
<ul>
<li><a href="https://www.jianshu.com/p/6874d9b4f3d8" target="_blank" rel="noopener"> Java并发编程之锁机制之Lock接口</a></li>
<li><a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener"> Java并发编程之锁机制之AQS(AbstractQueuedSynchronizer)</a></li>
<li><a href="https://www.jianshu.com/p/d0e84096d108" target="_blank" rel="noopener">Java并发编程之锁机制之LockSupport工具</a></li>
<li><a href="https://www.jianshu.com/p/a22855b8820a" target="_blank" rel="noopener">Java并发编程之锁机制之Condition接口</a></li>
</ul>
<h3 id="ReentrantLock基本介绍"><a href="#ReentrantLock基本介绍" class="headerlink" title="ReentrantLock基本介绍"></a>ReentrantLock基本介绍</h3><p><code>ReentrantLock</code>是一种<code>可重入</code>的<code>互斥锁</code>，它具有与使用<code>synchronized</code>方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</p>
<p><code>ReentrantLock</code> 将由最近成功获得锁，并且还没有释放该锁的线程所拥有。当锁没有被另一个线程所拥有时，调用 lock 的线程将成功获取该锁并返回。如果当前线程已经拥有该锁，此方法将立即返回。可以使用<code>isHeldByCurrentThread()</code> 和 <code>getHoldCount()</code>方法来检查此情况是否发生。</p>
<p>此类的构造方法接受一个可选的<code>公平</code>参数。当设置为 true 时(也是当前<code>ReentrantLock为公平锁的情况</code>)，在多个线程的争用下，这些锁倾向于将访问权授予等待时间最长的线程。否则此锁将无法保证任何特定访问顺序。与采用默认设置（使用不公平锁）相比，使用公平锁的程序在许多线程访问时表现为很低的总体吞吐量（即速度很慢，常常极其慢），但是在获得锁和保证锁分配的均衡性时差异较小。不过要注意的是，公平锁不能保证线程调度的公平性。因此，使用公平锁的众多线程中的一员可能获得多倍的成功机会，这种情况发生在其他活动线程没有被处理并且目前并未持有锁时。还要注意的是，未定时的 tryLock 方法并没有使用公平设置。因为即使其他线程正在等待，只要该锁是可用的，此方法就可以获得成功。</p>
<h3 id="ReentrantLock-类基本结构"><a href="#ReentrantLock-类基本结构" class="headerlink" title="ReentrantLock 类基本结构"></a>ReentrantLock 类基本结构</h3><p>通过上文的简单介绍后，我相信很多小伙伴还是一脸懵逼，只知道上文我们提到了<code>ReentrantLock</code>与<code>synchronized</code>相比有相同的语义，同时其内部分为了<code>公平锁</code>与<code>非公平锁</code>两种锁的类型，且该锁是支持<code>重进入</code>的。那么为了方便大家理解这些知识点，我们先从其类的基本结构讲起。具体类结构如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-435e7270822a79cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ReentrantLock.png"></p>
<p>从上图中我们可以看出，在<code>ReentrantLock</code>类中，定义了三个静态内部类，<strong>Sync</strong>、<strong>FairSync（公平锁）</strong>、<strong>NonfairSync（非公平锁</strong>）。其中<code>Sync</code>继承了<code>AQS（AbstractQueuedSynchronizer）</code>，而<code>FairSync</code>与<code>NonfairSync</code>又分别继承了<code>Sync</code>。关于<code>ReentrantLock</code>基本类结构如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">    private final Sync sync;</span><br><span class="line"></span><br><span class="line">	//默认无参构造函数，默认为非公平锁</span><br><span class="line">    public ReentrantLock() &#123;</span><br><span class="line">        sync = new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">	//带参数的构造函数，用户自己来决定是公平锁还是非公平锁</span><br><span class="line">    public ReentrantLock(boolean fair) &#123;</span><br><span class="line">        sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">    //抽象基类继承AQS，公平锁与非公平锁继承该类，并分别实现其lock()方法</span><br><span class="line">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        abstract void lock();</span><br><span class="line">        //省略部分代码..</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	//非公平锁实现</span><br><span class="line">    static final class NonfairSync extends Sync &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //公平锁实现</span><br><span class="line">    static final class FairSync extends Sync &#123;....&#125;</span><br><span class="line">   </span><br><span class="line">    //锁实现，根据具体子类实现调用</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line">	//响应中断的获取锁</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line">	//尝试获取锁，默认采用非公平锁方法实现</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.nonfairTryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">	//超时获取锁</span><br><span class="line">    public boolean tryLock(long timeout, TimeUnit unit)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">	//释放锁</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建锁条件（从Condetion来理解，就是创建等待队列）</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    //省略部分代码....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里为了方便大家理解<code>ReentrantLock</code>类的整体结构，我省略了一些代码及重新排列了一些代码的顺序。</p>
</blockquote>
<p>从代码中我们可以看出。整个<code>ReentrantLock</code>类的实现其实都是交给了其内部<code>FairSync</code>与<code>NonfairSync</code>两个类。在<code>ReentrantLock</code>类中有两个构造函数，其中不带参数的构造函数中默认使用的<code>NonfairSync（非公平锁）</code>。另一个带参数的构造函数，用户自己来决定是<code>FairSync（公平锁）</code>还是非公平锁。</p>
<h3 id="重进入实现"><a href="#重进入实现" class="headerlink" title="重进入实现"></a>重进入实现</h3><p>在上文中，我们提到了<code>ReentrantLock</code>是支持重进入的，那什么是重进入呢？<code>重进入是指任意线程在获取到锁之后能够再次获取该锁，而不会被锁阻塞</code>。那接下来我们看看这个例子，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class ReentrantLockDemo &#123;</span><br><span class="line">    private static final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                methodA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void methodA() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;我已经进入methodA方法了&quot;);</span><br><span class="line">            methodB();//方法A中继续调用方法B</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void methodB() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;我已经进入methodB方法了&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出结果</span><br><span class="line">我已经进入methodA方法了</span><br><span class="line">我已经进入methodB方法了</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中我们声明了一个线程调用methodA()方法。同时在该方法内部我们又调用了methodB()方法。从实际的代码运行结果来看，当前线程进入方法A之后。在方法B中再次调用<code>lock.lock();</code>时，该线程并没有被阻塞。也就是说<code>ReentrantLock</code>是支持重进入的。那下面我们就一起来看看其内部的实现原理。</p>
<p>因为<code>ReenTrantLock</code>将具体实现交给了<code>NonfairSync（非公平锁）</code>与<code>FairSync(公平锁)</code>。同时又因为上述提到的两个锁，关于重进入的实现又非常相似。所以这里将采用<code>NonfairSync（非公平锁）</code>的重进入的实现，来进行分析。希望读者朋友们阅读到这里的时候需要注意，不是我懒哦，是真的很相似哦。</p>
<p>好了下面我们来看代码。关于NonfairSync代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            if (compareAndSetState(0, 1))////直接获取同步状态成功，那么就不再走尝试获取锁的过程</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            else</span><br><span class="line">                acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            return nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们调用lock()方法时，通过CAS操作将AQS中的state的状态设置为1，如果成功，那么表示获取同步状态成功。那么会接着调用<code>setExclusiveOwnerThread(Thread thread)</code>方法来设置当前占有锁的线程。如果失败，则调用<code>acquire(int arg)</code>方法来获取同步状态（该方法是属于AQS中的独占式获取同步状态的方法，对该方法不熟悉的小伙伴，建议阅读<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener"> Java并发编程之锁机制之AQS(AbstractQueuedSynchronizer)</a>）。而该方法内部会调用<code>tryAcquire(int acquires)</code>来尝试获取同步状态。通过观察，我们发现最终会调用<code>Sync</code>类中的<code>nonfairTryAcquire(int acquires)</code>方法。我们继续跟踪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">  //获取当前线程</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        //(1)判断同步状态，如果未设置，则设置同步状态</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //(2)如果当前线程已经获取了同步状态，则增加同步状态的值。</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0) // overflow</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码上来看，该方法主要走两个步骤，具体如下所示：</p>
<ul>
<li>（1）先判断同步状态， 如果未曾设置，则设置同步状态，并设置当前占有锁的线程。</li>
<li>（2）判断是否是同一线程，如果当前线程已经获取了同步状态（也就是获取了锁），那么增加同步状态的值。</li>
</ul>
<p>也就是说，如果同一个锁获取了锁N(<code>N为正整数</code>)次，那么对应的同步状态<code>（state)</code>也就等于N。那么接下来的问题来了，<code>如果当前线程重复N次获取了锁，那么该线程是否需要释放锁N次呢？</code>答案当然是必须的。当我们调用<code>ReenTrantLock</code>的unlock()方法来释放同步状态（也就是释放锁）时，内部会调用<code>sync.release(1);</code>。最终会调用<code>Sync</code>类的<code>tryRelease(int releases)</code>方法。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">          int c = getState() - releases;</span><br><span class="line">          if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">              throw new IllegalMonitorStateException();</span><br><span class="line">          boolean free = false;</span><br><span class="line">          if (c == 0) &#123;</span><br><span class="line">              free = true;</span><br><span class="line">              setExclusiveOwnerThread(null);</span><br><span class="line">          &#125;</span><br><span class="line">          setState(c);</span><br><span class="line">          return free;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中，我们可以知道，每调用一次<code>unlock()</code>方法会将当前同步状态减一。也就是说如果当前线程获取了锁N次，那么获取锁的相应线程也需要调用<code>unlock()</code>方法N次。这也是为什么我们在之前的重入锁例子中，为什么<code>methodB</code>方法中也要释放锁的原因。</p>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>在ReentrantLock中有着<code>非公平锁</code>与<code>公平锁</code>的概念，这里我先简单的介绍一下<code>公平</code>这两个字的含义。<strong>这里的公平是指线程获取锁的顺序。也就是说锁的获取顺序是按照当前线程请求的绝对时间顺序，当然前提条件下是该线程获取锁成功</strong>。</p>
<p>那么接下来，我们来分析在ReentrantLock中的非公平锁的具体实现。</p>
<blockquote>
<p>这里需要大家具备<code>AQS(AbstractQueuedSynchronizer)</code>类的相关知识。如果大家不熟悉这块的知识。建议大家阅读 <a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener"> Java并发编程之锁机制之AQS(AbstractQueuedSynchronizer)</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        if (compareAndSetState(0, 1))//直接获取同步状态成功，那么就不再走尝试获取锁的过程</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //省略部分代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>当在ReentrantLock在<code>非公平锁的模式下</code>，去调用lock（）方法。那么接下来最终会走<code>AQS(AbstractQueuedSynchronizer)</code>下的<code>acquire(int arg)（独占式的获取同步状态）</code>，也就是如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">      if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>那么结合之前我们所讲的AQS知识，在多个线程在<code>独占式</code>请求共享状态下（也就是请求锁）的情况下，在AQS中的同步队列中的线程节点情况如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-b899bb6db2704676.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aqs同步队列中线程节点的情况.png"></p>
<p>那么我们试想一种情况，当Nod1中的线程执行完相应任务后，释放锁后。这个时候本来该唤醒当前线程节点的<code>下一个节点</code>,也就是<code>Node2中的线程</code>。这个时候突然另一线程突然来获取线程（这里我们用节点<code>Node5</code>来表示）。具体情况如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-30ff585cc5da6453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="突然线程请求锁的情况.png"></p>
<p>那么根据AQS中独占式获取同步状态的逻辑。只要<code>Node5对应的线程获取同步状态成功</code>。那么就会出现下面的这种情况，具体情况如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-a071107319267a4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程抢占后最终的情况.png"></p>
<p>从上图中我们可以看出，由于Node5对象的线程抢占了获取同步状态(获取锁)的机会，本身应该被唤醒的<code>Node2</code>线程节点。因为获取同步状态失败。所以只有再次的陷入阻塞。那么综上。我们可以知道。<code>非公平锁获取同步状态（获取锁）时不会考虑同步队列中中等待的问题。会直接尝试获取锁。也就是会存在后申请，但是会先获得同步状态（获取锁）的情况。</code></p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>理解了非公平锁，再来理解公平锁就非常简单了。下面我们来看一下公平锁与非公平锁的加锁的源码：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-b6351764588542ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非公平锁与公平锁源码区别.png"><br>从源码我们可以看出，非公平锁与公平锁之间的代码唯一区别就是多了一个判断条件<code>!hasQueuedPredecessors()(图中红框所示)</code>。那我们查看其源码（该代码在AQS中，强烈建议阅读<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener"> Java并发编程之锁机制之AQS(AbstractQueuedSynchronizer)</a>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码理解理解起来非常简单，就是判断当前当前head节点的next节点是不是当前请求同步状态（请求锁）的线程。也就是语句<br><code>((s = h.next) == null || s.thread != Thread.currentThread()</code>。那么接下来结合AQS中的同步队列我们可以得到下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-28ccbe3b0cb6c3e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公平锁抢占情况.png"></p>
<p>那么综上我们可以得出，公平锁保证了线程请求的同步状态（请求锁）的顺序。不会出现另一个线程抢占的情况。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>该文章参考以下图书，站在巨人的肩膀上。可以看得更远。</p>
<ul>
<li>《Java并发编程的艺术》<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3></li>
<li><a href="https://www.jianshu.com/p/4ead70bdab56" target="_blank" rel="noopener">Java并发编程之锁机制之引导篇</a></li>
<li><a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">《Java并发编程之锁机制之AQS》</a></li>
<li><a href="https://www.jianshu.com/p/d0e84096d108" target="_blank" rel="noopener">《Java并发编程之锁机制之LockSupport工具》</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之锁机制之（ReentrantLock)重入锁/" data-id="cjsheb866000ddsr7fh435xo0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程之Java内存模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之Java内存模型/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-f454739c9b2e5225.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小手手.jpeg"></p>
<blockquote>
<p>该文章属于《Java并发编程》系列文章，如果想了解更多，请点击《Java并发编程之总目录》</p>
</blockquote>
<h3 id="一、并发的起源"><a href="#一、并发的起源" class="headerlink" title="一、并发的起源"></a>一、并发的起源</h3><p>为了提高计算机处理数据的速度。现代的计算机都支持多任务处理。在32位windows操作系统中 ,多任务处理是指系统可同时运行多个进程，而每个进程也可同时执行多个线程。一个线程是指程序的一条执行路径，它在系统指定的时间片中完成特定的功能。系统不停地在多个线程之间切换，由于时间很短，看上去多个线程在同时运行。或者对于在线程序可并行执行同时服务于多个用户称为多任务处理。</p>
<h3 id="二、物理计算机的内存模型"><a href="#二、物理计算机的内存模型" class="headerlink" title="二、物理计算机的内存模型"></a>二、物理计算机的内存模型</h3><p>在理解java内存模型之前，我们先来了解一下，物理计算机的内存模型，其对Java内存模型有着很大的参考意义。<br>在物理计算机中，我们需要处理的数据都在内存中，处理器处理数据，需要从内存中获取相应的数据，然后存入内存中，为了提高计算机的处理速度（<strong>读取数据，存储数据有IO消耗）</strong>，我们常常会在CPU(处理器)中加入<strong>高速缓存（Cache Memory）</strong>，也就是将数据缓存到处理器中，当处理器处理完数据后，再将处理的数据结果存储在内存中。具体如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-b514647393adbdb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cpu高速缓存.jpg"></p>
<p>当CPU（处理器）要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。一般来说，每级缓存的命中率大概都在80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取。</p>
<blockquote>
<p>高速缓存（Cache Memory）是位于CPU与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。高速缓存的出现主要是为了解决CPU运算速度与内存读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快很多，这样会使CPU花费很长时间等待数据到来或把数据写入内存。在缓存中的数据是内存中的一小部分，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先缓存中调用，从而加快读取速度。</p>
</blockquote>
<h4 id="2-1-物理计算机的数据缓存不一致的问题"><a href="#2-1-物理计算机的数据缓存不一致的问题" class="headerlink" title="2.1 物理计算机的数据缓存不一致的问题"></a>2.1 物理计算机的数据缓存不一致的问题</h4><p>虽然高速缓缓冲提高了CPU(处理器)处理数据的速度问题。在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。这时CPU缓存中的值可能和缓存中的值不一样，这就会出现缓存不一致的问题。为了解决该问题。物理机算计提供了两种方案来解决该问题。具体如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-9a62884464a447b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缓存一致性.png"></p>
<h5 id="2-1-1-通过总线加LOCK-锁的方式"><a href="#2-1-1-通过总线加LOCK-锁的方式" class="headerlink" title="2.1.1 通过总线加LOCK#锁的方式"></a>2.1.1 通过总线加LOCK#锁的方式</h5><blockquote>
<p>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束，在计算机中数据是通过总线，在处理器和内存之间传递。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-72874c2ff3245da1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="总线机制.png"><br>在早期的CPU当中，是通过在总线上加<strong>LOCK#锁</strong>的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从其内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<h5 id="2-1-2-通过缓存一致性协议"><a href="#2-1-2-通过缓存一致性协议" class="headerlink" title="2.1.2 通过缓存一致性协议"></a>2.1.2 通过缓存一致性协议</h5><p>但是由于在锁住总线期间，其他CPU无法访问内存，会导致效率低下。因此出现了第二种解决方案，通过缓存一致性协议来解决缓存一致性问题。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<h4 id="2-2-CPU-处理器-的乱序执行（out-of-orderexecution"><a href="#2-2-CPU-处理器-的乱序执行（out-of-orderexecution" class="headerlink" title="2.2 CPU(处理器)的乱序执行（out-of-orderexecution)"></a>2.2 CPU(处理器)的乱序执行（out-of-orderexecution)</h4><p>除了使用高速缓存来提高CPU(处理器)的数据处理速度，<strong>CPU(处理器)还采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术</strong>。在这期间不按规定顺序执行指令，然后由重新排列单元将各执行单元结果按指令顺序重新排列。采用乱序执行技术的目的是为了使CPU内部电路满负荷运转并相应提高了CPU的运行程序的速度。有可能大家不好理解。下面这个例子帮助大家理解。</p>
<p>假如请A、B、C三个名人为晚会题写横幅“春节联欢晚会”六个大字，每人各写两个字。如果这时在一张大纸上按顺序由A写好”春节”后再交给B写”联欢”，然后再由C写”晚会”，那么这样在A写的时候，B和C必须等待，而在B写的时候C仍然要等待而A已经没事了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-8eb1eb36c68dcabc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="顺序执行.png"></p>
<p>但如果采用三个人分别用三张纸同时写的做法， 那么B和C都不必须等待就可以同时各写各的了，甚至C和B还可以比A先写好也没关系（就象乱序执行），但当他们都写完后就必须重新在横幅上（自然可以由别人做，就象CPU中乱序执行后的重新排列单元）按”春节联欢晚会”的顺序排好才能挂出去。<br><img src="https://upload-images.jianshu.io/upload_images/2824145-df391c94225c1f42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="乱序执行.png"></p>
<h3 id="三、Java的内存模型"><a href="#三、Java的内存模型" class="headerlink" title="三、Java的内存模型"></a>三、Java的内存模型</h3><p>看到这里大家一定会发现，我们所讨论的CPU高速缓存、指令重排序等内容都是计算机体系结构方面的东西，并不是Java语言所特有的。事实上，很多主流程序语言(如C/C++)都存在缓存不一致的问题，这些语言是借助物理硬件和操作系统的内存模型来处理缓存不一致问题的，因此不同平台上内存模型的差异，会影响到程序的执行结果。Java虚拟机规范定义了自己的内存模型JMM(Java Memory Model)来<strong>屏蔽掉不同硬件和操作系统的内存模型差异</strong>，以实现让Java程序在各种平台下都能达到一致的内存访问结果。所以对于Java程序员，无需了解底层硬件和操作系统内存模型的知识，只要关注Java自己的内存模型，就能够解决这些问题啦。</p>
<p>Java内存模型如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-0ec568ea5b771095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java内存模型.png"></p>
<ul>
<li>主内存：主要存储变量（包括。实例字段，静态字段和构成对象的元素）</li>
<li>工作内存：每个线程都有自己的工作内存，存储了对应的引用，方法参数。</li>
</ul>
<p>如果对应与Java内存中堆与栈的概念的话，<strong>主内存对应Java内存中的堆，工作内存对应Java虚拟机的栈。</strong></p>
<h4 id="3-1-内存之间交互"><a href="#3-1-内存之间交互" class="headerlink" title="3.1 内存之间交互"></a>3.1 内存之间交互</h4><p>主内存与工作内存之间的内存交互，也就是从线程的私有内存数据同步到主内存中，从主内存的读取数据到线程的私有内存中。Java内存模型定义了8种操作来完成。虚拟机在实现时保证下面提到的每一种操作都是<strong>原子的，不可再分的</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-c71aa78c0a3ca6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8种操作.png"></p>
<ul>
<li>lock：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li>unlock：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程访问。</li>
<li>read：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，一遍随后的load动作使用。</li>
<li>load：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存变量副本中。</li>
<li>use：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时会执行这个操作。</li>
<li>assign：作用于工作内存的变量，它把一个从执行引擎收到的值赋给工作内存的变量。每当虚拟机遇到给变量赋值的字节码指令时会执行这个操作。</li>
<li>store：作用于工作内存的变量，它把工作内存中一个变量值传送到主内存中。以便随后的write操作。</li>
<li>write：作用于主内存的变量，它把store操作从工作内存中得到的变量的值，放入主内存的变量中。</li>
</ul>
<h4 id="3-2-八种原子操作规则"><a href="#3-2-八种原子操作规则" class="headerlink" title="3.2 八种原子操作规则"></a>3.2 八种原子操作规则</h4><p>既然Java内存模型规定了内存之间交互的一些操作。那么我们来看看，它到底拥有哪些规则呢。</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现。即不允许一个变量从主内存读取了但工作内存不接受。或者从工作内存发起回写了但主内存不接受的情况</li>
<li>不允许一个线程丢弃它的最近的assign操作。即变量在工作内存改变了后必须把该变化同步到主内存中。</li>
<li>不允许没有发生任何的assign操作就把数据同步到主内存中。</li>
<li>一个新的变量只能在主内存中诞生，工作内存要使用或者赋值。必须要经过load或assign操作。</li>
<li>一个变量在同一时刻只允许一条线程进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量进行lock操作后，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作。也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unLock操作之前，必须要把次变量同步到主内存中（执行store,write操作）。</li>
</ul>
<p>上述规则规定了Java内存之间交互的流程。保证了数据<strong>在单线程情形下</strong>传输过程中的准确性与数据一致性。</p>
<h3 id="四、重排序"><a href="#四、重排序" class="headerlink" title="四、重排序"></a>四、重排序</h3><p>前面提到过，CPU(处理器)为了提高处理数据的速度，会进行乱序执行（out-of-orderexecution)。也就是<strong>重排序</strong>。但是CPU不会对任务操作进行重排序，编译器与处理器只会对<strong>没有数据依赖性</strong>的指令进行重排序。这里提到了一个关键词<strong>数据依赖性</strong>。什么是数据依赖呢？</p>
<h4 id="4-1-数据依赖"><a href="#4-1-数据依赖" class="headerlink" title="4.1 数据依赖"></a>4.1 数据依赖</h4><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。如下图所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">代码示例</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">写后读</td>
<td style="text-align:center">a=1;b=a</td>
<td style="text-align:center">写一个变量之后，再读这个位置</td>
</tr>
<tr>
<td style="text-align:center">写后写</td>
<td style="text-align:center">a=1;a=2</td>
<td style="text-align:center">写一个变量之后，再写这个位置</td>
</tr>
<tr>
<td style="text-align:center">读后写</td>
<td style="text-align:center">a=b;b=1</td>
<td style="text-align:center">读一个变量之后，再写这个位置</td>
</tr>
</tbody>
</table>
<p>上述三种情况，a与b存在着<strong>“数据依赖性”</strong>，同时大家也要注意。<strong>这里所说的数据依赖性是指单个处理器执行的指令序列和单个线程中执行的操作。多处理器和不同线程之间是没有数据依赖性这种关系的。</strong></p>
<h4 id="4-2-重排序规则（as-if-serial）"><a href="#4-2-重排序规则（as-if-serial）" class="headerlink" title="4.2 重排序规则（as-if-serial）"></a>4.2 重排序规则（as-if-serial）</h4><p>既然我们已经知道了CPU在处理数据时候会出现重排序。那重排序的规则是什么呢？重排序规则：不管怎么重排序（编译器和处理器为了提高并行度）<strong>，单线程（程序）执行结果不能被改变</strong>。编译器、runtime和处理器都必须遵守。那么我们三角形面积示例代码说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double a = 3;//底</span><br><span class="line">double h = 10;//高</span><br><span class="line">double s = a*h/2//面积</span><br></pre></td></tr></table></figure>
<p>其中上述代码的依赖关系如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-eba31d1af67b4abc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依赖关系.png"><br>如上图所示：a与s存在数据依赖关系，同时h与s也存在依赖关系。因此在程序的最终指令执行时。s是不能排在a与h之前。因为a与h不存在着数据依赖关系。所以处理器可以对a与h之前的执行顺序重排序。<br><img src="https://upload-images.jianshu.io/upload_images/2824145-cf8122328352c65d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重排序前后对比.png"><br>经过处理器的重排序后，执行的结果并没有发生改变。</p>
<h4 id="五、Java内存模型的需要解决的问题"><a href="#五、Java内存模型的需要解决的问题" class="headerlink" title="五、Java内存模型的需要解决的问题"></a>五、Java内存模型的需要解决的问题</h4><p>前面我们已经了解了Java内存模型的大致结构与操作方式，那么我们来看看Java内存模型需要解决的问题。</p>
<h4 id="5-1-工作内存的可见性问题"><a href="#5-1-工作内存的可见性问题" class="headerlink" title="5.1 工作内存的可见性问题"></a>5.1 工作内存的可见性问题</h4><p>工作内存的可见性问题（这里和计算机硬件的缓存不一致是一样的道理）。从上文的Java内存模型分析。我们已经知道了当多个线程操作同一个共享变量时，如果一个线程修改了其中的变量的值（如果通过Java内存模型的原子操作来表达，一个线程多次use与assign 操作，而另一个线程经过read、load之后，另一线程任然保持着之前从主内存中获取的值），另一个线程怎么感知呢？</p>
<h4 id="5-2-重排序带来的问题"><a href="#5-2-重排序带来的问题" class="headerlink" title="5.2 重排序带来的问题"></a>5.2 重排序带来的问题</h4><p>CPU(处理器)的重排序会对多线程带来问题。具体问题我们用下列伪代码来阐述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    private int a = 0;</span><br><span class="line">    private boolean isInit = false;</span><br><span class="line">    private Config config;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        config = readConfig();//1</span><br><span class="line">        isInit = true;//2</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        if (isInit) &#123;//3</span><br><span class="line">            doSomethingWithconfig();//4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>isInit用来标志是否已经初始化配置。其中1，2操作是没有数据依赖性，同理3、4操作也是没有数据依赖性的。那么CPU(处理器)可能对1、2操作进行重排序。对3、4操作进行重排序。现在我们加入线程A操作Init()方法，线程B操作doSomething()方法，那么我们看看重排序对多线程情况下的影响。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-a8134e7dee718eea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="程序执行顺序.png"></p>
<p>上图中2操作排在了1操作前面。当CPU时间片转到线程B。线程B判断 if (isInit)为true,接下来接着执行 doSomethingWithconfig(),但是我们Config还没有初始化。所以在多线程的情况下。重排序会影响程序的执行结果。</p>
<h3 id="六、Happens-Before-原则"><a href="#六、Happens-Before-原则" class="headerlink" title="六、Happens-Before 原则"></a>六、Happens-Before 原则</h3><p>上面我们讨论了Java内存模型需要解决的问题，那Java有不有一个良好的解决办法来处理以上出现的情况呢？答案是当然的。为了方便程序员开发，将底层的烦琐细节屏蔽掉，JMM定义了Happens-Before原则。只要我们理解了Happens-Before原则，无需了解Java内存模型的内存操作，就可以解决这些问题（避免工作内存的不可见与重排序带来的问题）。</p>
<p>Happens-Before原则是一组偏序关系：对于两个操作A和B，这两个操作可以在不同的线程中执行。如果A Happens-Before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是可见的。那么有哪些满足Happens-Before原则的呢？下面是Java内存模型规定的一些规则。</p>
<h4 id="6-1-程序次序规则"><a href="#6-1-程序次序规则" class="headerlink" title="6.1 程序次序规则"></a>6.1 程序次序规则</h4><p>在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。这是因为Java语言规范要求Java内存模型在单个线程内部要维护类似严格串行的语义，如果多个操作之间有先后依赖关系，则不允许对这些操作进行重排序。</p>
<h4 id="6-2-锁定规则"><a href="#6-2-锁定规则" class="headerlink" title="6.2 锁定规则"></a>6.2 锁定规则</h4><p>对一个unlock操作先行发生于后面对同一个锁的lock操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    private int value;</span><br><span class="line">    public synchronized void setValue(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，setValue与getValue拥有同一个锁（也就是当前实例对象），假设setValue方法在线程A中执行，getValue方法在线程B中执行。线程A调用setValue方法会先对value变量赋值，然后释放锁。线程B调用getValue方法会先获取到同一个锁后，再读取value的值。那么B线程获取的value的值一定是正确的。</p>
<h4 id="6-3-volatlie变量规则"><a href="#6-3-volatlie变量规则" class="headerlink" title="6.3 volatlie变量规则"></a>6.3 volatlie变量规则</h4><p>对一个volatile变量的写操作先行发生于后面这个变量的读操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    private volatile boolean flag;</span><br><span class="line">    public void setFlag(boolean flag) &#123;</span><br><span class="line">        this.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isFlag() &#123;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，假设setFlag方法在线程A中执行，isFlag方法在线程B中执行。线程A调用setFlag方法会先对value变量赋值，然后释放锁。线程B调用isFlag方法再读取value的值。那么B线程获取的flag的值一定是正确的。这里我们先不对volatlie进行讲解，后面系列文章会描述。</p>
<h4 id="6-4-线程启动规则"><a href="#6-4-线程启动规则" class="headerlink" title="6.4 线程启动规则"></a>6.4 线程启动规则</h4><p>Thread对象的start()方法先行发生于此线程的每个动作。</p>
<p>start方法和新线程中的动作一定是在两个不同的线程中执行。线程启动规则可以这样去理解：调用start方法时，会将start方法之前所有操作的结果同步到主内存中，新线程创建好后，需要从主内存获取数据。这样在start方法调用之前的所有操作结果对于新创建的线程都是可见的。</p>
<h4 id="6-5-线程终止规则"><a href="#6-5-线程终止规则" class="headerlink" title="6.5 线程终止规则"></a>6.5 线程终止规则</h4><p>线程中的所有操作都先行发生于对此线程的终止检测。</p>
<p>这里理解比较抽象。举个例子，假设两个线程s、t。在线程s中调用<strong>t.join()方法</strong>。则线程s会被挂起，等待t线程运行结束才能恢复执行。当t.join()成功返回时，s线程就知道t线程已经结束了。在t线程中对共享变量的修改，对s线程都是可见的。类似的还有Thread.isAlive方法也可以检测到一个线程是否结束。也就是说当一个线程结束时，会把自己所有操作的结果都同步到主内存。而任何其它线程当发现这个线程已经执行结束了，就会从主内存中重新刷新最新的变量值。所以结束的线程A对共享变量的修改，对于其它检测了A线程是否结束的线程是可见的。</p>
<h4 id="6-6-线程中断规则"><a href="#6-6-线程中断规则" class="headerlink" title="6.6 线程中断规则"></a>6.6 线程中断规则</h4><p>对线程interrupt()方法的调用先与被中断线程的代码检查到中断事件的发生。</p>
<p>假设两个线程A和B，A先做了一些操作operationA，然后调用B线程的interrupt方法。当B线程感知到自己的中断标识被设置时(通过抛出InterruptedException，或调用interrupted和isInterrupted),operationA中的操作结果对B都是可见的。</p>
<h4 id="6-7-对象终结规则"><a href="#6-7-对象终结规则" class="headerlink" title="6.7 对象终结规则"></a>6.7 对象终结规则</h4><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。</p>
<p>####6.8 传递性规则<br>如果操作A先行与发生于操作B,操作B先行发生于操作C，那么就可以得出A先行发生于操作C的结论。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>在物理计算机中CPU为了提高处理速度，添加了高速缓存与CPU乱序执行</li>
<li>Java定义了自身的内存模型是为了屏蔽掉不同硬件和操作系统的内存模型差异</li>
<li>Java为了处理内存的不可见性与重排序的问题，定义了Happens-Before 原则</li>
<li>Happens-Before 原则的理解：对于两个操作A和B，这两个操作可以在不同的线程中执行。如果A Happens-Before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是可见的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之Java内存模型/" data-id="cjsheb86t000ndsr7od1462y6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程之锁机制之Condition接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之锁机制之Condition接口/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-64a13d0c3114cdcb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="book.jpg"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前面的文章中，我曾提到过，整个Lock接口下实现的锁机制中<code>AQS(AbstractQueuedSynchronizer，下文都称之为AQS)</code>与<code>Condition</code>才是真正的实现者。也就说<code>Condition</code>在整个同步组件的基础框架中也起着非常重要的作用，既然它如此重要与犀利，那么现在我们就一起去了解其内部的实际原理与具体逻辑。</p>
<blockquote>
<p>在阅读该文章之前，我由衷的建议先阅读<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">《Java并发编程之锁机制之AQS》</a>与<a href="https://www.jianshu.com/p/d0e84096d108" target="_blank" rel="noopener">《Java并发编程之锁机制之LockSupport工具》</a>这两篇文章。因为整个Condtion的内部机制与逻辑都离不开以上两篇文章提到的知识点。</p>
</blockquote>
<h3 id="Condition接口方法介绍"><a href="#Condition接口方法介绍" class="headerlink" title="Condition接口方法介绍"></a>Condition接口方法介绍</h3><p>在正式介绍Condtion之前，我们可以先了解其中声明的方法。具体方法声明，如下表所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-3de65963e92886ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="condition方法.png"></p>
<p>从该表中，我们可以看出其内部定义了<code>等待（以await开头系列方法）</code>与<code>通知（以singal开头的系列方法)</code>两种类型的方法，类似于Object对象的<code>wait()</code>与<code>notify()/NotifyAll()</code>方法来对线程的阻塞与唤醒。</p>
<p>###ConditionObject介绍<br>在实际使用中，Condition接口实现类是<code>AQS</code>中的内部类<code>ConditionObject</code>。在其内部维护了一个<code>FIFO(first in first out)</code>的队列（这里我们称之为<code>等待队列</code>，你也可以叫做阻塞队列，看每个人的理解），通过与<code>AQS中的同步队列</code>配合使用，来控制获取共享资源的线程。</p>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>等待队列是<code>ConditionObjec</code>中内部的一个<code>FIFO(first in first out)</code>的队列，在队列中的每个节点都包含了一个线程引用，且该线程就是在ConditionObject对象上阻塞的线程。需要注意的是，在等待队列中的节点是复用了<code>AQS</code>中<code>Node类</code>的定义。换句话说，在<code>AQS</code>中维护的同步队列与<code>ConditionObjec</code>中维护的等待队列中的节点类型都是<code>AQS.Node</code>类型。（关于<code>AbstractQueuedSynchronizer.Node</code>类的介绍，大家可以参看<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">《Java并发编程之锁机制之AQS》</a>文章中的描述）。</p>
<p>在ConditionObject类中也分别定义了<code>firstWaiter</code>与<code>lastWaiter</code>两个指针，分别指向等待队列中头部与尾部。当实际线程调用其以<code>await开头</code>的系列方法后。会将该线程构造为Node节点。添加等待队列中的尾部。关于等待队列的基本结构如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-c2dbcb9a5df26c1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="condition内部结构.png"></p>
<p>对于等待队列中节点添加的方式也很简单，将<code>上一尾节点的nextWaiter指向新添加的节点</code>，同时使<code>lastWaiter</code>指向新添加的节点。</p>
<h4 id="同步队列与等待队列的对应关系"><a href="#同步队列与等待队列的对应关系" class="headerlink" title="同步队列与等待队列的对应关系"></a>同步队列与等待队列的对应关系</h4><p>上文提到了整个Lock锁机制需要<code>AQS中的同步队列</code>与<code>ConditionObject的等待队列</code>配合使用，其对应关系如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-306028fc076c6709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同步队列与等待队列的关系.png"></p>
<p>在Lock锁机制下，可以<code>拥有一个同步队列和多个等待队列</code>，与我们传统的Object监视器模型上，一个对象拥有一个同步队列和等待队列不同。lock中的锁可以伴有多个条件。</p>
<h4 id="Condition的基本使用"><a href="#Condition的基本使用" class="headerlink" title="Condition的基本使用"></a>Condition的基本使用</h4><p>为了大家能够更好的理解同步队列与等待队列的关系。下面通过一个有界队列<code>BoundedBuffer</code>来了解Condition的使用方式，该类是一个特殊的队列，当队列为空时，队列的获取操作将会阻塞当前”拿”线程，直到队列中有新增的元素，当队列已满时，队列的放入操作将会阻塞”放入”线程，直到队列中出现空位。具体代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer &#123;</span><br><span class="line"></span><br><span class="line">    final Lock lock = new ReentrantLock();</span><br><span class="line">    final Condition notFull = lock.newCondition();</span><br><span class="line">    final Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    final Object[] items = new Object[100];</span><br><span class="line">    </span><br><span class="line">    //依次为，放入的角标、拿的角标、数组中放入的对象总数</span><br><span class="line">    int putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加一个元素</span><br><span class="line">     * （1）如果当前数组已满，则把当前&quot;放入&quot;线程，加入到&quot;放入&quot;等待队列中，并阻塞当前线程</span><br><span class="line">     * （2）如果当前数组未满，则将x元素放入数组中，唤醒&quot;拿&quot;线程中的等待线程。</span><br><span class="line">     */</span><br><span class="line">    public void put(Object x) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)//如果已满，则阻塞当前&quot;放入&quot;线程</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            if (++putptr == items.length) putptr = 0;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();//唤醒&quot;拿&quot;线程</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 拿一个元素</span><br><span class="line">     * （1）如果当前数组已空，则把当前&quot;拿&quot;线程，加入到&quot;拿&quot;等待队列中，并阻塞当前线程</span><br><span class="line">     * （2）如果当前数组不为空，则把唤醒&quot;放入&quot;等待队列中的线程。</span><br><span class="line">     */</span><br><span class="line">    public Object take() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)//如果为空，则阻塞当前&quot;拿&quot;线程</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            if (++takeptr == items.length) takeptr = 0;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();//唤醒&quot;放入&quot;线程</span><br><span class="line">            return x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中我们可以看出，在该类中我们创建了两个等待队列<code>notFull</code>与<code>notEmpty</code>。这两个等待队列的作用分别是，当请数组已满时，<code>notFull</code>用于存储阻塞的”放入”线程，<code>notEmpty</code>用于存储阻塞的”拿”线程。需要注意的是<code>获取一个Condition必须通过Lock的newCondition()方法</code>。关于<code>ReentrantLock</code>，在后续的文章中，我们会进行介绍。</p>
<h3 id="阻塞实现-await"><a href="#阻塞实现-await" class="headerlink" title="阻塞实现 await()"></a>阻塞实现 await()</h3><p>在了解了ConditionObject的内部基本结构和与AQS中内部的同步队列的对应关系后，现在我们来看看其阻塞实现。调用ConditionObject的<code>await()</code>方法（或者以<code>await开头</code>的方法），会使当前线程进入等待队列，并释放同步状态，需要注意的是当该方法返回时，当前线程一定获取了同步状态（具体原因是当通过<code>signal()等系列方法</code>，线程才会从<code>await（）</code>方法返回，而唤醒该线程后会加入同步队列）。这里我们以<code>awati()</code>方法为例，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">	//如果当前线程已经中断，直接抛出异常  </span><br><span class="line">          if (Thread.interrupted())</span><br><span class="line">              throw new InterruptedException();</span><br><span class="line">          //(1)将当前线程加入等待队列</span><br><span class="line">          Node node = addConditionWaiter();</span><br><span class="line">          //(2)释放同步状态（也就是释放锁），同时将线程节点从同步队列中移除，并唤醒同步队列中的下一节点</span><br><span class="line">          int savedState = fullyRelease(node);</span><br><span class="line">          int interruptMode = 0;</span><br><span class="line">          //(3)判断当前线程节点是否还在同步队列中，如果不在则阻塞线程</span><br><span class="line">          while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">              LockSupport.park(this);</span><br><span class="line">              if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">                  break;</span><br><span class="line">          &#125;</span><br><span class="line">          //(4)当线程被唤醒后，重新在同步队列中与其他线程竞争获取同步状态</span><br><span class="line">          if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">              interruptMode = REINTERRUPT;</span><br><span class="line">          if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">              unlinkCancelledWaiters();</span><br><span class="line">          if (interruptMode != 0)</span><br><span class="line">              reportInterruptAfterWait(interruptMode);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码整体来看，整个方法分为以下四个步骤：</p>
<ul>
<li>（1）通过 <code>addConditionWaiter()</code>方法将线程节点加入到等待队列中。</li>
<li>（2）通过<code>fullyRelease(Node node)</code>方法释放同步状态（也就是释放锁），同时将线程节点从<code>同步队列</code>中移除，并唤醒<code>同步队列中的下一节点</code>。</li>
<li>（3）通过<code>isOnSyncQueue(Node node)</code>方法判断当前线程节点是否在<code>同步队列</code>中，如果不在，则通过<code>LockSupport.park(this);</code>阻塞当前线程。</li>
<li>（4）当线程被唤醒后，调用<code>acquireQueued(node, savedState)</code>方法，重新在同步队列中与其他线程竞争获取同步状态</li>
</ul>
<p>因为每个步骤涉及到的逻辑都稍微有一点复杂，这里为了方便大家理解，分别对以上四个步骤涉及到的方法分别进行介绍。</p>
<h4 id="addConditionWaiter-方法"><a href="#addConditionWaiter-方法" class="headerlink" title="addConditionWaiter()方法"></a>addConditionWaiter()方法</h4><p>该方法主要将同步队列中的需要阻塞的线程节点加入到等待队列中，关于<code>addConditionWaiter()</code>方法具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> private Node addConditionWaiter() &#123;</span><br><span class="line">         Node t = lastWaiter;</span><br><span class="line">         // (1)如果当前尾节点中中对应的线程已经中断，</span><br><span class="line">         //则移除等待队列中所有的已经中断或已经释放同步状态的线程节点</span><br><span class="line">         if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">             unlinkCancelledWaiters();</span><br><span class="line">             t = lastWaiter;</span><br><span class="line">         &#125;</span><br><span class="line">   //(2)构建等待队列中的节点</span><br><span class="line">         Node node = new Node(Node.CONDITION);</span><br><span class="line"></span><br><span class="line">//(3)将该线程节点添加到队列中，同时构建firstWaiter与lastWaiter的指向</span><br><span class="line">         if (t == null)</span><br><span class="line">             firstWaiter = node;</span><br><span class="line">         else</span><br><span class="line">             t.nextWaiter = node;</span><br><span class="line">         lastWaiter = node;</span><br><span class="line">         return node;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的逻辑也比较简单，分为以下三个步骤：</p>
<ul>
<li>（1）获取等待队列中的尾节点，如果当前尾节点已经中断，那么则通过<code>unlinkCancelledWaiters()</code>方法移除等待队列中所有的<code>已经中断</code>或<code>已经释放同步状态（也就是释放锁）</code>的线程节点</li>
<li>（2）构建等待队列中的节点，注意，是通过<code>New</code>的形式，那么就说明与同步队列中的线程节点不是同一个。（对Node状态枚举不清楚的小伙伴，可以参看<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">Java并发编程之锁机制之AQS</a>文章下的Node状态枚举介绍）。</li>
<li>（3）将该线程节点添加到等待队列中去，同时构建firstWaiter与lastWaiter的指向，可以看出等待队列总是以<code>FIFO(first in first out )</code>的形式添加线程节点。</li>
</ul>
<h5 id="unlinkCancelledWaiters-方法"><a href="#unlinkCancelledWaiters-方法" class="headerlink" title="unlinkCancelledWaiters()方法"></a>unlinkCancelledWaiters()方法</h5><p>因为在<code>addConditionWaiter()</code>方法的步骤（1）中，调用了<code>unlinkCancelledWaiters</code>移除了所有的<code>已经中断</code>的线程节点，那我们看一个该方法的实现。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void unlinkCancelledWaiters() &#123;</span><br><span class="line">	//获取等待队列中的头节点</span><br><span class="line">          Node t = firstWaiter;</span><br><span class="line">          Node trail = null;</span><br><span class="line">          //遍历等待队列，将已经中断的线程节点从等待队列中移除。</span><br><span class="line">          while (t != null) &#123;</span><br><span class="line">              Node next = t.nextWaiter;</span><br><span class="line">              if (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                  t.nextWaiter = null;</span><br><span class="line">                  if (trail == null)</span><br><span class="line">                      firstWaiter = next;</span><br><span class="line">                  else</span><br><span class="line">                      trail.nextWaiter = next;</span><br><span class="line">                  if (next == null)//重新定义lastWaiter的指向</span><br><span class="line">                      lastWaiter = trail;</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">                  trail = t;</span><br><span class="line">              t = next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法具体流程如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-fd08ef7d8f05fbe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="condition.png"></p>
<h4 id="fullyRelease-Node-node"><a href="#fullyRelease-Node-node" class="headerlink" title="fullyRelease(Node node)"></a>fullyRelease(Node node)</h4><p>在将阻塞线程将入到等待队列后，会将该线程节点从同步队列中移除，释放同步状态（也就是释放锁），并唤醒同步队列中的下一节点。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final int fullyRelease(Node node) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          int savedState = getState();</span><br><span class="line">          if (release(savedState))</span><br><span class="line">              return savedState;</span><br><span class="line">          throw new IllegalMonitorStateException();</span><br><span class="line">      &#125; catch (Throwable t) &#123;</span><br><span class="line">          node.waitStatus = Node.CANCELLED;</span><br><span class="line">          throw t;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p> <code>release(int arg)</code>方法会释放当前线程的同步状态， 并唤醒<code>同步队列中</code>的下一线程节点，使其尝试获取同步状态，因为该方法已经在<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">Java并发编程之锁机制之AQS</a>文章下的<code>unparkSuccessorNode node)</code>方法的下分析过了，所以这里就不再进行分析了。希望大家参考上面提到的文章进行理解。</p>
<h4 id="isOnSyncQueue-Node-node"><a href="#isOnSyncQueue-Node-node" class="headerlink" title="isOnSyncQueue(Node node)"></a>isOnSyncQueue(Node node)</h4><p>该方法主要用于判断当前线程节点是否在同步队列中。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final boolean isOnSyncQueue(Node node) &#123;</span><br><span class="line">      //判断当前节点 waitStatus ==Node.CONDITION或者当前节点上一节点为空,则不在同步队列中</span><br><span class="line">      if (node.waitStatus == Node.CONDITION || node.prev == null)</span><br><span class="line">          return false;</span><br><span class="line">      //如果当前节点拥有下一个节点，则在同步队列中。</span><br><span class="line">      if (node.next != null) // If has successor, it must be on queue</span><br><span class="line">          return true;</span><br><span class="line">   //如果以上条件都不满足，则遍历同步队列。检查是否在同步队列中。</span><br><span class="line">      return findNodeFromTail(node);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你还记得AQS中的同步队列，那么你应该知道同步队列中的Node节点才会使用其内部的<code>pre</code>与<code>next</code>字段，那么在同步队列中因为只使用了<code>nextWaiter</code>字段，所以我们就能很简单的通过这两个字段是否为<code>==null</code>，来判断是否在同步队列中。当然也有可能有一种特殊情况。有可能需要阻塞的线程节点还没有加入到同步队列中，那么这个时候我们需要遍历同步队列来判断是否在该线程节点是否在线程中。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private boolean findNodeFromTail(Node node) &#123;</span><br><span class="line">       for (Node p = tail;;) &#123;</span><br><span class="line">           if (p == node)</span><br><span class="line">               return true;</span><br><span class="line">           if (p == null)</span><br><span class="line">               return false;</span><br><span class="line">           p = p.prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里之所以使用同步队列<code>tail（尾节点）</code>来遍历，如果<code>node.netx!=null</code>，那么就说明当前线程已经在同步队列中。那么我们需要处理的情况肯定是针对<code>node.next==null</code>的情况。所以需要从尾节点开始遍历。</p>
<h4 id="acquireQueued-final-Node-node-int-arg"><a href="#acquireQueued-final-Node-node-int-arg" class="headerlink" title="acquireQueued(final Node node, int arg)"></a>acquireQueued(final Node node, int arg)</h4><p>当线程被唤醒后（具体原因是当通过<code>signal()等系列方法</code>，线程才会从<code>await（）</code>方法返回）会调用该方法将该线程节点加入到同步队列中。该方法我在<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">《Java并发编程之锁机制之AQS》</a>中具体描述过了。这里就不在进行过多的解析。</p>
<h4 id="阻塞流程"><a href="#阻塞流程" class="headerlink" title="阻塞流程"></a>阻塞流程</h4><p>在理解了整个阻塞的流程后，现在我们来归纳总结一下，整个阻塞的流程。具体流程如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-fbdd2f637ac198f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="阻塞流程.png"></p>
<ul>
<li>（1）将该线程节点从同步队列中移除，并释放其同步状态。</li>
<li>（2）构造新的阻塞节点，加入到等待队列中。</li>
</ul>
<h3 id="唤醒实现-signal"><a href="#唤醒实现-signal" class="headerlink" title="唤醒实现 signal()"></a>唤醒实现 signal()</h3><p>当需要唤醒线程时，会调用ConditionObject中的<code>singal开头的系列方法</code>，该系列方法会唤醒等待队列中的<code>首个</code>线程节点，在唤醒该节点之前，会先讲该节点移动到<code>同步队列</code>中。这里我们以<code>singal()</code>方法为例进行讲解，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    //（1）判断当前线程是否获取到了同步状态（也就是锁）</span><br><span class="line">          if (!isHeldExclusively())</span><br><span class="line">              throw new IllegalMonitorStateException();</span><br><span class="line">          Node first = firstWaiter;</span><br><span class="line">          //（2）获取等待队列中的首节点，然后将其移动到同步队列，然后再唤醒该线程节点</span><br><span class="line">          if (first != null)</span><br><span class="line">              doSignal(first);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法主要逻辑分为以下两个步骤：</p>
<ul>
<li>（1）通过<code>isHeldExclusively()</code>方法，判断当前线程是否获取到了同步状态（也就是锁）。</li>
<li>（2）通过<code>doSignal(Node first)</code>方法，获取等待队列中的首节点，然后将其移动到同步队列，然后再唤醒该线程节点。</li>
</ul>
<p>下面我们会分别对上面涉及到的两个方法进行描述。</p>
<h4 id="isHeldExclusively-方法"><a href="#isHeldExclusively-方法" class="headerlink" title="isHeldExclusively()方法"></a>isHeldExclusively()方法</h4><p><code>isHeldExclusively()</code>方法是AQS中的方法，默认交给其子类实现，主要用于判断当前调用<code>singal()</code>方法的线程，是否在同步队列中，且已经获取了同步状态。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean isHeldExclusively() &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="doSignal-Node-first-方法"><a href="#doSignal-Node-first-方法" class="headerlink" title="doSignal(Node first)方法"></a>doSignal(Node first)方法</h4><p>那我们继续跟踪<code>doSignal(Node first)</code>方法，具体方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">       do &#123;</span><br><span class="line">           //（1）将等待队列中的首节点从等待队列中移除，并重新制定firstWaiter的指向</span><br><span class="line">           if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">               lastWaiter = null;</span><br><span class="line">           first.nextWaiter = null;</span><br><span class="line">       &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">       //（2）将等待队列中的首节点，加入同步队列中，并重新唤醒该节点</span><br><span class="line">                (first = firstWaiter) != null);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该方法也很简单，分为两个步骤：</p>
<ul>
<li>（1）将等待队列中的首节点从等待队列中移除，并设置firstWaiter的指向为首节点的下一个节点。 为了方便大家理解该步骤所描述的逻辑，这里画了具体的图，具体情况如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-416aebe1f25d17f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="移除首节点.png"></li>
<li>（2）通过 <code>transferForSignal(Node node)</code>方法，将等待队列中的首节点，加入到同步队列中去，然后重新唤醒该线程节点。</li>
</ul>
<h5 id="transferForSignal-Node-node-方法"><a href="#transferForSignal-Node-node-方法" class="headerlink" title="transferForSignal(Node node)方法"></a>transferForSignal(Node node)方法</h5><p>因为步骤（2）中<code>transferForSignal(Node node)</code>方法较为复杂，所以会对该方法进行详细的讲解。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">   </span><br><span class="line">    //（1）将该线程节点的状态设置为初始状态，如果失败则表示当前线程已经中断了</span><br><span class="line">    if (!node.compareAndSetWaitStatus(Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line">    //（2）将该节点放入同步队列中，</span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    int ws = p.waitStatus;</span><br><span class="line">    //（3）获取当前节点的状态并判断，尝试将该线程节点状态设置为Singal，如果失败则唤醒线程</span><br><span class="line">    if (ws &gt; 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法分为三个步骤：</p>
<ul>
<li>（1）将该线程节点的状态设置为初始状态，如果失败则表示当前线程已经中断了，直接返回。</li>
<li>（2）通过<code>enq(Node node)</code>方法，将该线程节点放入<code>同步队列</code>中。</li>
<li>（3）当将该线程节点放入同步队列后，获取当前节点的状态并判断，如果该节点的<code>waitStatus&gt;0</code>或者通过<code>compareAndSetWaitStatus(ws, Node.SIGNAL)</code>将该节点的状态设置为Singal，如果失败则通过<code>LockSupport.unpark(node.thread)</code>唤醒线程。</li>
</ul>
<p>上述步骤中，着重讲<code>enq(Node node)</code>方法，关于<code>LockSupport.unPark(Thread thread)</code>方法的理解，大家可以阅读<a href="https://www.jianshu.com/p/d0e84096d108" target="_blank" rel="noopener">《Java并发编程之锁机制之LockSupport工具》</a>。下面我们就来分析<code>enq(Node node)</code>方法。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(Node node) &#123;</span><br><span class="line">     for (;;) &#123;</span><br><span class="line">         //(1)获取同步队列的尾节点</span><br><span class="line">         Node oldTail = tail;</span><br><span class="line">         //(2)如果尾节点不为空，则将该线程节点加入到同步队列中</span><br><span class="line">         if (oldTail != null) &#123;</span><br><span class="line">          //将当前节点的prev指向尾节点</span><br><span class="line">             U.putObject(node, Node.PREV, oldTail);</span><br><span class="line">             //将同步队列中的tail指针，指向当前节点</span><br><span class="line">             if (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">                 oldTail.next = node;</span><br><span class="line">                 return oldTail;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">          //(3)如果当前同步队列为空，则构造同步队列</span><br><span class="line">             initializeSyncQueue();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>观察该方法，我们发现该方法通过<code>死循环(当然你也可以叫做自旋)</code>的方式来添加该节点到同步队列中去。该方法分为以下步骤：</p>
<ul>
<li>（1）获取同步队列的尾节点</li>
<li>（2）如果尾节点不为空，则将该线程节点加入到同步队列中</li>
<li>（3）如果当前同步队列为空，则通过<code>initializeSyncQueue();</code>构造同步队列。</li>
</ul>
<p>这里对<code>Node enq(Node node)</code>中的步骤（2）补充一个知识点。我们来看一下调用<code>U.putObject(node, Node.PREV, oldTail);</code>语句，内部是如何将当前的节点的prev指向尾节点的。在<code>AQS（AbstractQueuedSynchronizer）</code>中的Node类中有如下静态变量和语句。这里我省略了一下不重要的代码。具体代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">//省略部分代码</span><br><span class="line">static final long PREV;</span><br><span class="line">    static &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">		    //省略部分代码</span><br><span class="line">            PREV = U.objectFieldOffset</span><br><span class="line">               (Node.class.getDeclaredField(&quot;prev&quot;));</span><br><span class="line">              &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class="line">               throw new Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Node.class.getDeclaredField(&quot;prev&quot;)</code>语句很好理解，就是获取Node类中<code>pre</code>字段，如果有则返回相应Field字段，反之抛出NoSuchFieldException异常。关于Unfase中的<code>objectFieldOffset(Field f)</code>方法，我曾经在<a href="https://www.jianshu.com/p/d0e84096d108" target="_blank" rel="noopener">《Java并发编程之锁机制之LockSupport工具》</a>描述过类似的情况。这里我简单的再解释一遍。该方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也就是说每个字段在类对应的内存中存储是有<code>“角标”</code>的，那么也就是说我们现在的<code>PREV</code>静态变量就代表着Node中<code>prev</code>字段在内存中的“角标”。</p>
<p>当获取到”角标”后，我们再通过<code>U.putObject(node, Node.PREV, oldTail);</code>该方法第一个参数是操作对象，第二个参数是操作的内存“角标”，第三个参数是期望值。那么最后，也就完成了将当前节点的prev字段指向同步队列的尾节点。</p>
<p>当理解了该知识点后，剩下的<code>将同步队列中的tail指针，指向当前节点</code>与<code>如果当前同步队列为空，则构造同步队列</code>这两个操作就非常好理解了。由于篇幅的限制，在这里我就不在进行描述了。希望读者朋友们，能阅读源代码，举一反三。关于这两个方法的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line"> private static final long STATE;</span><br><span class="line"> private static final long HEAD;</span><br><span class="line"> private static final long TAIL;</span><br><span class="line"> static &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         STATE = U.objectFieldOffset</span><br><span class="line">             (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));</span><br><span class="line">         HEAD = U.objectFieldOffset</span><br><span class="line">             (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));</span><br><span class="line">         TAIL = U.objectFieldOffset</span><br><span class="line">             (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));</span><br><span class="line">     &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class="line">         throw new Error(e);</span><br><span class="line">     &#125;</span><br><span class="line">     Class&lt;?&gt; ensureLoaded = LockSupport.class;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private final void initializeSyncQueue() &#123;</span><br><span class="line">     Node h;</span><br><span class="line">     if (U.compareAndSwapObject(this, HEAD, null, (h = new Node())))</span><br><span class="line">         tail = h;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private final boolean compareAndSetTail(Node expect, Node update) &#123;</span><br><span class="line">     return U.compareAndSwapObject(this, TAIL, expect, update);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="唤醒流程"><a href="#唤醒流程" class="headerlink" title="唤醒流程"></a>唤醒流程</h4><p>在理解了唤醒的具体逻辑后，现在来总结一下，唤醒的具体流程。具体如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-694a82e957dce046.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="唤醒流程.png"></p>
<ul>
<li>将等待队列中的<code>头</code>节点线程，移动到同步队列中。</li>
<li>当移动到同步队列中后。唤醒该线程。是该线程参与同步状态的竞争。</li>
</ul>
<p>整体流程其实不算太复杂，大家只需要注意，<code>当我们将等待队列中的线程节点加入到同步队列之后，才会唤醒线程</code>。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>该文章参考以下图书，站在巨人的肩膀上。可以看得更远。</p>
<ul>
<li>《Java并发编程的艺术》<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3></li>
<li><a href="https://www.jianshu.com/p/4ead70bdab56" target="_blank" rel="noopener">Java并发编程之锁机制之引导篇</a></li>
<li><a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">《Java并发编程之锁机制之AQS》</a></li>
<li><a href="https://www.jianshu.com/p/d0e84096d108" target="_blank" rel="noopener">《Java并发编程之锁机制之LockSupport工具》</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之锁机制之Condition接口/" data-id="cjsheb872000tdsr7je1wdxii" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/23/RecyclerView-smoothScrollToPosition了解一下/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/RecyclerView滚动位置，滚动速度设置/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/从ButterKnife-kt-了解Kotlin-委托与扩展/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/Gradle系列-引导篇（一）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/哈希表初识(一)/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 AndyJennifer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>AndyJennifer‘Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="AndyJennifer">
<meta property="og:type" content="website">
<meta property="og:title" content="AndyJennifer‘Blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="AndyJennifer‘Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AndyJennifer‘Blog">
  
    <link rel="alternate" href="/atom.xml" title="AndyJennifer‘Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AndyJennifer‘Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">What would life be if we had no courage to attempt anything?</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-「开眼Eyepetizer」SimpleEyes--学习Kotlin必备良器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/「开眼Eyepetizer」SimpleEyes--学习Kotlin必备良器/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><a href="https://github.com/AndyJennifer/SimpleEyes" target="_blank" rel="noopener">SimpleEyes</a>是一款基于仿开眼视频App，力求与原始开眼App相似（附上相关App参考版本，如有需要可下载<a href="https://pan.baidu.com/s/1xWR4fz9bXL4gH-KkQVX-RA" target="_blank" rel="noopener">开眼Version 3.8.1.2.216</a> ）,该项目中采用<strong>多Activity+多Fragment</strong>开发。使用<strong>MVP+RxJava+Retrofit</strong>架构。主要采用语言<strong>Kotlin</strong>，<strong>目前该项目持续开发中</strong>。如果你愿意和我一起开发，或者有任何问题，请联系我。我总是在这等着你呢。O(∩_∩)O。</p>
<h4 id="切图"><a href="#切图" class="headerlink" title="切图"></a>切图</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-9c4c8943bc9eebc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="picture_1.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-499b2c209643ce12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="picture_2.png"></p>
<h5 id="目前完成的功能"><a href="#目前完成的功能" class="headerlink" title="目前完成的功能"></a>目前完成的功能</h5><ul>
<li>闪屏页实现</li>
<li>首页部分逻辑实现</li>
<li>视频详情界面</li>
<li>视频搜索界面</li>
<li>发现界面部分逻辑</li>
<li>我的界面搭建</li>
</ul>
<h4 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h4><ul>
<li>自定义底部导航栏。项目中自定义了底部导航栏。完全可以根据喜好修改。</li>
<li>自定义字体TextView, 对项目中常用的字体进行了封装。轻松转换字体。</li>
<li>自定义文字显示中的打字效果。</li>
<li>对播放界面进行封装。实现了全屏切换。音量控制，亮度控制等逻辑。</li>
<li>分装了项目请求过程中的，加载中，加载错误。加载空界面的封装。力求做到丝滑过度</li>
<li>…..</li>
</ul>
<p>项目中对很多内容进行了封装，我自己也不知道我封装了那些（就是这么傲娇），项目中运用到了很多动画。每个效果如果大家去仔细研究，我相信大家能和我一样学到很多东西。反正这个项目是大家学习<strong>Kotlin</strong>练手的必备良器。</p>
<h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4><p>站在巨人的肩膀上。可以看得更远。该项目中运用了以下开源库，如果漏掉，请原谅我，我记性不是很好。<br><a href="https://github.com/facebook/fresco" target="_blank" rel="noopener">Fresco</a><br><a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="noopener">Fragmentation</a><br><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a><br><a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a><br><a href="https://github.com/CymChad/BaseRecyclerViewAdapterHelper" target="_blank" rel="noopener">BaseRecyclerViewAdapterHelper</a><br><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">IjkPlayer</a><br><a href="https://github.com/google/flexbox-layout" target="_blank" rel="noopener">FlexBox-Layout</a><br><a href="https://github.com/youth5201314/banner" target="_blank" rel="noopener">Banner</a></p>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>感谢<a href="http://www.kaiyanapp.com" target="_blank" rel="noopener">开眼App</a>提供参考,本人是豆瓣粉丝。使用了其中的Api,并非攻击，如构成侵权，请及时通知我删除或者修改。数据来源来自开眼App,一切解释权归开眼所有。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>注意：此开源项目仅做学习交流使用，如用到实际项目还需多考虑其他因素如并发等，请多多斟酌。如果你觉得不错，对你有帮助，欢迎点个star，follow，也可以帮忙分享给你更多的朋友，这是给我最大的动力与支持</p>
<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><ul>
<li>QQ:443696320</li>
<li>简书:<a href="https://www.jianshu.com/users/921c778fb5e1/timeline" target="_blank" rel="noopener">AndyandJennifer</a></li>
<li>Email: <a href="andyjennifer@126.com">andyjennifer@126.com</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/「开眼Eyepetizer」SimpleEyes--学习Kotlin必备良器/" data-id="cjsheb85p0008dsr7s65akehp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程之锁机制之引导篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之锁机制之引导篇/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-e64e7be17dce3220.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小石头.jpg"></p>
<blockquote>
<p>该文章属于《Java并发编程》系列文章，如果想了解更多，请点击《Java并发编程之总目录》</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前面的文章中。我们了解了<strong>volatile</strong>、了解了<strong>synchronized</strong>。现在我们来了解一下Java SE 5之后新增加的Lock接口（以及相关实现类）实现的锁功能。在阅读该系列文章之前，希望你已经掌握了volatile原理及CAS操作原理。如果你对上述提到的两个知识点不是很熟悉或者了解。那么建议从整个Java内存模型的设计及相关知识点开始了解，欲知详情，请点击—&gt;《Java并发编程之总目录》。</p>
<h3 id="concurrent包的设计"><a href="#concurrent包的设计" class="headerlink" title="concurrent包的设计"></a>concurrent包的设计</h3><p>要了解Java为我们提供的基于Lock接口（以及相关实现类）实现的锁功能，我们首先要看一下整个concurrent包下的设计。具体设计如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-db62acff4c900b57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="current.png"><br>在上图中，我们大致可以看出courrent包下的整体结构。整个包大致分为了三层。</p>
<ul>
<li>高层：Lock、同步器、阻塞队列等。</li>
<li>中层：AQS(AbstractQueuedSynchronizer)、非阻塞数据结构、原子变量类。</li>
<li>底层：volatile变量的读/写、CAS操作。</li>
</ul>
<p>其中每个层中的依赖关系也很明显，AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），都是基于底层实现，而高层类又依赖中层这些基础类。<strong>特别需要注意的是于Lock接口（以及相关实现类）相关的锁功能在整个高层中起着非常重要的重要</strong>。虽然没有直接在图中表述Lock接口在高层中的关系，但是在高层中我们所罗列的同步器、阻塞队列、并发容器等，或多或少都依赖或使用其Lock接口（以及相关实现类）实现的锁功能。</p>
<p>所以了解Lock接口以及相关实现类，对我们认识整个Java并发的机制与设计起着尤为重要的作用。</p>
<h3 id="Lock接口（以及相关实现类）UML类图"><a href="#Lock接口（以及相关实现类）UML类图" class="headerlink" title="Lock接口（以及相关实现类）UML类图"></a>Lock接口（以及相关实现类）UML类图</h3><p>总所周知锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁就能够防止多个线程同时访问共享资源（但是有些锁可以允许多线程并发的访问共享资源，比如我们后期将会讲解的读写锁），在Lock接口出现之前，Java程序是靠synchronized关键字来实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口以及相关实现类，来实现锁的功能。<br>关于 Lock接口（以及相关实现类）的UML类图，具体如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-f66e4f7b822bbc33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="继承关系.png"></p>
<p>关于上图中涉及到的类，我都简单的描述了出来，并没有详细的将每个类中的方法描述出来。因为我觉得前期大家只要了解其中的使用关系就行了。后续的相关文章会对其中涉及到的类及使用会有具体的描述。（<strong>如果在手机端阅览的同学，图片有可能不是很清楚，建议直接在PC端阅读</strong>）</p>
<p>从上图中我们发现整个Lock接口以及相关实现类关系还算比较复杂，所以准备分为以下几个部分来介绍：</p>
<ul>
<li><a href="https://www.jianshu.com/p/6874d9b4f3d8" target="_blank" rel="noopener"> Java并发编程之锁机制之Lock接口</a></li>
<li><a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener"> Java并发编程之锁机制之AQS(AbstractQueuedSynchronizer)</a></li>
<li><a href="https://www.jianshu.com/p/d0e84096d108" target="_blank" rel="noopener">Java并发编程之锁机制之LockSupport工具</a></li>
<li><a href="https://www.jianshu.com/p/a22855b8820a" target="_blank" rel="noopener">Java并发编程之锁机制之Condition接口</a></li>
<li><a href="https://www.jianshu.com/p/1068960ecd64" target="_blank" rel="noopener">Java并发编程之锁机制之重入锁</a></li>
<li><a href="https://www.jianshu.com/p/416e16eea7da" target="_blank" rel="noopener">Java并发编程之锁机制之读写锁</a></li>
</ul>
<p>相信大家看完这系列文章之后，对大家会有所帮助。喜欢我的小伙伴们，不要加我微信啊，给我点赞就行了。你的支持就是对我最大的鼓励。爱你哟~~~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之锁机制之引导篇/" data-id="cjsheb85l0005dsr7znnq3h1x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程之锁机制之AQS(AbstractQueuedSynchronizer)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之锁机制之AQS(AbstractQueuedSynchronizer)/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-0e04abe007aee52d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="爆炸.png"></p>
<blockquote>
<p>该文章属于《Java并发编程》系列文章，如果想了解更多，请点击《Java并发编程之总目录》</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上篇文章<a href="https://www.jianshu.com/p/6874d9b4f3d8" target="_blank" rel="noopener"> 《Java并发编程之锁机制之Lock接口》</a>中，我们已经了解了，Java下整个Lock接口下实现的锁机制是通过<code>AQS(这里我们将AbstractQueuedSynchronizer 或AbstractQueuedLongSynchronizer统称为AQS)</code>与Condition来实现的。那下面我们就来具体了解AQS的内部细节与实现原理。</p>
<blockquote>
<p>PS:该篇文章会以<code>AbstractQueuedSynchronizer</code>来进行讲解，对AbstractQueuedLongSynchronizer有兴趣的小伙伴，可以自行查看相关资料。</p>
</blockquote>
<h3 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h3><p>抽象队列同步器AbstractQueuedSynchronizer （以下都简称AQS），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量来表示同步状态，通过内置的FIFO(first-in-first-out)同步队列来控制获取共享资源的线程。</p>
<p>该类被设计为大多数同步组件的基类，这些同步组件都依赖于单个原子值（int）来控制同步状态，子类必须要定义获取获取同步与释放状态的方法，在AQS中提供了三种方法<code>getState()</code>、<code>setState(int newState)</code>及<code>compareAndSetState(int expect, int update)</code>来进行操作。同时子类应该为自定义同步组件的静态内部类，AQS自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。</p>
<h3 id="AQS类方法简介"><a href="#AQS类方法简介" class="headerlink" title="AQS类方法简介"></a>AQS类方法简介</h3><p>AQS的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p>
<h4 id="修改同步状态方法"><a href="#修改同步状态方法" class="headerlink" title="修改同步状态方法"></a>修改同步状态方法</h4><p>在子类实现自定义同步组件的时候，需要通过AQS提供的以下三个方法，来获取与释放同步状态。</p>
<ul>
<li>int getState() ：获取当前同步状态</li>
<li>void setState(int newState) ：设置当前同步状态</li>
<li>boolean compareAndSetState(int expect, int update) 使用CAS设置当前状态。</li>
</ul>
<h4 id="子类中可以重写的方法"><a href="#子类中可以重写的方法" class="headerlink" title="子类中可以重写的方法"></a>子类中可以重写的方法</h4><ul>
<li>boolean isHeldExclusively()：当前线程是否独占锁</li>
<li>boolean tryAcquire(int arg)：独占式尝试获取同步状态，通过CAS操作设置同步状态，如果成功返回true，反之返回false</li>
<li>boolean tryRelease(int arg)：独占式释放同步状态。</li>
<li>int tryAcquireShared(int arg)：共享式的获取同步状态，返回大于等于0的值，表示获取成功，反之失败。</li>
<li>boolean tryReleaseShared(int arg)：共享式释放同步状态。</li>
</ul>
<h4 id="获取同步状态与释放同步状态方法"><a href="#获取同步状态与释放同步状态方法" class="headerlink" title="获取同步状态与释放同步状态方法"></a>获取同步状态与释放同步状态方法</h4><p>当我们实现自定义同步组件时，将会调用AQS对外提供的方法同步状态与释放的方法，当然这些方法内部会调用其子类的模板方法。这里将对外提供的方法分为了两类，具体如下所示：</p>
<ul>
<li><strong>独占式获取与释放同步状态</strong></li>
</ul>
<ol>
<li>void acquire(int arg)：独占式获取同步状态，如果当前线程获取同步状态成功，则返回，否则进入同步队列等待，该方法会调用tryAcquire(int arg)方法。</li>
<li>void acquireInterruptibly(int arg)：与 void acquire(int arg)基本逻辑相同，但是该方法<code>响应中断</code>,如果当前没有获取到同步状态，那么就会进入等待队列，如果当前线程被中断（<code>Thread().interrupt()</code>），那么该方法将会抛出InterruptedException。并返回</li>
<li>boolean tryAcquireNanos(int arg, long nanosTimeout)：<code>在acquireInterruptibly(int arg)的基础上</code>，增加了超时限制，如果当前线程没有获取到同步状态，那么将返回fase，反之返回true。</li>
<li>boolean release(int arg) ：独占式的释放同步状态</li>
</ol>
<ul>
<li><strong>共享式获取与释放同步状态</strong></li>
</ul>
<ol>
<li>void acquireShared(int arg)：共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，<code>与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态。</code></li>
<li>void acquireSharedInterruptibly(int arg)：<code>在acquireShared(int arg)的基本逻辑相同</code>，增加了响应中断。</li>
<li>boolean tryAcquireSharedNanos(int arg, long nanosTimeout)：<code>在acquireSharedInterruptibly的基础上</code>，增加了超时限制。</li>
<li>boolean releaseShared(int arg) ：共享式的释放同步状态</li>
</ol>
<h3 id="AQS具体实现及内部原理"><a href="#AQS具体实现及内部原理" class="headerlink" title="AQS具体实现及内部原理"></a>AQS具体实现及内部原理</h3><p>在了解了AQS中的针对不同方式获取与释放同步状态（<code>独占式与共享式</code>）与修改同步状态的方法后，现在我们来了解AQS中具体的实现及其内部原理。</p>
<h4 id="AQS中FIFO队列"><a href="#AQS中FIFO队列" class="headerlink" title="AQS中FIFO队列"></a>AQS中FIFO队列</h4><p>在上文中我们提到AQS中主要通过一个FIFO(first-in-first-out)来控制线程的同步。那么在实际程序中，AQS会将获取同步状态的线程构造成一个Node节点，并将该节点加入到队列中。如果该线程获取同步状态失败会阻塞该线程，当同步状态释放时，会把头节点中的线程唤醒，使其尝试获取同步状态。</p>
<h5 id="Node节点结构"><a href="#Node节点结构" class="headerlink" title="Node节点结构"></a>Node节点结构</h5><p>下面我们就通过实际代码来了解Node节点中存储的信息。Node节点具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">    volatile Node prev;</span><br><span class="line">    volatile Node next;</span><br><span class="line">    volatile Thread thread;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Node节点是AQS中的<code>静态内部类</code>，下面分别对其中的属性（<code>注意其属性都用volatile 关键字进行修饰</code>)进行介绍。</p>
<ul>
<li>int waitStatus：等待状态主要包含以下状态</li>
</ul>
<ol>
<li><strong>SIGNAL = -1</strong>：当前节点的线程如果释放了或取消了同步状态，将会将当前节点的状态标志位SINGAL，用于通知当前节点的下一节点，准备获取同步状态。</li>
<li><strong>CANCELLED = 1</strong>：被中断或获取同步状态超时的线程将会被置为当前状态，且该状态下的线程不会再阻塞。</li>
<li><strong>CONDITION = -2</strong>：当前节点在Condition中的等待队列上，（关于Condition会在下篇文章进行介绍），其他线程调用了Condition的singal()方法后，该节点会从等待队列转移到AQS的同步队列中，等待获取同步锁。</li>
<li><strong>PROPAGATE = -3</strong>：与共享式获取同步状态有关，该状态标识的节点对应线程处于可运行的状态。</li>
<li><strong>0</strong>：初始化状态。</li>
</ol>
<ul>
<li>Node prev：当前节点在同步队列中的上一个节点。</li>
<li>Node next：当前节点在同步队列中的下一个节点。</li>
<li>Thread thread：当前转换为Node节点的线程。</li>
<li>Node nextWaiter：当前节点在Condition中等待队列上的下一个节点，（关于Condition会在下篇文章进行介绍）。</li>
</ul>
<h4 id="AQS同步队列具体实现结构"><a href="#AQS同步队列具体实现结构" class="headerlink" title="AQS同步队列具体实现结构"></a>AQS同步队列具体实现结构</h4><p>通过上文的描述我们大概了解了Node节点中存储的数据与信息，现在我们来看看整个AQS下同步队列的结构。具体如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-62c705bac15d1b1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aqs.png"><br>在AQS中的同步队列中，分别有两个指针（你也可以叫做对象的引用），一个<code>head</code>指针指向队列中的头节点，一个<code>tail</code>指针指向队列中的尾节点。</p>
<h5 id="AQS添加尾节点"><a href="#AQS添加尾节点" class="headerlink" title="AQS添加尾节点"></a>AQS添加尾节点</h5><p> 当一个线程成功获取了同步状态（或者锁），其他线程无法获取到同步状态，这个时候会将该线程构造成Node节点，并加入到同步队列中，而这个加入队列的过程必须要确保线程安全，所以在AQS中提供了一个基于CAS的设置尾节点的方法：<code>compareAndSetTail(Node expect,Nodeupdate)</code>，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。具体过程如下图所示：</p>
<p>   <img src="https://upload-images.jianshu.io/upload_images/2824145-0c6db04f40503219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aqs_save_tail.png"><br>上图中，虚线部分为之前tail指向的节点。</p>
<h5 id="AQS添加头节点"><a href="#AQS添加头节点" class="headerlink" title="AQS添加头节点"></a>AQS添加头节点</h5><p>在AQS中的同步队列中，头节点是获取同步状态成功的节点，头节点的线程会在释放同步状态时，将会唤醒其下一个节点，而下一个节点会在获取同步状态成功时将自己设置为头节点，具体过程如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-7a0e99472ad06aad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aqs_save_head.png"></p>
<p>上图中，<code>虚线部分为之前head指向的节点</code>。因为设置头节点是获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要CAS来进行保证，只需要将原头节点的next指向断开就行了。</p>
<p>现在我们已经了解了AQS中同步队列的头节点与尾节点的设置过程。现在我们根据实际代码进行分析，因为涉及到不同状态对同步状态的获取(<code>独占式与共享式</code>)，所以下面会分别对这两种状态进行讲解。</p>
<h4 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h4><h5 id="独占式同步状态获取"><a href="#独占式同步状态获取" class="headerlink" title="独占式同步状态获取"></a>独占式同步状态获取</h5><p>通过<code>acquire(int arg)</code>方法我们可以获取到同步状态，但是需要注意的是该方法并不会响应线程的中断与获取同步状态的超时机制。同时即使当前线程已经中断了，通过该方法放入的同步队列的Node节点（该线程构造的Node），也不会从同步队列中移除。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">      if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法中，主要通过<code>子类重写的方法tryAcquire(arg)</code>来获取同步状态，如果获取同步状态失败，则会将请求线程构造独占式Node节点（Node.EXCLUSIVE），同时将该线程加入同步队列的尾部（因为AQS中的队列是FIFO类型）。接着我们查看addWaiter(Node mode)方法具体细节：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">       Node node = new Node(Thread.currentThread(), mode);//将该线程构造成Node节点</span><br><span class="line"> </span><br><span class="line">       Node pred = tail;</span><br><span class="line">       if (pred != null) &#123;//尝试将尾指针 tail 指向当前线程构造的Node节点</span><br><span class="line">           node.prev = pred;</span><br><span class="line">           if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">             //如果成功，那么将尾指针之前指向的节点的next指向 当前线程构造的Node节点</span><br><span class="line">               pred.next = node;</span><br><span class="line">               return node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       enq(node);//如果当前尾指针为null,则调用enq(final Node node)方法</span><br><span class="line">       return node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法中，主要分为两个步骤：</p>
<ul>
<li>如果当前尾指针（tail)不为null，那么尝试将尾指针 tail 指向当前线程构造的Node节点，如果成功，那么将尾指针之前指向的节点的next指向当前线程构造的Node节点，并返回当前节点。</li>
<li>反之调用enq(final Node node)方法，将当前线程构造的节点加入同步队列中。</li>
</ul>
<p>接下来我们继续查看enq(final Node node)方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">      for (;;) &#123;</span><br><span class="line">          Node t = tail;</span><br><span class="line">          if (t == null) &#123;//如果当前尾指针为null,那么尝试将头指针 head指向当前线程构造的Node节点</span><br><span class="line">              if (compareAndSetHead(new Node()))</span><br><span class="line">                  tail = head;</span><br><span class="line">          &#125; else &#123;//如果当前尾指针（tail)不为null，那么尝试将尾指针 tail 指向当前线程构造的Node节点</span><br><span class="line">              node.prev = t;</span><br><span class="line">              if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                  t.next = node;</span><br><span class="line">                  return t;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在enq(final Node node)方法中，通过<code>死循环（你也可以叫做自旋）</code>的方式来保证节点的正确的添加。接下来，我们继续查看acquireQueued(final Node node, int arg)方法的处理。<code>该方法才是整个多线程竞争同步状态的关键，大家一定要注意看！！！</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();//获取该节点的上一节点</span><br><span class="line">            //如果上一节点是head锁指向的节点，且该节点获取同步状态成功</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">          //设置head指向该节点，</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // 将上一节点的next指向断开</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断获取同步状态失败的线程是否需要阻塞</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())//阻塞并判断当前线程是否已经中断了</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">        //如果线程中断了，那么就将该线程从同步队列中移除，同时唤醒下一节点</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法中主要分为三个步骤:</p>
<ul>
<li>通过<code>死循环（你也可以叫做自旋）</code>的方式来获取同步状态，如果当前节点的<code>上一节点是head指向的节点</code>且<code>该节点获取同步状态成功</code>，那么会设置head指向该节点 ，同时将上一节点的next指向断开。<br><img src="https://upload-images.jianshu.io/upload_images/2824145-577539f984ab6e45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aqs_self_rotate.png"></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-7d9fbf3bebdddfda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aqs_get_head.png"></p>
<ul>
<li>如果当前节点的上一节点不是head指向的节点，或者获取当前节点同步状态失败，那么会先调用<code>shouldParkAfterFailedAcquire(Node pred, Node node)</code>方法来判断是需要否阻塞当前线程，如果该方法返回<code>true</code>，则调用<code>parkAndCheckInterrupt()</code>方法来阻塞线程。如果该方法返回<code>false</code>,那么该方法内部会把当前节点的上一节点的状态修改为Node.SINGAL。</li>
<li>在finally语句块中，判断当前线程是否已经中断。如果中断，则通过那么<code>cancelAcquire(Node node)</code>方法将该线程（对应的Node节点）从同步队列中移除，同时唤醒下一节点。</li>
</ul>
<p>下面我们接着来看<code>shouldParkAfterFailedAcquire(Node pred, Node node)</code>方法，看看具体的阻塞具体逻辑，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">	        //上一节点已经设置状态请求释放信号，因此当前节点可以安全地阻塞</span><br><span class="line">            return true;</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">	        //上一节点，已经被中断或者超时，那么接跳过所有状态为Node.CANCELLED</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">	        //其他状态，则调用cas操作设置状态为Node.SINGAL</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法中会获取上一节点的状态<code>(waitStatus)</code>，然后进行下面的三个步骤的判断。</p>
<ul>
<li>如果上一节点状态为Node.SIGNAL，那么会阻塞接下来的线程<code>(函数 return true)</code>。</li>
<li>如果上一节点的状态大于0（从上文描述的waitStatus所有状态中，我们可以得知只有Node.CANCELLED大于0）那么会跳过整个同步列表中所有状态为Node.CANCELLED的Node节点。<code>(函数 return false)</code>。</li>
<li>如果上一节点是其他状态，则调用CAS操作设置其状态为Node.SINGAL。<code>(函数 return false)</code>。</li>
</ul>
<h5 id="阻塞实现"><a href="#阻塞实现" class="headerlink" title="阻塞实现"></a>阻塞实现</h5><p>当<code>shouldParkAfterFailedAcquire(Node pred, Node node)</code>方法返回<code>true</code>时，接着会调用parkAndCheckInterrupt（）方法来阻塞当前线程。该方法的返回值为当前线程是否中断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">       LockSupport.park(this);</span><br><span class="line">       return Thread.interrupted();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法中，主要阻塞线程的方法是通过LockSupport（在后面的文章中会具体介绍）的park来阻塞当前线程。</p>
<h5 id="从同步队列中移除，同时唤醒下一节点"><a href="#从同步队列中移除，同时唤醒下一节点" class="headerlink" title="从同步队列中移除，同时唤醒下一节点"></a>从同步队列中移除，同时唤醒下一节点</h5><p>通过对独占式获取同步状态的理解，我们知道 acquireQueued(final Node node, int arg)方法中最终会执行<code>finally</code>语句块中的代码，来判断当前线程是否已经中断。如果中断，则通过那么<code>cancelAcquire(Node node)方法将该线程从同步队列中移除</code>。那么接下来我们来看看该方法的具体实现。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> private void cancelAcquire(Node node) &#123;</span><br><span class="line">      //如果当前节点已经不存在直接返回</span><br><span class="line">      if (node == null)</span><br><span class="line">          return;</span><br><span class="line">//（1）将该节点对应的线程置为null</span><br><span class="line">      node.thread = null;</span><br><span class="line"></span><br><span class="line">      //（2）跳过当前节点之前已经取消的节点</span><br><span class="line">      Node pred = node.prev;</span><br><span class="line">      while (pred.waitStatus &gt; 0)</span><br><span class="line">          node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">//获取在（2）操作之后，节点的下一个节点</span><br><span class="line">      Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">   //（3）将当前中断的线程对应节点状态设置为CANCELLED</span><br><span class="line">      node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">      //（4）如果当前中断的节点是尾节点，那么则将尾节点重新指向</span><br><span class="line">      if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">          compareAndSetNext(pred, predNext, null);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          //（5）如果中断的节点的上一个节点的状态，为SINGAL或者即将为SINGAL，</span><br><span class="line">          //那么将该当前中断节点移除</span><br><span class="line">          int ws;</span><br><span class="line">          if (pred != head &amp;&amp;</span><br><span class="line">              ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">               (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">              pred.thread != null) &#123;</span><br><span class="line">              Node next = node.next;</span><br><span class="line">              if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span><br><span class="line">                  compareAndSetNext(pred, predNext, next);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              unparkSuccessor(node);//（6）将该节点移除，同时唤醒下一个节点</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          node.next = node; // help GC</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>观察上诉代码，我们可以知道该方法干了以下这几件事</p>
<ul>
<li>（1）将中断线程对应的节点对应的线程置为null</li>
<li><p>（2）跳过当前节点之前已经取消的节点（我们已经知道在Node.waitStatus的枚举中，只有CANCELLED 大于0 ）<br><img src="https://upload-images.jianshu.io/upload_images/2824145-15ff4717041cc3bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳过已经取消的节点.png"></p>
</li>
<li><p>（3）将当前中断的线程对应节点状态设置为CANCELLED</p>
</li>
<li>（4）在（2）的前提下，如果当前中断的节点<code>是尾节点</code>，那么通过CAS操作将尾节点指向（2）操作后的的节点。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-aa83713dcb855990.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重新设置尾节点Tail.png"></p>
<ul>
<li>（5）如果当前中断节点<code>不是尾节点</code>,且当前中断的节点的上一个节点的状态，为SINGAL或者即将为SINGAL，那么将该当前中断节点移除。</li>
<li>（6）如果（5）条件不满足，那么调用<code>unparkSuccessor(Node node)</code>方法将该节点移除，同时唤醒下一个节点。具体代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">     //重置该节点为初始状态</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">    //获取中断节点的下一节点    </span><br><span class="line">    Node s = node.next;</span><br><span class="line">    //判断下一节点的状态，如果为Node.CANCELED状态</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        //则通过尾节点向前遍历，获取最近的waitStatus&lt;=0的节点</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果该节点不会null，则唤醒该节点中的线程。</span><br><span class="line">    if (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里为了方便大家理解，我还是将图补充了出来，（图片有可能不是很清晰，建议大家点击浏览大图），<br><img src="https://upload-images.jianshu.io/upload_images/2824145-95d89529fae7df5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aqs.png"><br>整体来说，unparkSuccessor（Node node）方法主要是获取中断节点后的可用节点（Node.waitStatus&lt;=0),然后将该节点对应的线程唤醒。</p>
<h5 id="独占式同步状态释放"><a href="#独占式同步状态释放" class="headerlink" title="独占式同步状态释放"></a>独占式同步状态释放</h5><p>当线程获取同步状态成功并执行相应逻辑后，需要释放同步状态，使得后继线程节点能够继续获取同步状态，通过调用AQS的relase(int arg)方法，可以释放同步状态。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">       if (tryRelease(arg)) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法中，会调用模板方法<code>tryRelease(int  arg)</code>，也就是说同步状态的释放逻辑，是需要用户来自己定义的。当<code>tryRelease(int  arg)</code>方法返回true后，如果当前头节点不为null且头节点waitStatus!=0，接着会调用<code>unparkSuccessor(Node node)</code>方法来唤醒下一节点<code>（使其尝试获取同步状态）</code>。关于unparkSuccessor(Node node)方法，上文已经分析过了，这里就不再进行描述了。</p>
<h4 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h4><p>共享式获取与独占式获取最主要的区别在于<code>同一时刻是否能有多个线程同时获取到同步状态</code>。以文件的读写为例，如果一个程序在对文件进行<code>读操作</code>，那么这一时刻对于文件的<code>写操作均会被阻塞</code>。而<code>其他读操作能够同时进行</code>。如果对文件进行<code>写操作</code>，那么这一时刻<code>其他的读写操作都会被阻塞</code>，写操作要求对资源的独占式访问，而读操作可以是共享访问的。</p>
<h5 id="共享式同步状态获取"><a href="#共享式同步状态获取" class="headerlink" title="共享式同步状态获取"></a>共享式同步状态获取</h5><p>在了解了共享式同步状态获取与独占式获取同步状态的区别后，现在我们来看一看共享式获取的相关方法。在AQS中通过 acquireShared(int arg)方法来实现的。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">      if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">          doAcquireShared(arg);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法内部会调用模板方法<code>tryAcquireShared(int arg)</code>,同独占式获取获取同步同步状态一样，也是需要用户自定义的。当<code>tryAcquireShared(int arg)</code>方法返回值小于0时，表示没有获取到同步状态，则调用<code>doAcquireShared(int arg)</code>方法获取同步状态。反之，已经获取同步状态成功，则不进行任何的操作。关于<code>doAcquireShared(int arg)</code>方法具体实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">  //（1）添加共享式节点在AQS中FIFO队列中</span><br><span class="line">     final Node node = addWaiter(Node.SHARED);</span><br><span class="line">     boolean failed = true;</span><br><span class="line">     try &#123;</span><br><span class="line">         boolean interrupted = false;</span><br><span class="line">         //(2)自旋获取同步状态</span><br><span class="line">         for (;;) &#123;</span><br><span class="line">             final Node p = node.predecessor();</span><br><span class="line">             if (p == head) &#123;</span><br><span class="line">                 int r = tryAcquireShared(arg);</span><br><span class="line">                 if (r &gt;= 0) &#123;</span><br><span class="line">                  //当获取同步状态成功后，设置head指针</span><br><span class="line">                     setHeadAndPropagate(node, r);</span><br><span class="line">                     p.next = null; // help GC</span><br><span class="line">                     if (interrupted)</span><br><span class="line">                         selfInterrupt();</span><br><span class="line">                     failed = false;</span><br><span class="line">                     return;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             //(3)判断线程是否需要阻塞</span><br><span class="line">             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                 parkAndCheckInterrupt())</span><br><span class="line">                 interrupted = true;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">      //(4)如果线程已经中断，则唤醒下一节点</span><br><span class="line">         if (failed)</span><br><span class="line">             cancelAcquire(node);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>整体来看，共享式获取的逻辑与独占式获取的逻辑几乎一样，还是以下几个步骤：</p>
<ul>
<li>(1)添加共享式节点在AQS中FIFO队列中,这里需要注意节点的构造为 <code>addWaiter(Node.SHARED)</code>,其中 Node.SHARED为Node类中的静态常量<code>(static final Node SHARED = new Node())</code>，且通过addWaiter（Node.SHARED)方法构造的<code>节点状态为初始状态，也就是waitStatus= 0</code>。</li>
</ul>
<ul>
<li>(2)自旋获取同步状态，如果当前节点的上一节点为head节点，其获取同步状态成功，那么将调用<code>setHeadAndPropagate(node, r);</code>，重新设置head指向当前节点。<code>同时重新设置该节点状态waitStutas = Node.PROPAGATE(共享状态)</code>,然后直接退出doAcquireShared(int arg)方法。具体情况如下图所示：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-3794d9b6c9f71b05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="共享式自旋判断.png"></p>
<ul>
<li>(3)如果不满足条件（2），那么会判断当前节点的上一节点不是head指向的节点，或者获取当前节点同步状态失败，那么会先调用<code>shouldParkAfterFailedAcquire(Node pred, Node node)</code>方法来判断是需要否阻塞当前线程，如果该方法返回<code>true</code>，则调用<code>parkAndCheckInterrupt()</code>方法来阻塞线程。如果该方法返回<code>false</code>,那么该方法内部会把当前节点的上一节点的状态修改为Node.SINGAL。具体情况如下图所示：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-380e27c34be98551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="共享式线程阻塞.png"></p>
<ul>
<li>(4)如果线程已经中断，则唤醒下一节点</li>
</ul>
<p>前面我们提到了，共享式与独占式获取同步状态的主要不同在于<code>其设置head指针的方式不同</code>，下面我们就来看看共享式设置head指针的方法<code>setHeadAndPropagate(Node node, int propagate)</code>。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line"> //(1)设置head 指针，指向该节点</span><br><span class="line">    Node h = head; // Record old head for check below</span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    //(2)判断是否执行doReleaseShared();</span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        //如果当前节点的下一节点是共享式获取同步状态节点，则调用doReleaseShared（）方法</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在setHeadAndPropagate(Node node, int propagate)方法中有两个参数。<br><code>第一个参数node</code>是当前共享式获取同步状态的线程节点。<br><code>第二个参数propagate</code>（中文意思，繁殖、传播）是共享式获取同步状态线程节点的个数。</p>
<p>其主要逻辑步骤分为以下两个步骤：</p>
<ul>
<li>(1)设置head 指针，指向该节点。<code>从中我们可以看出在共享式获取中，Head节点总是指向最进获取成功的线程节点！！！</code></li>
<li>(2)判断是否执行doReleaseShared()，从代码中我们可以得出，主要通过该条件<code>if (s == null || s.isShared())</code>，其中 s为当前节点的下一节点（也就是说同一时刻有可能会有多个线程同时访问）。当该条件为true时，会调用doReleaseShared()方法。关于怎么判断下一节点是否是否共享式线程节点，具体逻辑如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//在共享式访问中，当前节点为SHARED类型</span><br><span class="line">final Node node = addWaiter(Node.SHARED);</span><br><span class="line"></span><br><span class="line">//在调用addWaiter 内部会调用Node构造方法，其中会将nextWaiter设置为Node.SHARED。</span><br><span class="line">Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">         this.nextWaiter = mode;</span><br><span class="line">         this.thread = thread;</span><br><span class="line">     &#125;</span><br><span class="line">//SHARED为Node类静态类    </span><br><span class="line">final boolean isShared() &#123;</span><br><span class="line">         return nextWaiter == SHARED;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面我们继续查看<code>doReleaseShared（）</code>方法的具体实现，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">               int ws = h.waitStatus;</span><br><span class="line">               if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                //(1)从上图中，我们可以得知在共享式的同步队列中，如果存在堵塞节点，</span><br><span class="line">                //那么head所指向的节点状态肯定为Node.SINGAL,</span><br><span class="line">                //通过CAS操作将head所指向的节点状态设置为初始状态，如果成功就唤醒head下一个阻塞的线程</span><br><span class="line">                   if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                       continue;            // loop to recheck cases</span><br><span class="line">                   unparkSuccessor(h);//唤醒下一节点线程，上文分析过该方法，这里就不在讲了</span><br><span class="line">               &#125;</span><br><span class="line">			//(2)表示该节点线程已经获取共享状态成功,则通过CAS操作将该线程节点状态设置为Node.PROPAGATE</span><br><span class="line">			//从上图中，我们可以得知在共享式的同步队列中，</span><br><span class="line">               else if (ws == 0 &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                   continue;                // loop on failed CAS</span><br><span class="line">           &#125;</span><br><span class="line">           if (h == head)                   //如果head指针发生改变一直循环，否则跳出循环</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中我们可以看出该方法主要分为两个步骤：</p>
<ul>
<li>(1)从上图中，我们可以得知在共享式的同步队列中，如果存在堵塞节点，<code>那么head所指向的节点状态肯定为Node.SINGAL</code>，通过CAS操作将head所指向的节点状态设置为初始状态，如果成功就唤醒head下一个阻塞的线程节点，反之继续循环。</li>
<li>(2)如果(1)条件不满足，那么说明该节点已经获取成功的获取同步状态，那么通过CAS操作将该线程节点的状态设置为<code>waitStatus =  Node.PROPAGATE</code>,如果CAS操作失败，就一直循环。</li>
</ul>
<h5 id="共享式同步状态释放"><a href="#共享式同步状态释放" class="headerlink" title="共享式同步状态释放"></a>共享式同步状态释放</h5><p>当线程获取同步状态成功并执行相应逻辑后，需要释放同步状态，使得后继线程节点能够继续获取同步状态，通过调用AQS的releaseShared(int arg)方法，可以释放同步状态。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">       if (tryReleaseShared(arg)) &#123;</span><br><span class="line">           doReleaseShared();</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="独占式与共享式超时获取同步状态"><a href="#独占式与共享式超时获取同步状态" class="headerlink" title="独占式与共享式超时获取同步状态"></a>独占式与共享式超时获取同步状态</h4><p>因为独占式与共享式超时获取同步状态，与其本身的非超时获取同步状态逻辑几乎一样。所以下面就以独占式超时获取同步状态的相应逻辑进行讲解。</p>
<p>在独占式超时获取同步状态中，会调用<code>tryAcquireNanos(int arg, long nanosTimeout)</code>方法，其中具体nanosTimeout参数为你传入的超时时间（<code>单位纳秒</code>），具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        if (Thread.interrupted())</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        return tryAcquire(arg) ||</span><br><span class="line">            doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>观察代码，我们可以得知如果当前线程已经中断，会<code>直接抛出InterruptedException</code>，如果当前线程能够获取同步状态（ 调用tryAcquire(arg)），那么就会直接返回，如果当前线程获取同步状态失败，则调用<code>doAcquireNanos(int arg, long nanosTimeout)</code>方法来超时获取同步状态。那下面我们接着来看该方法具体代码实现，代码如下图所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private boolean doAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        if (nanosTimeout &lt;= 0L)</span><br><span class="line">            return false;</span><br><span class="line">        //(1)计算超时等待的结束时间</span><br><span class="line">        final long deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        final Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                //(2)如果获取同步状态成功，直接返回</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果获取同步状态失败，计算的剩下的时间</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                //(3)如果超时直接退出</span><br><span class="line">                if (nanosTimeout &lt;= 0L)</span><br><span class="line">                    return false;</span><br><span class="line">                //(4)如果没有超时，且nanosTimeout大于spinForTimeoutThreshold（1000纳秒）时，</span><br><span class="line">                //则让线程等待nanosTimeout （剩下的时间，单位：纳秒。）</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(this, nanosTimeout);</span><br><span class="line">                //(5)如果当前线程被中断，直接抛出异常    </span><br><span class="line">                if (Thread.interrupted())</span><br><span class="line">                    throw new InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>整个方法为以下几个步骤：</p>
<ul>
<li>(1)在线程获取同步状态之前，先计算出超时等待的结束时间。（单位精确到纳秒）</li>
<li>(2)通过自旋操作获取同步状态，如果成功，则直接返回</li>
<li>(3)如果获取同步失败，则计算剩下的时间。如果已经超时了就直接退出。</li>
<li>(4)如果没有超时，则判断当前剩余时间<code>nanosTimeout是否大于</code>spinForTimeoutThreshold（1000纳秒），如果大于，则通过 <code>LockSupport.parkNanos(this, nanosTimeout)</code>方法让线程等待相应时间。（该方法会在根据传入的<code>nanosTimeout</code>时间，等待相应时间后返回。），<code>如果nanosTimeout小于等于</code>spinForTimeoutThreshold时，将不会使该线程进行超时等待，而是进入快速的自旋过程。原因在于，非常短的超时等待无法做到十分精确，如果这时再进行超时等待，相反会让nanosTimeout的超时从整体上表现得反而不精确。因此，在超时非常短的场景下，线程会进入无条件的快速自旋。</li>
<li>(5)在没有走（4）步骤的情况下，表示当前线程已经被中断了，则<code>直接抛出InterruptedException</code>。</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>到现在我们基本了解了整个AQS的内部结构与其独占式与共享式获取同步状态的实现，但是其中涉及到的线程的阻塞、等待、唤醒（与LockSupport工具类相关）相关知识点我们都没有具体介绍，后续的文章会对<code>LockSupport工具</code>以及后期关于锁相关的等待/通知模式相关的<code>Condition接口</code>进行介绍。希望大家继续保持着学习的动力~~。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>整个AQS是基于其内部的FIFO队列实现同步控制。请求的线程会封装为Node节点。</li>
<li>AQS分为整体分为独占式与共享式获取同步状态。其支持线程的中断，与超时获取。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之锁机制之AQS(AbstractQueuedSynchronizer)/" data-id="cjsheb878000wdsr7gpz2xiqo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程之锁机制之Lock接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之锁机制之Lock接口/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-99cbcbf1c00c2fc8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小盒子.jpg"></p>
<blockquote>
<p>该文章属于《Java并发编程》系列文章，如果想了解更多，请点击《Java并发编程之总目录》</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上篇文章<a href="https://www.jianshu.com/p/4ead70bdab56" target="_blank" rel="noopener">《Java并发编程之锁机制之引导篇》</a>中，我们大致了解了Lock接口（以及相关实现类）在并发编程重要作用。接下来我们就来具体了解Lock接口中声明的方法以及使用优势。</p>
<h3 id="Lock简介"><a href="#Lock简介" class="headerlink" title="Lock简介"></a>Lock简介</h3><p>Lock 接口实现类提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的 <code>Condition</code> (Condition实现类ConditonObject来实现线程的通知/与唤醒机制，关于Condition后期会进行介绍)对象。</p>
<p>锁是用于控制多线程访问共享资源的工具。通常，锁提供对共享资源的独占访问：一次只有一个线程可以获取锁，对共享资源的所有访问都需要首先获取锁。但是，一些锁可以允许同时访问共享资源，例如<code>ReadWriteLock</code>。</p>
<p>虽然使用关键字synchronized修饰的方法或代码块，会使得在监视器模式（ObjectMonitor)下编程变得非常容易(通过synchronized块或者方法所提供的隐式获取释放锁的便捷性)。虽然这种方式简化了锁的管理，但是某些情况下，还是建议采用Lock接口（及其相关子类）提供的显示的锁的获取和释放。例如，针对一个场景，手把手进行锁获取和释放，先获得锁A，然后再获取锁B，当锁B获得后，释放锁A同时获取锁C，当锁C获得后，再释放B同时获取锁D，以此类推。这种场景下，<br>synchronized关键字就不那么容易实现了，而Lock接口的实现类<code>允许锁在不同的作用范围内获取和释放</code>，并允许以任何顺序获取和释放多个锁。</p>
<h3 id="Lock接口中的方法"><a href="#Lock接口中的方法" class="headerlink" title="Lock接口中的方法"></a>Lock接口中的方法</h3><p>关于Lock接口中涉及到的方法具体如下：（建议直接在PC端查看，手机上有可能看的不是很清楚）<br><img src="https://upload-images.jianshu.io/upload_images/2824145-8b6274b75d4d2022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lock_method.png"><br>从上表中，我们就可以得出使用Lock接口实现的锁机制与使用传统的synchronized的区别</p>
<ol>
<li>尝试非阻塞地获取锁：当线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁。</li>
<li>能被中断的获取锁：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常会被抛出，同时锁也会被释放。</li>
<li>超时获取锁：在指定的截止时间之前获取锁，如果截止时间到了任然无法获取到锁，则返回。</li>
</ol>
<h3 id="Lock简单使用与注意事项"><a href="#Lock简单使用与注意事项" class="headerlink" title="Lock简单使用与注意事项"></a>Lock简单使用与注意事项</h3><p>其中Lock的使用方式也很简单，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ....;具体实现类</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();//建议在finally中释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当锁定和解锁发生在不同的范围时，一定要注意确保在持有锁时执行的所有代码都受到try-finally或try-catch的保护，以确保在必要时释放锁。<code>不要将获取锁的过程写在try块中</code>，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放（因为一旦发生异常，就会走finally语句，如果这个异常（可能是用户自定义异常，用户可以自己处理）需要线程1来处理，但是接着执行了lock.unlock()语句导致了锁的释放。那么其他线程就可以操作共享资源。有可能破坏程序的执行结果）。</p>
<h3 id="Lock相关实现类实现锁机制"><a href="#Lock相关实现类实现锁机制" class="headerlink" title="Lock相关实现类实现锁机制"></a>Lock相关实现类实现锁机制</h3><p>为了使用Lock接口实现相关锁功能时，会涉及以下类和接口，这里还是把上篇文章提到的UML图展示出来：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-0413ea5589564dfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lock.png"></p>
<p>上图中，</p>
<ol>
<li>绿色部分为：其中<code>ReentrantLock（重入锁）</code>、WriteLock、ReadLock都是Lock的实现类。<code>Segment为ReentrantLock的子类（在后续文章，ConcurrentHashMap的讲解中我们会提及）。</code> <code>ReentrantReadWriteLock （读写锁）</code>的实现使用了WriteLock与ReadLock类。</li>
<li>紫色部分为：其中<code>AbstractQueuedSynchronizer</code>与<code>AbstractQueuedLongSynchronizer</code>都为<code>AbstractOwnableSynchronizer</code>的子类，该两个类中都维护了一个同步队列，用于线程的并发执行。在该两个类中拥有名为<code>ConditionObject(为Conditon的实现类)</code>的内部类，只是其内部实现不同。在ConditionObject内部维护了一个等待队列，用于控制线程的等待与唤醒。</li>
</ol>
<h3 id="基本代码结构"><a href="#基本代码结构" class="headerlink" title="基本代码结构"></a>基本代码结构</h3><p>在了解了Lock相关实现类实现锁机制后，这里给实现该锁机制的大致代码结构（根据不同需求，部分方法实现可能不一样，这里只是一个参考，并不是样本代码）。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class LockImpl implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    private final sync mSync = new sync();</span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        mSync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        mSync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return mSync.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return mSync.tryAcquireNanos(1, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        mSync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return mSync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	 //这里也可以继承AbstractQueuedLongSynchronizer</span><br><span class="line">    private static class sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean isHeldExclusively() &#123;...&#125;</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryAcquire(int arg) &#123;...&#125;</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryRelease(int arg) &#123;...&#125;</span><br><span class="line">        @Override</span><br><span class="line">        protected int tryAcquireShared(int arg) &#123;...&#125;</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryReleaseShared(int arg) &#123;...&#125;</span><br><span class="line">        final ConditionObject newCondition() &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中我们可以看出，在整个Lock接口下实现的锁机制中，<code>AQS(这里我们将AbstractQueuedSynchronizer 或AbstractQueuedLongSynchronizer统称为AQS)</code>是实现锁的关键，整个锁的实现是在Lock类的实现类中聚合AQS来实现的，从代码层面上来说，Lock接口（及其实现类）是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节。AQS与Condition才是真正的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Lock接口（及其实现类）相比synchronized有如下优点：</li>
</ol>
<ul>
<li>锁的释放与获取不在是隐式的，允许锁在不同的作用范围内获取和释放`，并允许以任何顺序获取和释放多个锁。</li>
<li>能被中断的获取锁，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常会被抛出，同时锁也会被释放</li>
<li>超时获取锁：在指定的截止时间之前获取锁，如果截止时间到了任然无法获取到锁，则返回。</li>
</ul>
<ol start="2">
<li>在使用Lock的时候注意，一定要确保必要时释放锁</li>
<li>在整个Lock接口下实现的锁机制中,AQS(<strong>上文进行了统称</strong>)与Condition才是真正的实现者。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之锁机制之Lock接口/" data-id="cjsheb85k0004dsr7orh3jc7f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程之synchronized" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之synchronized/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-4e592f4f3b8d49b5.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="学习.jpeg"></p>
<blockquote>
<p>该文章属于《Java并发编程》系列文章，如果想了解更多，请点击《Java并发编程之总目录》</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上篇文章我们讲了<strong>volatile</strong>关键字，我们大致了解了其为轻量级的同步机制，现在我们来讲讲我们关于同步的另一个兄弟<strong>synchronized</strong>。synchronized作为开发中常用的同步机制，也是我们处理线程安全的常用方法。相信大家对其都比较熟悉。但是对于其内部原理与底层代码实现大家有可能不是很了解，下面我就和大家一起彻底了解synchronized的使用方式与底层原理。</p>
<h3 id="线程安全的问题"><a href="#线程安全的问题" class="headerlink" title="线程安全的问题"></a>线程安全的问题</h3><blockquote>
<p>线程安全的定义：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么这个类就是线程安全的。</p>
</blockquote>
<p>在具体讲解synchronized之前，我们需要了解一下什么是线程安全，为什么会出现线程线程不安全的问题。请看下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class ThreadNotSafeDemo &#123;</span><br><span class="line">    private static class Count &#123;</span><br><span class="line">        private int num;</span><br><span class="line">        private void count() &#123;</span><br><span class="line">            for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">                num += i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;-&quot; + num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            Count count = new Count();</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                count.count();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">		//创建10个线程，</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(runnable).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，我们创建Count类，在该类中有一个count()方法，计算从1一直加到10的和，在计算完后输出当前线程的名称与计算的结果，我们期望线程输出的结果是首项为55且等差为55的等差数列。但是结果并不是我们期望的。具体结果如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-cfa91431d1aaf3b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果.png"></p>
<p>我们可以看见，线程并没有按照我们之间想的那样，线程按照从Thread-0到Thread-9依次排列，并且Thread-0与Thread-1线程输出的结果是错误的。</p>
<p>之所以会出现这样的情况，是CPU在调度的时候线程是可以交替执行的，具体来讲是因为当前线程Thread-0求和后，（求和后num值为55），在即将执行打印语句时，突然CPU开始调度执行Thread-1去执行count()方法，那么Thread-0就会停留在即将打印语句的位置，当Thread-1执行计算和后（求和后num值为100），这个时候CPU又开始调度Thread-0执行打印语句。则Thread-1开始暂停，而这个时候num值已经为110了，所以Thread-0打印输出的结果为110。</p>
<h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><p>上面我们了解了之所以会出现线程安全的问题，主要原因就是因为存在多条线程共同操作共享数据，同时CPU的调度的时候线程是可以交替执行的。导致了程序的语义发生改变，所以会出现与我们预期的结果违背的情况。因此为了解决这个问题，在Java中提供了两种方式来处理这种情况。</p>
<h4 id="互斥同步-悲观锁"><a href="#互斥同步-悲观锁" class="headerlink" title="互斥同步(悲观锁)"></a>互斥同步(悲观锁)</h4><p>互斥同步是指当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行。</p>
<p>在Java中最基本的互斥同步就是<strong>synchronized</strong>(这里我们讨论的是jdk1.6之前，在jdk1.6之后Java团队对锁进行了优化，后面文章会具体描述)，也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。</p>
<p>除了synchronized之外，我们还可以使用java.util.concurrent包下的<strong>ReentrantLock</strong>来实现同步。</p>
<h4 id="非阻塞式同步（乐观锁）"><a href="#非阻塞式同步（乐观锁）" class="headerlink" title="非阻塞式同步（乐观锁）"></a>非阻塞式同步（乐观锁）</h4><p>互斥同步主要的问题就是进行线程阻塞和唤醒锁带来的性能问题，为了解决这性能问题，我们有另一种解决方案，当多个线程竞争某个共享数据时，没有获得锁的线程不会阻塞，而是不断的尝试去获取锁，直到成功为止。这种方案的原理就是使用<strong>循环CAS操作</strong>来实现。</p>
<h3 id="synchronized的三种使用方式"><a href="#synchronized的三种使用方式" class="headerlink" title="synchronized的三种使用方式"></a>synchronized的三种使用方式</h3><p>了解了synchronized的解决的问题，那么我们继续来看看在Java中在Java中synchronized的使用情况。</p>
<p>在Java中synchronized主要有三种使用的情况。下面分别列出了这几种情况</p>
<ul>
<li>修饰普通的实例方法，对于普通的同步方法，锁式当前实例对象</li>
<li>修饰静态方法，对于静态同步方法，锁式当前类的Class对象</li>
<li>修饰代码块，对于同步方法块，锁是Synchronized配置的对象</li>
</ul>
<h4 id="证明当前普通的同步方法，锁式当前实例对象"><a href="#证明当前普通的同步方法，锁式当前实例对象" class="headerlink" title="证明当前普通的同步方法，锁式当前实例对象"></a>证明当前普通的同步方法，锁式当前实例对象</h4><p>为了证明普通的同步方法中，锁是当前对象。请观察以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class SynchronizedDemo &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void normalMethod() &#123;</span><br><span class="line">        doPrint(5);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void blockMethod() &#123;//注意,同步块方法块中，配置的是当前类的对象</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            doPrint(5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	//打印当前线程信息与角标值</span><br><span class="line">    private static void doPrint(int index) &#123;</span><br><span class="line">        while (index-- &gt; 0) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + index);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SynchronizedDemo demo = new SynchronizedDemo();</span><br><span class="line">        new Thread(() -&gt; demo.normalMethod(), &quot;testNormalMethod&quot;).start();</span><br><span class="line">        new Thread(() -&gt; demo.normalMethod(), &quot;testBlockMethod&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在上诉代码中，分别创建了两个方法，normalMethod（）与blockMethod（）方法，其中normalMethod()方法为普通的同步方法，blockMethod（）方法中，是一个同步块且配置的对象是当前类的对象。在Main()方法中，分别创建两个线程执行两个不同的方法。</p>
<h5 id="程序输出结果"><a href="#程序输出结果" class="headerlink" title="程序输出结果"></a>程序输出结果</h5><p><img src="https://upload-images.jianshu.io/upload_images/2824145-7616a244b81ac54f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果.png"><br>观察程序输出结果，我们可以看到normalMethod方法是由于blockMethod方法执行的，且blockMethod方法是在normalMethod方法执行完成之后在执行的。也就证明了我们的对于普通的同步方法锁式当前实例对象的结论。</p>
<h4 id="证明对于静态同步方法，锁式当前类的Class对象"><a href="#证明对于静态同步方法，锁式当前类的Class对象" class="headerlink" title="证明对于静态同步方法，锁式当前类的Class对象"></a>证明对于静态同步方法，锁式当前类的Class对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class SynchronizedDemo &#123;</span><br><span class="line">    public void blockMethod() &#123;</span><br><span class="line">        synchronized (SynchronizedDemo.class) &#123;//注意,同步块方法块中，配置的是当前类的Class对象</span><br><span class="line">            doPrint(5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static synchronized void staticMethod() &#123;</span><br><span class="line">        doPrint(5);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 打印当前线程信息</span><br><span class="line">     */</span><br><span class="line">    private static void doPrint(int index) &#123;</span><br><span class="line">        while (index-- &gt; 0) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + index);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SynchronizedDemo demo = new SynchronizedDemo();</span><br><span class="line">        new Thread(() -&gt; demo.blockMethod(), &quot;testBlockMethod&quot;).start();</span><br><span class="line">        new Thread(() -&gt; demo.staticMethod(), &quot;testStaticMethod&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在有了第一个结论的证明后，对于静态同步方法的锁对象就不再进行描述了（但是大家要注意一下，同步方法块中配置的对象是当前类的Class对象）。下面直接给出输出结果：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-b44650256c9ed7b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TIM截图20180821140901.png"></p>
<p>观察结果，也很明显的证明了对于静态同步方法，锁式当前类的Class对象的结论</p>
<h3 id="Synchronized的原理"><a href="#Synchronized的原理" class="headerlink" title="Synchronized的原理"></a>Synchronized的原理</h3><blockquote>
<p>下面文章主要是讲解jdk1.6之后Java团队对锁进行了优化之后的原理，优化之后涉及到偏向锁、轻量级锁、重量级锁。其中该文章都涉及jdk源码，这里把最新的jdk源码分享给大家—–&gt;<a href="https://pan.baidu.com/s/1Lk9yp8cEpSAnLvw5NJdqZg" target="_blank" rel="noopener">jdk源码</a>）</p>
</blockquote>
<p>在了解Synchronized的原理的原理之前，我们需要知道三个知识点<strong>第一个是CAS操作，</strong>、<strong>第二个是Java对象头（其中Synchronized使用的锁就在对象头中）</strong>、<strong>第三个是jdk1.6对锁的优化</strong>。在了解以上三个知识点后，再去理解其原理就相对轻松一点。关于CAS操作已经在上篇文章《Java并发编程之Java CAS操作》进行过讲解，下面我们来讲解关于Java对象头与锁优化的知识点。</p>
<h4 id="Java对象的内存布局"><a href="#Java对象的内存布局" class="headerlink" title="Java对象的内存布局"></a>Java对象的内存布局</h4><p>在Java虚拟机中，对象在内存的存储的布局可以分为3块区域：对象头（Header)、实例数据（Instance Data)、对其填充（Padding)。其中虚拟机中的对象头包括三部分信息，分别为”Mark Word”、类型指针、记录数组长度的数据（可选），具体情况如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-81a3128a336b0a21.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象存储结构.png"></p>
<h4 id="Java对象头的组成"><a href="#Java对象头的组成" class="headerlink" title="Java对象头的组成"></a>Java对象头的组成</h4><ul>
<li>“Mark Word“：第一部分用于存储对象自身的运行时数据。如哈希码（HashCode）、GC分代年龄、<strong>锁状态标志</strong>、线<strong>程持有的锁</strong>、偏向锁ID、偏向锁时间戳等，这部分的数据在长度32位与64位的虚拟机中分别为32bit和64bit，官方称为“Mark Word”。</li>
<li>类型指针：对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。（<strong>Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁</strong>)</li>
<li>记录数组长度数据：对象头剩下的一部分是用于记录数组长度的数据（如果当前对象不是数组，就没有这一部分数据），如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。因为虚拟机可以通过普通Java对象的元数据信息来确定Java对象的大小，但是从数组中的元数据中无法确定数组的大小。</li>
</ul>
<h4 id="“Mark-Word“数据结构"><a href="#“Mark-Word“数据结构" class="headerlink" title="“Mark Word“数据结构"></a>“Mark Word“数据结构</h4><p>其中关于”Mark Word”，因为存储对象头信息是与对象身定义的数据无关的额外的存储成本，考虑到虚拟机的空间效率，”Mark Word”被设计成一个被设计成一个非固定的数据结构以便在极小的空间存储尽量多的信息。它会根据对象的状态复用自己的存储区域。在JVM中，“Mark Word”的实现是在markOop.hpp文件中的markOopDesc类。通过注释我们大致了解”Mark Word”的结构，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hash:保存对象的哈希码</span><br><span class="line">age:GC分代年龄</span><br><span class="line">biased_lock:偏向锁标志</span><br><span class="line">lock:锁状态标志</span><br><span class="line">JavaThread*  当前线程</span><br><span class="line">epoch:保存偏向时间戳</span><br><span class="line"></span><br><span class="line">//  32 bits:</span><br><span class="line">//  --------</span><br><span class="line">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span><br><span class="line">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span><br><span class="line">// 省略部分代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  64 bits:</span><br><span class="line">//  --------</span><br><span class="line">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span><br><span class="line">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span><br><span class="line">// 省略部分代码</span><br></pre></td></tr></table></figure>
<p>在上述代码中，分成了2种不同位数的操作系统，32位与64位。其中关于当前锁的状态标志markOopDesc类中也进行了详细的说明，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum &#123; locked_value             = 0,//轻量级锁 对应[00] </span><br><span class="line">       unlocked_value           = 1,//无锁状态  对应[01]</span><br><span class="line">       monitor_value            = 2,//重量级锁 对应[10]</span><br><span class="line">       marked_value             = 3,//GC标记  对应[11]</span><br><span class="line">       biased_lock_pattern      = 5//是否是偏向锁  对应[101] 其中biased_lock一个bit位，lock两个bit位</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么根据上述代码，我们以32位操作系统为例，可以生成如下两张表：</p>
<h5 id="在无锁状态下，32位JVM的“Mark-Word”的默认存储结构"><a href="#在无锁状态下，32位JVM的“Mark-Word”的默认存储结构" class="headerlink" title="在无锁状态下，32位JVM的“Mark Word”的默认存储结构"></a>在无锁状态下，32位JVM的“Mark Word”的默认存储结构</h5><p><img src="https://upload-images.jianshu.io/upload_images/2824145-16e9628223a24026.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="无锁状态.png"><br>在无锁状态下，“Mark Word“的32bit空间中，25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志<strong>（其中01标识当前线程为无锁状态）</strong>，1bit固定为0。</p>
<h5 id="在有锁状态态下，32位JVM的“Mark-Word”的默认存储结构"><a href="#在有锁状态态下，32位JVM的“Mark-Word”的默认存储结构" class="headerlink" title="在有锁状态态下，32位JVM的“Mark Word”的默认存储结构"></a>在有锁状态态下，32位JVM的“Mark Word”的默认存储结构</h5><p><img src="https://upload-images.jianshu.io/upload_images/2824145-c834f8223e543eac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有锁状态.png"><br>在有锁的状态下，23个bit位用于存储当前线程id,2个bit位用于存储偏向锁时间戳，4个bit为用于存储分代年龄（用于GC),1个bit位存储当前是否是偏向锁，最后的2bit用于当前锁的不同状态。其中00标识当前锁为轻量级锁，10标识为重量级锁，01标识当前锁为偏向锁。</p>
<h3 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h3><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。下面会对各种锁进行介绍。</p>
<ul>
<li><strong>偏向锁</strong><br>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，当一个线程访问同步块，并获取锁是，会在对象头中的“Mark word”和栈帧中的锁记录里存储锁偏向的线程ID。以后该线程在进入和退出同步块时，不需要进行CAS操作来加锁和解锁。只需简单地测试一下对象头的”Mark Word“里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下“Mark Word”中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>
<li><strong>轻量级锁</strong><br>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为<strong>Displaced Mark Word</strong>。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>
<li><strong>重量级锁</strong><br>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁，重量级锁会导致竞争的线程<strong>互斥同步。</strong><h3 id="synchronized底层代码实现"><a href="#synchronized底层代码实现" class="headerlink" title="synchronized底层代码实现"></a>synchronized底层代码实现</h3>在了解了上述知识点后，我们来了解一下synchronized底层代码实现。从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。<strong>代码块同步是使用monitorenter和monitorexit指令实现的</strong>，而<strong>方法同步是使用字节码同步指令ACC_SYNCHRONIZED来实现</strong>的，细节在JVM规范里并没有详细说明。但是方法的同步同样可以使用这两个指令来实现。那我们这里我们就以synchronized代码块底层原理来进行讲解。</li>
</ul>
<blockquote>
<p><strong>字节码同步指令ACC_SYNCHRONIZED原理</strong>：JVM通过使用管程（Monitor)来支持同步，JVM可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志来得知一个方法是否声明为同步方法，当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程（Monitor)，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程，在方法执行期间，执行线程持有了管程，其他任何线程都无法在获取到同一个管程。</p>
</blockquote>
<h3 id="synchronized代码块底层原理"><a href="#synchronized代码块底层原理" class="headerlink" title="synchronized代码块底层原理"></a>synchronized代码块底层原理</h3><p>在了解 synchronized代码块底层原理之前，我们先了解我们常用的synchronized代码块使用方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SyncCodeBlock &#123;</span><br><span class="line">   public int i;</span><br><span class="line">   public void syncTask()&#123;</span><br><span class="line">       //同步代码库</span><br><span class="line">       synchronized (this)&#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们通过javap指令反编译得到字节码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> //===========主要看看syncTask方法实现================</span><br><span class="line">  public void syncTask();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=3, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dup</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: monitorenter  //注意此处，进入同步方法</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: dup</span><br><span class="line">         6: getfield      #2             // Field i:I</span><br><span class="line">         9: iconst_1</span><br><span class="line">        10: iadd</span><br><span class="line">        11: putfield      #2            // Field i:I</span><br><span class="line">        14: aload_1</span><br><span class="line">        15: monitorexit   //注意此处，退出同步方法</span><br><span class="line">        16: goto          24</span><br><span class="line">        19: astore_2</span><br><span class="line">        20: aload_1</span><br><span class="line">        21: monitorexit //注意此处，退出同步方法</span><br><span class="line">        22: aload_2</span><br><span class="line">        23: athrow</span><br><span class="line">        24: return</span><br><span class="line">      Exception table:</span><br><span class="line">      //省略其他字节码.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上诉代码中，我们可以明白当我们声明synchronized代码块的时候，编译器会我们生产相应的monitorenter  与monitorexit 指令。当我们的JVM把字节码加载到内存的时候，会对这两个指令进行解析。其中关于monitorenter 与monitorenter的指令解析是通过InterpreterRuntime.cpp文件中的<strong>InterpreterRuntime::monitorenter</strong>与<strong>InterpreterRuntime::monitorexit</strong>两个函数分别实现的。</p>
<ul>
<li>InterpreterRuntime::monitorenter(JavaThread<em> thread, BasicObjectLock</em> elem)</li>
<li>InterpreterRuntime::monitorexit(JavaThread<em> thread, BasicObjectLock</em> elem)</li>
</ul>
<p>在了解具体的方法实现之间，我们需要了解两个参数信息，第一个参数猜都都猜出来，当前线程的指针，第二个参数为BasicObjectLock类型的指针，那我们来看看BasicObjectLock到底是什么东西。</p>
<h4 id="BasicObjectLock"><a href="#BasicObjectLock" class="headerlink" title="BasicObjectLock"></a>BasicObjectLock</h4><p>关于BasicObjectLock的类具体声明是在basicLock.hpp文件下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class BasicLock &#123;</span><br><span class="line">  friend class VMStructs;</span><br><span class="line">  friend class JVMCIVMStructs;</span><br><span class="line"> private:</span><br><span class="line">  //指向&quot;Mark Word“也就是我们提到过的markOopDesc的指针。这里markOop是markOopDesc的别名</span><br><span class="line">  volatile markOop _displaced_header;</span><br><span class="line"> public:</span><br><span class="line">  //获取&quot;Mark Word“也就是我们提到过的markOopDesc，这里markOop是markOopDesc的别名</span><br><span class="line">  markOop      displaced_header() const               &#123; return _displaced_header; &#125;</span><br><span class="line">  void         set_displaced_header(markOop header)   &#123; _displaced_header = header; &#125;</span><br><span class="line">  //省略部分代码</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BasicObjectLock &#123;</span><br><span class="line">  friend class VMStructs;</span><br><span class="line"> private:</span><br><span class="line">  BasicLock _lock; //拥有BasicLock对象</span><br><span class="line">  oop       _obj;                                    </span><br><span class="line">  //省略部分代码</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从该文件中，我们知道在BasicLock类中指向”Mark Word“的指针，同时BasicObjectLock 也拥有BasicLock对象，那么BasicObjectLock 就能访问”Mark Word“中的内容了。那现在我们再来看上面提到的两个对应的方法。</p>
<h4 id="InterpreterRuntime-monitorenter方法"><a href="#InterpreterRuntime-monitorenter方法" class="headerlink" title="InterpreterRuntime::monitorenter方法"></a>InterpreterRuntime::monitorenter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">  //省略部分代码</span><br><span class="line">  if (UseBiasedLocking) &#123;//判断是否使用偏向锁</span><br><span class="line">	//如果是使用偏向锁，则进入快速获取，避免不必要的膨胀。</span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), true, CHECK);</span><br><span class="line">  &#125; else &#123;//否则直接走轻量级锁的获取</span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  //省略部分代码</span><br></pre></td></tr></table></figure>
<p>当monitorenter方法执行时，会先判断当前是否开启偏向锁（偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态），如果没有开启会直接走轻量级锁的获取，也就是slow_enter（）方法。</p>
<h5 id="偏向锁的获取"><a href="#偏向锁的获取" class="headerlink" title="偏向锁的获取"></a>偏向锁的获取</h5><p>ObjectSynchronizer::fast_enter（）方法是在sychronizer.cpp文件进行声明的，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock,</span><br><span class="line">                                    bool attempt_rebias, TRAPS) &#123;</span><br><span class="line">  if (UseBiasedLocking) &#123;//如果使用偏向锁</span><br><span class="line">    if (!SafepointSynchronize::is_at_safepoint()) &#123;//如果不在安全点，获取当前偏向锁的状态（可能撤销与重偏向）</span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      if (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;//如果是撤销与重偏向直接返回</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;//如果在安全点，有可能会撤销偏向锁</span><br><span class="line">      assert(!attempt_rebias, &quot;can not rebias toward VM thread&quot;);</span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">   //省略部分代码</span><br><span class="line">  &#125;</span><br><span class="line">  slow_enter(obj, lock, THREAD);//如果不使用偏向锁，则走轻量级锁的获取</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法中如果当前JVM支持偏向锁，会需要等待全局安全点（在这个时间点上没有正在执行的字节码），如果当前不在安全点中，会调用revoke_and_rebias（）方法来获取当前偏向锁的状态（可能为撤销或撤销后重偏向）。如果在安全点，会根据当前偏向锁的状态来判断是否需要撤销偏向锁。<strong>其中revoke_and_rebias（）方法是在biasedLocking.cpp中进行声明的。</strong></p>
<h4 id="BiasedLocking-revoke-and-rebias（）方法"><a href="#BiasedLocking-revoke-and-rebias（）方法" class="headerlink" title="BiasedLocking::revoke_and_rebias（）方法"></a>BiasedLocking::revoke_and_rebias（）方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">BiasedLocking::Condition BiasedLocking::revoke_and_rebias(Handle obj, bool attempt_rebias, TRAPS) &#123;</span><br><span class="line">  assert(!SafepointSynchronize::is_at_safepoint(), &quot;must not be called while at safepoint&quot;);</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  </span><br><span class="line">  //第一步，如果没有其他线程占用该对象（mark word中线程id为0，后三位为101，且不尝试重偏向)</span><br><span class="line">  //这里“fast enter（）方法&quot;传入的attempt_rebias为true</span><br><span class="line">  if (mark-&gt;is_biased_anonymously() &amp;&amp; !attempt_rebias) &#123;</span><br><span class="line">    //一般来讲，只有在重新计算对象hashCode的时候才会进入该分支，</span><br><span class="line">    //所以直接用用CAS操作将对象设置为无锁状态</span><br><span class="line">    markOop biased_value       = mark;</span><br><span class="line">    markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(mark-&gt;age());</span><br><span class="line">    markOop res_mark = obj-&gt;cas_set_mark(unbiased_prototype, mark);//cas 操作从新设置偏向锁的状态</span><br><span class="line">    if (res_mark == biased_value) &#123;//如果CAS操作失败，说明存在竞争，偏向锁为撤销状态</span><br><span class="line">      return BIAS_REVOKED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">    //第二步，判断当前偏向锁是否已经锁定(不管mark word中线程id是否为null),尝试重偏向</span><br><span class="line">    Klass* k = obj-&gt;klass();</span><br><span class="line">    markOop prototype_header = k-&gt;prototype_header();</span><br><span class="line">    if (!prototype_header-&gt;has_bias_pattern()) &#123;</span><br><span class="line">     //第三步如果有线程对该对象进行了全局锁定（即同步了静态方法/属性），则取消偏向操作</span><br><span class="line">      markOop biased_value       = mark;</span><br><span class="line">      markOop res_mark = obj-&gt;cas_set_mark(prototype_header, mark);</span><br><span class="line">      assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;even if we raced, should still be revoked&quot;);</span><br><span class="line">      return BIAS_REVOKED;//偏向锁为撤销状态</span><br><span class="line">    &#125; else if (prototype_header-&gt;bias_epoch() != mark-&gt;bias_epoch()) &#123;  //第四步，如果偏向锁时间过期，（这个时候有另一个线程通过偏向锁获取到了这个对象的锁）</span><br><span class="line">      if (attempt_rebias) &#123;//第五步，如果偏向锁开启，重新通过cas操作更新时间戳与分代年龄。</span><br><span class="line">        assert(THREAD-&gt;is_Java_thread(), &quot;&quot;);</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop rebiased_prototype = markOopDesc::encode((JavaThread*) THREAD, mark-&gt;age(), prototype_header-&gt;bias_epoch());</span><br><span class="line">        markOop res_mark = obj-&gt;cas_set_mark(rebiased_prototype, mark);</span><br><span class="line">        if (res_mark == biased_value) &#123;</span><br><span class="line">          return BIAS_REVOKED_AND_REBIASED;//撤销偏移后重偏向。</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;//第六步，如果偏向锁关闭，通过CAS操作更新分代年龄</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(mark-&gt;age());</span><br><span class="line">        markOop res_mark = obj-&gt;cas_set_mark(unbiased_prototype, mark);</span><br><span class="line">        if (res_mark == biased_value) &#123;</span><br><span class="line">          return BIAS_REVOKED;////如果CAS操作失败，说明存在竞争，偏向锁为撤销状态</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> //省略部分代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>偏向锁的获取由BiasedLocking::revoke_and_rebias方法实现，主要分为五个步骤</p>
<ol>
<li>第一步，判断当前偏向锁中”Mark word”中线程id是否为null，且attempt_rebias =false。如果满足条件，尝试通过CAS操作将当前对象设置为无锁状态。如果CAS操作失败，说明存在竞争，偏向锁为撤销状态。</li>
<li>第二步，判断当前偏向锁是否已经锁定（不管mark word中线程id是否为null）,会根据当前条件走第三、第四、第五步。</li>
<li>第三步，如果有线程对该对象进行了全局锁定（即同步了静态方法/属性），偏向锁为撤销状态。</li>
<li>第四步，判断偏向锁时间是否过期（这个时候有另一个线程通过偏向锁获取到了这个对象的锁），接着走第五步、第六步的条件判断</li>
<li>第五步，在偏向锁时间过期的条件下，如果偏向锁开启，那么通过CAS操作更新时间戳与分代年龄、线程ID，如果失败,表明该对象的锁状态已经从撤销偏向到了另一线程。当前偏向锁的状态为撤销后重偏向。</li>
<li>第六步，在偏向锁时间过期的条件下，如果偏向锁默认关闭，那么通过CAS操作更新分代年龄，如果失败，说明存在线程的竞争，偏向锁为撤销状态。</li>
</ol>
<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p>在上文中我们提到了在调用fast_enter（）方法时，如果在安全点，这时会根据偏向锁的状态来判断是否需要撤销偏向锁，也就是调用revoke_at_safepoint（）方法。其中该方法也是在biasedLocking.cpp中进行声明的，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void BiasedLocking::revoke_at_safepoint(Handle h_obj) &#123;</span><br><span class="line">  assert(SafepointSynchronize::is_at_safepoint(), &quot;must only be called while at safepoint&quot;);</span><br><span class="line">  oop obj = h_obj();</span><br><span class="line">  HeuristicsResult heuristics = update_heuristics(obj, false);//获得偏向锁偏向与撤销的次数</span><br><span class="line">  if (heuristics == HR_SINGLE_REVOKE) &#123;//如果是一次撤销</span><br><span class="line">    revoke_bias(obj, false, false, NULL, NULL);</span><br><span class="line">  &#125; else if ((heuristics == HR_BULK_REBIAS) ||//如果是多次撤销或多次偏向</span><br><span class="line">             (heuristics == HR_BULK_REVOKE)) &#123;</span><br><span class="line">    bulk_revoke_or_rebias_at_safepoint(obj, (heuristics == HR_BULK_REBIAS), false, NULL);</span><br><span class="line">  &#125;</span><br><span class="line">  clean_up_cached_monitor_info();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>观察代码我们可以发现，会根据当前偏向锁偏向与撤销的次数走不同的方法。这里我们以revoke_bias()方法为例，来进行讲解。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">static BiasedLocking::Condition revoke_bias(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread, JavaThread** biased_locker) &#123;</span><br><span class="line">  //省略部分代码...</span><br><span class="line">  uint age = mark-&gt;age();</span><br><span class="line">  markOop   biased_prototype = markOopDesc::biased_locking_prototype()-&gt;set_age(age);</span><br><span class="line">  markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(age);</span><br><span class="line">  </span><br><span class="line">  JavaThread* biased_thread = mark-&gt;biased_locker();</span><br><span class="line">  if (biased_thread == NULL) &#123;//判断当前偏向锁中，偏向线程id是否为null</span><br><span class="line">    if (!allow_rebias) &#123;//如果不允许重偏向，则使其偏向锁不可用。</span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">	//省略部分代码...</span><br><span class="line">    return BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> //判断当前偏向锁偏向的线程是否存在</span><br><span class="line">  bool thread_is_alive = false;</span><br><span class="line">  if (requesting_thread == biased_thread) &#123;</span><br><span class="line">    thread_is_alive = true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ThreadsListHandle tlh;</span><br><span class="line">    thread_is_alive = tlh.includes(biased_thread);</span><br><span class="line">  &#125;</span><br><span class="line">  if (!thread_is_alive) &#123;//如果当前偏向锁偏向的线程不存活</span><br><span class="line">    if (allow_rebias) &#123;</span><br><span class="line">      obj-&gt;set_mark(biased_prototype);//如果允许偏向，则将偏向锁中的 线程id置为null</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);//否则，将偏向锁设置为无锁状态 也就是01</span><br><span class="line">    &#125;</span><br><span class="line">    return BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //遍历当前锁记录，找到拥有锁的线程，将需要的displaced headers 写到线程堆栈中。</span><br><span class="line">  GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_thread);</span><br><span class="line">  BasicLock* highest_lock = NULL;</span><br><span class="line">  for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) &#123;</span><br><span class="line">    MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);</span><br><span class="line">    if (oopDesc::equals(mon_info-&gt;owner(), obj)) &#123;</span><br><span class="line">      markOop mark = markOopDesc::encode((BasicLock*) NULL);</span><br><span class="line">      highest_lock = mon_info-&gt;lock();</span><br><span class="line">      highest_lock-&gt;set_displaced_header(mark);//将dispalece headers 写入堆栈中</span><br><span class="line">    &#125; 	</span><br><span class="line">    //省略部分代码...</span><br><span class="line">  &#125;</span><br><span class="line">  if (highest_lock != NULL) &#123;//将需要的displaced headers 写到线程堆栈</span><br><span class="line">   //省略部分代码...</span><br><span class="line">    highest_lock-&gt;set_displaced_header(unbiased_prototype);</span><br><span class="line">   //省略部分代码...</span><br><span class="line">    obj-&gt;release_set_mark(markOopDesc::encode(highest_lock));</span><br><span class="line"> </span><br><span class="line">  //省略部分代码...</span><br><span class="line">  &#125; else &#123;//将对象的头恢复到未锁定或无偏状态</span><br><span class="line">     //省略部分代码...</span><br><span class="line">    if (allow_rebias) &#123;</span><br><span class="line">      obj-&gt;set_mark(biased_prototype);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Store the unlocked value into the object&apos;s header.</span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //获取偏向锁指向的线程</span><br><span class="line">  if (biased_locker != NULL) &#123;</span><br><span class="line">    *biased_locker = biased_thread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return BiasedLocking::BIAS_REVOKED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在偏向锁的撤销，需要等待全局全局点（这个时间点没有在执行的字节码），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态。会更将偏向锁设置为无锁状态，如果线程仍然活着，拥有偏向锁的栈<br>会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<h4 id="轻量级锁的获取"><a href="#轻量级锁的获取" class="headerlink" title="轻量级锁的获取"></a>轻量级锁的获取</h4><p>在上文中我们说过当monitorenter指令执行时，如果当前偏向锁没有开启或多个线程竞争偏向锁导致偏向锁升级为轻量级锁时，那么会直接走轻量级的锁的获取。在讲解轻量级锁的获取之前，需要讲解一个知识点”Displaced Mark Word”。</p>
<h5 id="轻量级锁获与“Displaced-Mark-Word”"><a href="#轻量级锁获与“Displaced-Mark-Word”" class="headerlink" title="轻量级锁获与“Displaced Mark Word”"></a>轻量级锁获与“Displaced Mark Word”</h5><p>在代码进入同步块，执行轻量级锁获取之前，如果此同步对象没有被锁定（锁标志为01状态），JVM会在当前线程的帧栈中建立一个名为锁记录（Lock Record)的空间，用于存储对象目前的”Mark Word”的拷贝（官方把这份拷贝加了一个Displaced前缀，及Displaced Mark Word）。虚拟机将使用CAS操作尝试将对象的“Mark word”更新为指向Lock Record的指针，如果这个更新动作成功了，那么这个现场就拥有了该对象的锁，及该对象处于轻量级锁定状态。关于轻量级锁的获取，具体示意图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-2b7a9f4de35a2dee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="轻量级锁获取示意图.png"></p>
<h5 id="ObjectSynchronizer-slow-enter（）方法"><a href="#ObjectSynchronizer-slow-enter（）方法" class="headerlink" title="ObjectSynchronizer::slow_enter（）方法"></a>ObjectSynchronizer::slow_enter（）方法</h5><p>在了解了具体的轻量级锁获取流程后，我们来查看具体的实现slow_enter()方法。该方法是在sychronizer.cpp文件进行声明的。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) &#123;</span><br><span class="line"></span><br><span class="line">  markOop mark = obj-&gt;mark();//第一步 获取锁对象的“mark word&quot;</span><br><span class="line">  </span><br><span class="line">  if (mark-&gt;is_neutral()) &#123;//第二步，判断当前锁是否是无锁状态 后两位标志位为01</span><br><span class="line">    //第三步，如果是无锁状态，存储对象目前的“mark word&quot;拷贝，</span><br><span class="line">    //通过CAS尝试将锁对象Mark Word更新为指向lock Record对象的指针，</span><br><span class="line">    lock-&gt;set_displaced_header(mark);</span><br><span class="line">    if (mark == obj()-&gt;cas_set_mark((markOop) lock, mark)) &#123;</span><br><span class="line">      TEVENT(slow_enter: release stacklock); //如果更新成功，表示获得锁，则执行同步代码，</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //第四步，如果当前mark处于加锁状态，且线程帧栈中的owner指向当前锁，则执行同步代码， </span><br><span class="line">  else if (mark-&gt;has_locker() &amp;&amp;</span><br><span class="line">             THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">    lock-&gt;set_displaced_header(NULL);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  //第五步，否则说明有多个线程竞争轻量级锁，轻量级锁需要膨胀升级为重量级锁；</span><br><span class="line">  lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">  ObjectSynchronizer::inflate(THREAD,</span><br><span class="line">                              obj(),</span><br><span class="line">                              inflate_cause_monitor_enter)-&gt;enter(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在轻量级锁的获取中，主要分为五个步骤，主要步骤如下：</p>
<ol>
<li>第一步：markOop mark = obj-&gt;mark()方法获取锁对象的markOop数据mark。</li>
<li>第二步：mark-&gt;is_neutral()方法判断mark是否为无锁状态：mark的偏向锁标志位为 0，锁标志位为 01。</li>
<li>第三步：如果处于无锁状态，存储对象目前的“Mark Word”拷贝,通过CAS尝试将锁对象的“Mark Word”更新为指向lock Record对象的指针，如果更新成功，表示竞争到锁，则执行同步代码。</li>
<li>第四步：如果处于有锁状态，且线程帧栈中的owner指向当前锁，则执行同步代码， </li>
<li>第五步：如果都不满足，否则说明有多个线程竞争轻量级锁，轻量级锁需要膨胀升级为重量级锁。</li>
</ol>
<p>适用情形：假设线程A和B同时执行到临界区if (mark-&gt;is_neutral())：</p>
<ol>
<li>线程AB都把Mark Word复制到各自的lock Record空间中，该数据保存在线程的栈帧上，是线程私有的；</li>
<li>通过CAS操作保证只有一个线程可以把指向栈帧的指针复制到Mark Word，假设此时线程A执行成功，并返回继续执行同步代码块。</li>
<li>线程B执行失败，退出临界区，通过ObjectSynchronizer::inflate方法开始膨胀锁（将轻量级锁膨胀为重量级锁）</li>
</ol>
<h4 id="轻量级锁的撤销"><a href="#轻量级锁的撤销" class="headerlink" title="轻量级锁的撤销"></a>轻量级锁的撤销</h4><p>在上文中，我们讲过当走完同步块的时候，会执行monitorexit指令，而轻量级锁的释放这正是在monitorexit执行的时候，也就是InterpreterRuntime::monitorexit（）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">#ifdef ASSERT</span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line">#endif</span><br><span class="line">  Handle h_obj(thread, elem-&gt;obj());</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         &quot;must be NULL or an object&quot;);</span><br><span class="line">  if (elem == NULL || h_obj()-&gt;is_unlocked()) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_IllegalMonitorStateException());</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::slow_exit(h_obj(), elem-&gt;lock(), thread);</span><br><span class="line">  // Free entry. This must be done here, since a pending exception might be installed on</span><br><span class="line">  // exit. If it is not cleared, the exception handling code will try to unlock the monitor again.</span><br><span class="line">  elem-&gt;set_obj(NULL);</span><br><span class="line">#ifdef ASSERT</span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line">#endif</span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure></p>
<p>在monitorexit（）方法中内部会调用slow_exit（）方法而slow_exit()方法内部会调用fast_exit（）方法，我们查看fast_exit（）方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void ObjectSynchronizer::fast_exit(oop object, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">  markOop mark = object-&gt;mark();</span><br><span class="line">  //省略部分代码...</span><br><span class="line">  markOop dhw = lock-&gt;displaced_header();//获取线程堆栈中的Displaced Mark Word</span><br><span class="line">  if (dhw == NULL) &#123;//如果线程堆栈中的Displaced Mark Word为null</span><br><span class="line">	#ifndef PRODUCT</span><br><span class="line">    if (mark != markOopDesc::INFLATING()) &#123;//如果当前轻量级锁不是在膨胀为重量级锁</span><br><span class="line">      //省略部分代码...</span><br><span class="line">      if (mark-&gt;has_monitor()) &#123;//如果已经为重量级锁，直接返回</span><br><span class="line">        ObjectMonitor * m = mark-&gt;monitor();</span><br><span class="line">        assert(((oop)(m-&gt;object()))-&gt;mark() == mark, &quot;invariant&quot;);</span><br><span class="line">        assert(m-&gt;is_entered(THREAD), &quot;invariant&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  //如果当前线程拥有轻量级锁，那么通过CAS尝试把Displaced Mark Word替换到当前锁对象的Mark Word，</span><br><span class="line">  //如果CAS成功，说明成功的释放了锁</span><br><span class="line">  if (mark == (markOop) lock) &#123;</span><br><span class="line">    assert(dhw-&gt;is_neutral(), &quot;invariant&quot;);</span><br><span class="line">    if (object-&gt;cas_set_mark(dhw, mark) == mark) &#123;</span><br><span class="line">      TEVENT(fast_exit: release stack-lock);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //如果CAS操作失败，说明其他线程在尝试获取轻量级锁，这个时候需要将轻量级锁升级为重量级锁</span><br><span class="line">  ObjectSynchronizer::inflate(THREAD,</span><br><span class="line">                              object,</span><br><span class="line">                              inflate_cause_vm_internal)-&gt;exit(true, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在偏向锁的释放中，会经历一下几个步骤。</p>
<ol>
<li>获取线程堆栈中的Displaced Mark Word</li>
<li>如果线程堆栈中的Displaced Mark Word为null，如果已经为重量级锁，直接返回。</li>
<li>如果当前线程拥有轻量级锁，那么通过CAS尝试把Displaced Mark Word替换到当前锁对象的Mark Word，如果CAS成功，说明成功的释放了锁</li>
<li>如果CAS操作失败，说明其他线程在尝试获取轻量级锁，这个时候需要将轻量级锁升级为重量级锁。</li>
</ol>
<h4 id="重量级锁的获取"><a href="#重量级锁的获取" class="headerlink" title="重量级锁的获取"></a>重量级锁的获取</h4><p>在上文中我们提到过，在多个线程进行轻量级锁的获取时或在轻量级锁撤销时，有肯能会膨胀为重量级锁，那现在我们就来看看膨胀的具体过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor* ObjectSynchronizer::inflate(Thread * Self,</span><br><span class="line">                                           oop object,</span><br><span class="line">                                           const InflateCause cause) &#123;</span><br><span class="line">  EventJavaMonitorInflate event;</span><br><span class="line"></span><br><span class="line">  for (;;) &#123;//开始自旋</span><br><span class="line">    const markOop mark = object-&gt;mark();</span><br><span class="line">    // The mark can be in one of the following states:</span><br><span class="line">    // *  Inflated     - just return</span><br><span class="line">    // *  Stack-locked - coerce it to inflated</span><br><span class="line">    // *  INFLATING    - busy wait for conversion to complete</span><br><span class="line">    // *  Neutral      - aggressively inflate the object.</span><br><span class="line">    // *  BIASED       - Illegal.  We should never see this</span><br><span class="line"></span><br><span class="line">    //1.如果当前锁已经为重量级锁了，直接返回</span><br><span class="line">    if (mark-&gt;has_monitor()) &#123;</span><br><span class="line">      ObjectMonitor * inf = mark-&gt;monitor();</span><br><span class="line">      return inf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //2.如果正在膨胀的过程中，在完成膨胀过程中，其他线程必须等待。</span><br><span class="line">    if (mark == markOopDesc::INFLATING()) &#123;</span><br><span class="line">      TEVENT(Inflate: spin while INFLATING);</span><br><span class="line">      ReadStableMark(object);</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	//3.如果当前为轻量级锁，迫使其膨胀为重量级锁</span><br><span class="line">    if (mark-&gt;has_locker()) &#123;</span><br><span class="line">      ObjectMonitor * m = omAlloc(Self);</span><br><span class="line">      m-&gt;Recycle();</span><br><span class="line">      m-&gt;_Responsible  = NULL;</span><br><span class="line">      m-&gt;_recursions   = 0;</span><br><span class="line">      m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;   // Consider: maintain by type/class</span><br><span class="line"></span><br><span class="line">      markOop cmp = object-&gt;cas_set_mark(markOopDesc::INFLATING(), mark);</span><br><span class="line">      if (cmp != mark) &#123;</span><br><span class="line">        omRelease(Self, m, true);</span><br><span class="line">        continue;       // Interference -- just retry</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      markOop dmw = mark-&gt;displaced_mark_helper();</span><br><span class="line">      assert(dmw-&gt;is_neutral(), &quot;invariant&quot;);</span><br><span class="line"></span><br><span class="line">      m-&gt;set_header(dmw);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">      m-&gt;set_owner(mark-&gt;locker());</span><br><span class="line">      m-&gt;set_object(object);</span><br><span class="line">      // TODO-FIXME: assert BasicLock-&gt;dhw != 0.</span><br><span class="line"></span><br><span class="line">      // Must preserve store ordering. The monitor state must</span><br><span class="line">      // be stable at the time of publishing the monitor address.</span><br><span class="line">      guarantee(object-&gt;mark() == markOopDesc::INFLATING(), &quot;invariant&quot;);</span><br><span class="line">      object-&gt;release_set_mark(markOopDesc::encode(m));</span><br><span class="line"></span><br><span class="line">      // Hopefully the performance counters are allocated on distinct cache lines</span><br><span class="line">      // to avoid false sharing on MP systems ...</span><br><span class="line">      OM_PERFDATA_OP(Inflations, inc());</span><br><span class="line">      TEVENT(Inflate: overwrite stacklock);</span><br><span class="line">      if (log_is_enabled(Debug, monitorinflation)) &#123;</span><br><span class="line">        if (object-&gt;is_instance()) &#123;</span><br><span class="line">          ResourceMark rm;</span><br><span class="line">          log_debug(monitorinflation)(&quot;Inflating object &quot; INTPTR_FORMAT &quot; , mark &quot; INTPTR_FORMAT &quot; , type %s&quot;,</span><br><span class="line">                                      p2i(object), p2i(object-&gt;mark()),</span><br><span class="line">                                      object-&gt;klass()-&gt;external_name());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (event.should_commit()) &#123;</span><br><span class="line">        post_monitor_inflate_event(&amp;event, object, cause);</span><br><span class="line">      &#125;</span><br><span class="line">      return m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	//4.如果为无锁状态，重置监视器状态</span><br><span class="line">    assert(mark-&gt;is_neutral(), &quot;invariant&quot;);</span><br><span class="line">    ObjectMonitor * m = omAlloc(Self);</span><br><span class="line">    // prepare m for installation - set monitor to initial state</span><br><span class="line">    m-&gt;Recycle();</span><br><span class="line">    m-&gt;set_header(mark);</span><br><span class="line">    m-&gt;set_owner(NULL);</span><br><span class="line">    m-&gt;set_object(object);</span><br><span class="line">    m-&gt;_recursions   = 0;</span><br><span class="line">    m-&gt;_Responsible  = NULL;</span><br><span class="line">    m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;       // consider: keep metastats by type/class</span><br><span class="line"></span><br><span class="line">    if (object-&gt;cas_set_mark(markOopDesc::encode(m), mark) != mark) &#123;</span><br><span class="line">      m-&gt;set_object(NULL);</span><br><span class="line">      m-&gt;set_owner(NULL);</span><br><span class="line">      m-&gt;Recycle();</span><br><span class="line">      omRelease(Self, m, true);</span><br><span class="line">      m = NULL;</span><br><span class="line">      continue;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">  //省略部分代码...</span><br><span class="line">   return m ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在轻量级锁膨胀为重量级锁大致可以分为以下几个过程</p>
<ol>
<li>如果当前锁已经为重量级锁了，直接返回ObjectMonitor 对象。</li>
<li>如果正在膨胀的过程中，在完成膨胀过程中，其他线程自旋等待。这里需要注意一点，虽然是自旋操作，但不会一直占用cpu资源，会通过spin/yield/park方式挂起线程。</li>
<li>如果当前为轻量级锁，迫使其膨胀为重量级锁</li>
<li>如果是无锁，重置ObjectMonitor 中的状态。</li>
</ol>
<h3 id="锁升级示意图"><a href="#锁升级示意图" class="headerlink" title="锁升级示意图"></a>锁升级示意图</h3><p>在了解了偏向锁、轻量级锁，与重量级锁的原理后，现在我们来总结一下整个锁升级的流程。具体如下图所示：</p>
<h4 id="偏向锁获得和撤销"><a href="#偏向锁获得和撤销" class="headerlink" title="偏向锁获得和撤销"></a>偏向锁获得和撤销</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-baf96b535929b672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="偏向锁获得和撤销示意图.png"></p>
<h4 id="轻量级锁膨胀流程图"><a href="#轻量级锁膨胀流程图" class="headerlink" title="轻量级锁膨胀流程图"></a>轻量级锁膨胀流程图</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-11f9e59e6e2af1e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="轻量级锁膨胀示意图.png"></p>
<h3 id="重量级锁的竞争"><a href="#重量级锁的竞争" class="headerlink" title="重量级锁的竞争"></a>重量级锁的竞争</h3><p>在上文中，我们主要介绍了整个锁升级的流程与源代码实现。而真正线程的等待与竞争我们还没有详细描述。下面我们就来讲讲当锁膨胀为重量级锁的时候，整个线程的竞争与等待过程。重量级锁的竞争是在objectMonitor.cpp中ObjectMonitor::enter()方法中实现的。</p>
<h4 id="ObjectMonitor结构"><a href="#ObjectMonitor结构" class="headerlink" title="ObjectMonitor结构"></a>ObjectMonitor结构</h4><p>在讲解具体的锁获取之前，我们需要了解<strong>每个锁对象（这里指已经升级为重量级锁的对象）都有一个ObjectMonitor（对象监视器）</strong>。也就是说每个线程获取锁对象都会通过ObjectMonitor。代码如下所示：（这里我省略了一些不必要的属性。大家只需要看一些关键的结构）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ObjectMonitor &#123;</span><br><span class="line"> public:</span><br><span class="line">  enum &#123;</span><br><span class="line">    OM_OK,                    // 没有错误</span><br><span class="line">    OM_SYSTEM_ERROR,          // 系统错误</span><br><span class="line">    OM_ILLEGAL_MONITOR_STATE, // 监视器状态异常</span><br><span class="line">    OM_INTERRUPTED,           // 当前线程已经中断</span><br><span class="line">    OM_TIMED_OUT              // 线程等待超时</span><br><span class="line">  &#125;;</span><br><span class="line">  volatile markOop   _header;       // 线程帧栈中存储的 锁对象的mark word拷贝</span><br><span class="line"></span><br><span class="line"> protected:                         // protected for JvmtiRawMonitor</span><br><span class="line">  void *  volatile _owner;          // 指向获得objectMonitor的线程或者 BasicLock对象</span><br><span class="line">  volatile jlong _previous_owner_tid;  // 上一个获得objectMonitor的线程id</span><br><span class="line">  volatile intptr_t  _recursions;   // 同一线程重入锁的次数，如果是0，表示第一次进入</span><br><span class="line">  ObjectWaiter * volatile _EntryList; // 在进入或者重进入阻塞状态下的线程链表</span><br><span class="line">                             </span><br><span class="line"> protected:</span><br><span class="line">  ObjectWaiter * volatile _WaitSet; // 处于等待状态下的线程链表</span><br><span class="line">  volatile jint  _waiters;          //处于等待状态下的线程个数</span><br></pre></td></tr></table></figure></p>
<h4 id="重量级锁的获取-1"><a href="#重量级锁的获取-1" class="headerlink" title="重量级锁的获取"></a>重量级锁的获取</h4><p>在了解了ObjectMonitor 类中具体结构后，来看看具体的锁获取方法ObjectMonitor::enter（），具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void ObjectMonitor::enter(TRAPS) &#123;</span><br><span class="line"></span><br><span class="line">  Thread * const Self = THREAD;//当前进入enter方法的线程</span><br><span class="line"> </span><br><span class="line"> //通过CAS操作尝试吧monitor的_owner（ 指向获得objectMonitor的线程或者 BasicLock对象）设置为当前线程</span><br><span class="line">  void * cur = Atomic::cmpxchg(Self, &amp;_owner, (void*)NULL);</span><br><span class="line">  </span><br><span class="line">  if (cur == NULL) &#123;//如果成功，当前线程获取锁成功，直接执行同步代码块</span><br><span class="line">    assert(_recursions == 0, &quot;invariant&quot;);</span><br><span class="line">    assert(_owner == Self, &quot;invariant&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //如果是同一线程，则记录当前重入的次数（上一步CAS操作不管成功还是失败，都会返回_owner指向的地址)</span><br><span class="line">  if (cur == Self) &#123;</span><br><span class="line">    _recursions++;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //如果之前_owner指向的BasicLock在当前线程栈上，说明当前线程是第一次进入该monitor，</span><br><span class="line">  //设置_recursions为1，_owner为当前线程，该线程成功获得锁并返回；</span><br><span class="line">  if (Self-&gt;is_lock_owned ((address)cur)) &#123;</span><br><span class="line">    assert(_recursions == 0, &quot;internal state error&quot;);</span><br><span class="line">    _recursions = 1;</span><br><span class="line">    _owner = Self;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  //省略部</span><br><span class="line">  分代码...</span><br><span class="line">  </span><br><span class="line">  //开始竞争锁</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">      jt-&gt;set_suspend_equivalent();</span><br><span class="line">      EnterI(THREAD);</span><br><span class="line">      if (!ExitSuspendEquivalent(jt)) break;</span><br><span class="line">      _recursions = 0;</span><br><span class="line">      _succ = NULL;</span><br><span class="line">      exit(false, Self);</span><br><span class="line">      jt-&gt;java_suspend_self();</span><br><span class="line">    &#125;</span><br><span class="line">    Self-&gt;set_current_pending_monitor(NULL);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">//省略部分代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在重量级级锁的竞争步骤，主要分为以下几个步骤：</p>
<ol>
<li>通过CAS操作尝试吧monitor的_owner（ 指向获得objectMonitor的线程或者 BasicLock对象）设置为当前线程，如果CAS操作成功，表示线程获取锁成功，直接执行同步代码块。</li>
<li>如果是同一线程重入锁，则记录当前重入的次数。</li>
<li>如果2,3步骤都不满足，则开始竞争锁，走EnterI()方法。</li>
</ol>
<h5 id="EnterI-方法实现"><a href="#EnterI-方法实现" class="headerlink" title="EnterI()方法实现"></a>EnterI()方法实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void ObjectMonitor::EnterI(TRAPS) &#123;</span><br><span class="line">  Thread * const Self = THREAD;</span><br><span class="line">  //省略部分代码...</span><br><span class="line">  </span><br><span class="line">  //把当前线程被封装成ObjectWaiter的node对象，状态设置成ObjectWaiter::TS_CXQ；</span><br><span class="line">  ObjectWaiter node(Self);</span><br><span class="line">  Self-&gt;_ParkEvent-&gt;reset();</span><br><span class="line">  node._prev   = (ObjectWaiter *) 0xBAD;</span><br><span class="line">  node.TState  = ObjectWaiter::TS_CXQ;//TS_CXQ：为竞争锁状态</span><br><span class="line"></span><br><span class="line"> //在for循环中，通过CAS把node节点push到_cxq链表中；</span><br><span class="line">  ObjectWaiter * nxt;</span><br><span class="line">  for (;;) &#123;</span><br><span class="line">    node._next = nxt = _cxq;</span><br><span class="line">    //如果CAS操作失败，继续尝试，是因为当期_cxq链表已经发生改变了</span><br><span class="line">    if (Atomic::cmpxchg(&amp;node, &amp;_cxq, nxt) == nxt) break;</span><br><span class="line">	//有可能在放入_cxq链表中时，已经获取到锁了，直接返回</span><br><span class="line">    if (TryLock (Self) &gt; 0) &#123;</span><br><span class="line">      assert(_succ != Self, &quot;invariant&quot;);</span><br><span class="line">      assert(_owner == Self, &quot;invariant&quot;);</span><br><span class="line">      assert(_Responsible != Self, &quot;invariant&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> //将node节点push到_cxq链表之后，通过自旋尝试获取锁</span><br><span class="line">  for (;;) &#123;</span><br><span class="line"></span><br><span class="line">    if (TryLock(Self) &gt; 0) break;//尝试获取锁</span><br><span class="line">    assert(_owner != Self, &quot;invariant&quot;);</span><br><span class="line"></span><br><span class="line">    if ((SyncFlags &amp; 2) &amp;&amp; _Responsible == NULL) &#123;</span><br><span class="line">      Atomic::replace_if_null(Self, &amp;_Responsible);</span><br><span class="line">    &#125;</span><br><span class="line">    //判断执行循环的次数，如果执行相应循环后，如果还是没有获取到锁，则通过park函数将当前线程挂起，等待被唤醒</span><br><span class="line">    if (_Responsible == Self || (SyncFlags &amp; 1)) &#123;</span><br><span class="line">      TEVENT(Inflated enter - park TIMED);</span><br><span class="line">      Self-&gt;_ParkEvent-&gt;park((jlong) recheckInterval);</span><br><span class="line">      // Increase the recheckInterval, but clamp the value.</span><br><span class="line">      recheckInterval *= 8;</span><br><span class="line">      if (recheckInterval &gt; MAX_RECHECK_INTERVAL) &#123; 其中MAX_RECHECK_INTERVAL为1000</span><br><span class="line">        recheckInterval = MAX_RECHECK_INTERVAL;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      TEVENT(Inflated enter - park UNTIMED);</span><br><span class="line">      Self-&gt;_ParkEvent-&gt;park();</span><br><span class="line">    &#125;</span><br><span class="line">	//省略部分代码...</span><br><span class="line">    OrderAccess::fence();</span><br><span class="line">  &#125;</span><br><span class="line"> //省略部分代码...</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于EnterI()方法，可以分为以下步骤：</p>
<ol>
<li>把当前线程被封装成ObjectWaiter的node对象，同时将该线程状态设置为TS_CXQ（竞争状态）</li>
<li>在for循环中，通过CAS把node节点push到_cxq链表中，如果CAS操作失败，继续尝试，是因为当期_cxq链表已经发生改变了继续for循环，如果成功直接返回。</li>
<li>将node节点push到_cxq链表之后，通过自旋尝试获取锁（TryLock方法获取锁)，如果循环一定次数后，还获取不到锁，则通过park函数挂起。（并不会消耗CPU资源）</li>
</ol>
<p>关于获取锁的TryLock方法如下所示：</p>
<h5 id="TryLock方法"><a href="#TryLock方法" class="headerlink" title="TryLock方法"></a>TryLock方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int ObjectMonitor::TryLock(Thread * Self) &#123;</span><br><span class="line">  void * own = _owner;</span><br><span class="line">  if (own != NULL) return 0;</span><br><span class="line">  if (Atomic::replace_if_null(Self, &amp;_owner)) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数其实很简单，就是将锁中的_owner指针指向当前线程，如果成功返回1，反之返回-1。</p>
<h4 id="重量级锁的释放"><a href="#重量级锁的释放" class="headerlink" title="重量级锁的释放"></a>重量级锁的释放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">void ObjectMonitor::exit(bool not_suspended, TRAPS) &#123;</span><br><span class="line">  Thread * const Self = THREAD;</span><br><span class="line">  if (THREAD != _owner) &#123;//如果当前锁对象中的_owner没有指向当前线程</span><br><span class="line">    if (THREAD-&gt;is_lock_owned((address) _owner)) &#123;</span><br><span class="line">      //但是_owner指向的BasicLock在当前线程栈上,那么将_owner指向当前线程</span><br><span class="line">      assert(_recursions == 0, &quot;invariant&quot;);</span><br><span class="line">      _owner = THREAD;</span><br><span class="line">      _recursions = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">	  //省略部分代码...</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //如果当前，线程重入锁的次数，不为0，那么就重新走ObjectMonitor::exit，直到重入锁次数为0为止</span><br><span class="line">  if (_recursions != 0) &#123;</span><br><span class="line">    _recursions--;        // this is simple recursive enter</span><br><span class="line">    TEVENT(Inflated exit - recursive);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  //省略部分代码...</span><br><span class="line">  for (;;) &#123;</span><br><span class="line"></span><br><span class="line">    if (Knob_ExitPolicy == 0) &#123;</span><br><span class="line">      OrderAccess::release_store(&amp;_owner, (void*)NULL);   //释放锁</span><br><span class="line">      OrderAccess::storeload();                        // See if we need to wake a successor</span><br><span class="line">      if ((intptr_t(_EntryList)|intptr_t(_cxq)) == 0 || _succ != NULL) &#123;</span><br><span class="line">        TEVENT(Inflated exit - simple egress);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      TEVENT(Inflated exit - complex egress);</span><br><span class="line">    //省略部分代码...</span><br><span class="line">    &#125;</span><br><span class="line">    //省略部分代码...</span><br><span class="line">    ObjectWaiter * w = NULL;</span><br><span class="line">    int QMode = Knob_QMode;</span><br><span class="line">	</span><br><span class="line">	//根据QMode的模式判断，</span><br><span class="line">	</span><br><span class="line">    //如果QMode == 2则直接从_cxq挂起的线程中唤醒	</span><br><span class="line">    if (QMode == 2 &amp;&amp; _cxq != NULL) &#123;</span><br><span class="line">      w = _cxq;</span><br><span class="line">      ExitEpilog(Self, w);</span><br><span class="line">      return;</span><br><span class="line">	    &#125;</span><br><span class="line">     //省略部分代码... 省略的代码为根据QMode的不同，不同的唤醒机制</span><br><span class="line">	 &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   //省略部分代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重量级锁的释放可以分为以下步骤：</p>
<ol>
<li>判断当前锁对象中的_owner没有指向当前线程，如果_owner指向的BasicLock在当前线程栈上,那么将_owner指向当前线程。</li>
<li>如果当前锁对象中的_owner指向当前线程，则判断当前线程重入锁的次数，如果不为0，那么就重新走ObjectMonitor::exit（），直到重入锁次数为0为止。</li>
<li>释放当前锁，并根据QMode的模式判断，是否将_cxq中挂起的线程唤醒。还是其他操作。</li>
</ol>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>写了这么久，终于写完了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">该篇文章主要是根据先关博客与自己对源码的理解，发现其实有很多东西自己还是描述的不是很清楚。主要原因是C++代码看的我头大。个人感觉Java的整个锁的机制其实涉及到蛮多的东西，自己理解的只是冰山一角，如果大家对代码或者文章不理解，请轻喷。我也是看的半懂半懂的。原谅我啦</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>站在巨人的肩膀上能看的更远~~~<br>《深入理解Java虚拟机：JVM高级特性与最佳实践》<br>《Java并发编程的艺术》<br><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a><br><a href="https://www.cnblogs.com/dennyzhangdd/p/6734638.html" target="_blank" rel="noopener">jdk源码剖析二: 对象内存布局、synchronized终极原理</a><br><a href="https://pan.baidu.com/s/1Lk9yp8cEpSAnLvw5NJdqZg" target="_blank" rel="noopener">jdk源码</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之synchronized/" data-id="cjsheb87c000ydsr7gy3p22bc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/23/RecyclerView-smoothScrollToPosition了解一下/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/RecyclerView滚动位置，滚动速度设置/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/从ButterKnife-kt-了解Kotlin-委托与扩展/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/Gradle系列-引导篇（一）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/哈希表初识(一)/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 AndyJennifer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
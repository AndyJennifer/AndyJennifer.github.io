<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>AndyJennifer‘Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="AndyJennifer">
<meta property="og:type" content="website">
<meta property="og:title" content="AndyJennifer‘Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="AndyJennifer‘Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AndyJennifer‘Blog">
  
    <link rel="alternate" href="/atom.xml" title="AndyJennifer‘Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AndyJennifer‘Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">What would life be if we had no courage to attempt anything?</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android-Handler机制之内存泄漏" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Android-Handler机制之内存泄漏/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-73ede8ebabc4c5a9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="溢出啦啦.jpg"></p>
<blockquote>
<p>该文章属于Android Handler系列文章，如果想了解更多，请点击<br><a href="https://www.jianshu.com/p/43bb31d8a742" target="_blank" rel="noopener">《Android Handler机制之总目录》</a></p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>整个Handler机制系列文章到此就结束了，相信大家基本已经将整个Handler机制消化的差不多了，现在就剩下最后一个知识点，在平时开发中使用Handler有可能会<code>导致内存泄漏</code>的问题。下面我们就一起去了解了解~~</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>内存泄漏在官方的定义如下:</p>
<blockquote>
<p>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
</blockquote>
<p>那么翻译成人话，就是当一个对象不再被使用时，本该被系统回收，但却因为有另外一个正在使用的对象持有它的引用，导致其不能被回收，造成内存的浪费。</p>
<p>那么针对于Android系统来说，在Android系统中会为每个应用程序分配相应的内存（根据手机厂商的不同，分配的内存大小会有所差异）。也就是说对于每一个应用程序来说其内存是有限的。那么当某个应用程序产生的内存泄漏较多时，导致达到应用总的内存阀值，那么就会导致应用崩溃。</p>
<h3 id="Handler内存泄漏的情况讨论"><a href="#Handler内存泄漏的情况讨论" class="headerlink" title="Handler内存泄漏的情况讨论"></a>Handler内存泄漏的情况讨论</h3><p>为了分析Handler内存泄漏的具体情况，请参看以下示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class HandlerLeakageActivity extends BaseActivity &#123;</span><br><span class="line"></span><br><span class="line">    public static final int UPDATE_UI = 1;</span><br><span class="line">    </span><br><span class="line">    private Handler mHandler = new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            if (msg.what == UPDATE_UI) &#123;</span><br><span class="line">                updateUI();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_handler_leakage);</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.what = UPDATE_UI;</span><br><span class="line">        mHandler.sendMessageDelayed(message, 1000 * 3600 * 24);//发送延时24小时消息</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	//更新ui</span><br><span class="line">    private void updateUI() &#123;...&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码逻辑很简单，我们在HandlerLeakageActivity 中创建了内部类Handler，同时发送了一个延时为24小时的消息。当HandlerLeakageActivity 收到这个延迟消息后，那么接着会来更新UI，同时我们可以得到以下引用链：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-5c954ec52cdd8638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="handler_refrence.png"><br>其中的内部类Handler 拥有当前Activity的引用，是因为<code>在Java中，非静态内部类会持有外部类的引用</code>，而Messagey拥有Handler的引用，是因为Message通过Looper的loop（）方法取出后，需要相应的Handler来处理消息（<code>msg.target ==发送消息的Handler</code>）。</p>
<p>那么在整个Handler机制下的引用关系如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-dce1099c23153126.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="handler_leakage.png"></p>
<p>参照上图，我们设想一种情况，假设我们在程序启动的时候，首先进入HandlerLeakageActivity ，然后又将其finish掉。那么就会出现，因为延迟消息的迟迟不能被取出执行，导致该Activity不能被系统回收。从而造成上文我们提到过的<code>内存泄漏</code>。</p>
<h4 id="那么问题来了，什么时候引用链会断开？"><a href="#那么问题来了，什么时候引用链会断开？" class="headerlink" title="那么问题来了，什么时候引用链会断开？"></a>那么问题来了，什么时候引用链会断开？</h4><p>在文章<a href="https://www.jianshu.com/p/d0ef4edd4407" target="_blank" rel="noopener">《Android Handler机制之Message及Message回收机制 》</a><br>中，我们曾经提到过，当消息被Looper通过Loop（）方法取出并执行的时候，会执行recycleUnchecked（）方法来重置消息中的数据，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void recycleUnchecked() &#123;</span><br><span class="line">        flags = FLAG_IN_USE;</span><br><span class="line">        what = 0;</span><br><span class="line">        arg1 = 0;</span><br><span class="line">        arg2 = 0;</span><br><span class="line">        obj = null;</span><br><span class="line">        replyTo = null;</span><br><span class="line">        sendingUid = -1;</span><br><span class="line">        when = 0;</span><br><span class="line">        target = null;//将关联handler对象置为null</span><br><span class="line">        callback = null;</span><br><span class="line">        data = null;</span><br><span class="line">		//省略部分代码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法中将<code>target =null</code>，其中消息中的<code>target</code>为当前发送该消息的Handler对象。也就说只有消息被取出执行后，整个引用链才会断开，那么相应的Handler与使用该Handler的Activity才会被系统回收。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>通过上文Handler内存泄漏的问题分析，导致这种情况的发生的原因是内部类Handler拥有当前Activity的引用。那么解决只要解决这个问题，我们就能处理Handler内存泄漏啦。</p>
<h4 id="使用静态内部类-弱引用的方式"><a href="#使用静态内部类-弱引用的方式" class="headerlink" title="使用静态内部类+弱引用的方式"></a>使用静态内部类+弱引用的方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class HandlerLeakageActivity extends BaseActivity &#123;</span><br><span class="line">    public static final int UPDATE_UI = 1;</span><br><span class="line">    </span><br><span class="line">    private MyHandler mHandler = new MyHandler(this);</span><br><span class="line">	//使用静态内部类</span><br><span class="line">    private static class MyHandler extends Handler &#123;</span><br><span class="line"></span><br><span class="line">        private final WeakReference&lt;HandlerLeakageActivity&gt; mWeakReference;</span><br><span class="line">        MyHandler(HandlerLeakageActivity activity) &#123;</span><br><span class="line">            mWeakReference = new WeakReference&lt;HandlerLeakageActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            HandlerLeakageActivity activity = mWeakReference.get();</span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">                activity.updateUI();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    	//更新ui</span><br><span class="line">    private void updateUI() &#123;...&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>为了保证不再持有当前Activity的引用，我们采用静态内部类的方式（<code>静态内部类不会持有外部类引用</code>），同时为了让Handler在处理消息的时候，能够调用外部类Activity的方法，所以我们这里采用<code>弱引用</code>的方式。</p>
<h5 id="为什么要使用弱引用？"><a href="#为什么要使用弱引用？" class="headerlink" title="为什么要使用弱引用？"></a>为什么要使用弱引用？</h5><p>在Java中判断一个对象到底是不是需要回收，都跟引用相关。在Java中引用分为了4类。</p>
<ul>
<li>强引用：只要引用存在，垃圾回收器永远不会回收Object obj = new Object();而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉。</li>
<li>软引用：是用来描述，一些还有但并非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。（SoftReference)</li>
<li>弱引用：也是用来描述非必须的对象，但是它的强度要比软引用更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都回回收掉被弱引用关联的对象。（WeakReference)</li>
<li>虚引用：也被称为幽灵引用，它是最弱的一种关系。一个对象是否有引用的存在，完全不会对其生存时间构成影响，也无法通过一个虚引用来取得一个实例对象。<h4 id="另创建一个类-弱引用的方式"><a href="#另创建一个类-弱引用的方式" class="headerlink" title="另创建一个类+弱引用的方式"></a>另创建一个类+弱引用的方式</h4>如果你不想使用静态内部类+弱引用的方式，你也可以采用新建一个Handler类文件+弱引用的方式。这两种代码基本差不多，这里就不过多进行介绍了。</li>
</ul>
<h4 id="当外部类生命周期结束时，清空消息"><a href="#当外部类生命周期结束时，清空消息" class="headerlink" title="当外部类生命周期结束时，清空消息"></a>当外部类生命周期结束时，清空消息</h4><p>如果你不想采用上述的两种方式，还有一种方法就是在当前Activity被finish掉的时候，移除掉整个消息队列中的所有消息。这样就能保证Activity与Handler没有直接的引用关系啦。</p>
<p>关于消息的删除主要有三种方法，大家可以根据自己的项目需求来选择相应的方法。具体如下所示：</p>
<blockquote>
<p>（关于消息的删除，如果有同学不是很熟悉，请参看《Android Handler机制之Message及Message回收机制》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void removeMessages(Handler h, int what, Object object)</span><br><span class="line">void removeMessages(Handler h, Runnable r, Object object)</span><br><span class="line">void removeCallbacksAndMessages(Handler h, Object object)</span><br><span class="line">void removeCallbacksAndMessages(Object token)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>结合Activity的生命周期，具体代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onDestroy() &#123;</span><br><span class="line">       super.onDestroy();</span><br><span class="line">       //这里token传null,会移除消息队列中所有当前Handler发送且未被执行的消息</span><br><span class="line">       mHandler.removeCallbacksAndMessages(null);</span><br></pre></td></tr></table></figure>
<p>这里我使用removeCallbacksAndMessages(Object token) 方法来清空消息，需要注意的是如果token=null,该方法会<code>移除消息队列中所有当前Handler发送且未被执行的消息</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Handler在使用时，如果直接采用内部类，有可能会导致内存泄漏。</li>
<li>Handler内存泄漏的主要原因是，内部类Handler拥有外部类Activity的引用，且不能保证消息的发送是否有较长延时。</li>
<li>解决Handler内存泄漏的主要方法有，采用静态内部类+弱引用，当外部类生命周期结束时，清空消息等。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Android-Handler机制之内存泄漏/" data-id="cjsheb85y000adsr7x2lby1rc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android-Handler机制之循环消息队列的退出" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Android-Handler机制之循环消息队列的退出/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-8bc6d10af2118f1b.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="啦啦.jpeg"></p>
<blockquote>
<p>该文章属于Android Handler系列文章，如果想了解更多，请点击<br><a href="https://www.jianshu.com/p/43bb31d8a742" target="_blank" rel="noopener">《Android Handler机制之总目录》</a></p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上几篇文中我们介绍了整个消息的循环机制以及消息的回收。现在我们来看看整么退出循环消息队列。（到现在为止，整个Android Handler机制快要接近尾声了。不知道大家看了整个系列的文章，有没有对Handler机制有个深一点的了解。如果对你有所帮助，我也感到十分的开心与自豪~~~）。</p>
<h3 id="消息队列的退出"><a href="#消息队列的退出" class="headerlink" title="消息队列的退出"></a>消息队列的退出</h3><p>要想结束循环消息队列，需要调用Loooper的quitSafely（）或quit（）方法，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void quitSafely() &#123; mQueue.quit(true);&#125;</span><br><span class="line">public void quit() &#123; mQueue.quit(false); &#125;</span><br></pre></td></tr></table></figure></p>
<p>而该两个方法的内部，都会调用Loooper中对应的MessageQueue的quit(boolean safe)方法。查看quit(boolean safe)方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void quit(boolean safe) &#123;</span><br><span class="line">     if (!mQuitAllowed) &#123;//注意，主线程是不能退出消息循环的</span><br><span class="line">         throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     synchronized (this) &#123;</span><br><span class="line">         if (mQuitting) &#123;//如果当前循环消息已经退出了，直接返回</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         mQuitting = true;//该标记十分重要，十分重要</span><br><span class="line"></span><br><span class="line">         if (safe) &#123;//如果是安全退出</span><br><span class="line">             removeAllFutureMessagesLocked();</span><br><span class="line">         &#125; else &#123;//如果不是安全退出</span><br><span class="line">             removeAllMessagesLocked();</span><br><span class="line">         &#125;</span><br><span class="line">         nativeWake(mPtr);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在MessageQueue的quit(boolean safe)方法中，会将<strong>mQuitting （用于判断当前消息队列是否已经退出，该标志位十分有用，下文会提到）置为true</strong>，同时会根据当前是否安全退出的标志 (safe)来走不同的逻辑,如果安全则走removeAllFutureMessagesLocked（）方法，如果不是安全退出则走removeAllMessagesLocked（）方法。下面分别对这两个方法进行讨论。</p>
<h4 id="非安全退出-removeAllMessagesLocked-方法"><a href="#非安全退出-removeAllMessagesLocked-方法" class="headerlink" title="非安全退出 removeAllMessagesLocked()方法"></a>非安全退出 removeAllMessagesLocked()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void removeAllMessagesLocked() &#123;</span><br><span class="line">    Message p = mMessages;//消息队列中的头节点</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">        Message n = p.next;</span><br><span class="line">        p.recycleUnchecked();//回收消息</span><br><span class="line">        p = n;</span><br><span class="line">    &#125;</span><br><span class="line">    mMessages = null;//将消息队列中的头节点置为null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非安全退出其实很简单，就是遍历消息队列中的消息（消息队列内部结构是链表）将所有消息队列中的消息全部回收。同时将MessageQueue中的mMessages （消息队列中的头消息）置为null，其中关于Message的recycleUnchecked()方法，如果你对该方法不是很熟悉，建议先阅读<a href="https://www.jianshu.com/p/d0ef4edd4407" target="_blank" rel="noopener">《Android Handler机制之Message及Message回收机制 》</a>。关于非安全退出时，消息队列中的回收示意图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-012dc5d65a9d84b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收全部消息.png"></p>
<h4 id="退出消息循环的具体逻辑"><a href="#退出消息循环的具体逻辑" class="headerlink" title="退出消息循环的具体逻辑"></a>退出消息循环的具体逻辑</h4><p>上文中，我们描述了在非安全退出时MessageQueue中仅仅进行了消息的回收，而并没有真正涉及到循环消息队列的退出，现在我们就来看一看息循环退出的具体逻辑。我们都知道整个消息循环的消息获得，都是通过Loooper中的loop（）方法，具体代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">       final Looper me = myLooper();</span><br><span class="line">    //省略部分代码...</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           Message msg = queue.next(); // might block</span><br><span class="line">           if (msg == null) &#123;</span><br><span class="line">            //如果没有消息，那么说明当前消息队列已经退出</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       //省略部分代码</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从代码中我们可以退出，整个loop()方法的结束，会与MessageQueue的next（）方法相关，如果next（）方法获取的msg为null,那么Looper中的loop方法也直接结束。那么整个消息循环也退出了。那接下来我们来查看Message 中的next()方法，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">   //省略部分代码...</span><br><span class="line">      for (;;) &#123;</span><br><span class="line">          if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">              Binder.flushPendingCommands();</span><br><span class="line">          &#125;</span><br><span class="line">          synchronized (this) &#123;</span><br><span class="line">             //省略部分代码..</span><br><span class="line">              if (mQuitting) &#123;</span><br><span class="line">                  dispose();</span><br><span class="line">                  return null;</span><br><span class="line">              &#125;</span><br><span class="line">              //省略部分代码..</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在Message中的next()方法中，如果mQuitting为true，该方法会直接就返回了。<strong>大家还记得我们mQuitting是什么时候置为true的吗？</strong>对！就是我们调用Loooper的quitSafely（）或quit（）方法（也就是调用MessageQueue.quit(boolean safe)）时，会将mQuitting置为true。</p>
<p>那么到现在整个循环消息队列的退出的逻辑就清楚了。主要分为以下几个步骤:</p>
<ol>
<li>Looper调用quitSafely（）或quit（）方法时会导致mQuitting标志位为true。</li>
<li>Looper调用quitSafely（）或quit（）方法时，内部会分别走MessageQueue的removeAllFutureMessagesLocked（）与removeAllMessagesLocked（）,上述两种方法会回收消息队列中的消息。</li>
<li>Looper整个的消息循环是通过其loop（）方法。当MessageQueue中的next()获取的消息为空时，或导致整个循环消息队列的退出。  </li>
<li>MessageQueue中的next（）方法受mQuitting标志位影响，当mQuitting=true时，next()方法会返回null。</li>
</ol>
<h4 id="安全退出removeAllFutureMessagesLocked-方法"><a href="#安全退出removeAllFutureMessagesLocked-方法" class="headerlink" title="安全退出removeAllFutureMessagesLocked()方法"></a>安全退出removeAllFutureMessagesLocked()方法</h4><p>现在为止，我们已经基本了解了整个循环消息队列退出的流程了。在了解了非安全退出的方法之后，我们再来看看安全退出时，涉及到的逻辑操作。上文我们已经提到过了，当Looper调用quitSafely（）方法时，内部会走MessagQueue的removeAllFutureMessagesLocked（）。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void removeAllFutureMessagesLocked() &#123;</span><br><span class="line">     final long now = SystemClock.uptimeMillis();</span><br><span class="line">     Message p = mMessages;//当前队列中的头消息</span><br><span class="line">     if (p != null) &#123;</span><br><span class="line">         if (p.when &gt; now) &#123;//判断时间，如果Message的取出时间比当前时间要大直接移除</span><br><span class="line">             removeAllMessagesLocked();</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             Message n;</span><br><span class="line">             for (;;) &#123;//继续判断，取队列中所有大于当前时间的消息</span><br><span class="line">                 n = p.next;</span><br><span class="line">                 if (n == null) &#123;</span><br><span class="line">                     return;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (n.when &gt; now) &#123;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">                 p = n;</span><br><span class="line">             &#125;</span><br><span class="line">             p.next = null;</span><br><span class="line">             do &#123;//将所有所有大于当前时间的消息的消息回收</span><br><span class="line">                 p = n;</span><br><span class="line">                 n = p.next;</span><br><span class="line">                 p.recycleUnchecked();</span><br><span class="line">             &#125; while (n != null);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>观察上诉代码，在该方法中，会判断当前消息队列中的头消息的时间是否大于当前时间，如果大于当前时间就会removeAllMessagesLocked（）方法（也就是回收全部消息），反之，则回收部分消息，同时没有被回收的消息任然可以被取出执行。具体示意图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-104a9f156f672df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收部分消息.png"></p>
<p>当使用安全退出循环消息队列时，整个退出逻辑与非安全退出有一定的区别。在上文中我们说过。当安全退出时，程序会判断消息队列会根据消息中的message.when来判断是否回收消息。那么在消息队列中没有被回收的消息是仍然能被取出执行的。具体代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">  //省略部分代码...</span><br><span class="line">     for (;;) &#123;</span><br><span class="line">         //省略部分代码...</span><br><span class="line">         synchronized (this) &#123;</span><br><span class="line">          //省略部分代码...</span><br><span class="line">          Message prevMsg = null;</span><br><span class="line">             Message msg = mMessages;</span><br><span class="line">             if (msg != null) &#123;</span><br><span class="line">                 if (now &lt; msg.when) &#123;</span><br><span class="line">             //省略部分代码...</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">		  //省略部分代码...</span><br><span class="line">		   </span><br><span class="line">		   //第一处。如果消息队列中仍然有消息，是会取出并执行的。</span><br><span class="line">                     mBlocked = false;</span><br><span class="line">                     if (prevMsg != null) &#123;</span><br><span class="line">                         prevMsg.next = msg.next;</span><br><span class="line">                     &#125; else &#123;</span><br><span class="line">                         mMessages = msg.next;</span><br><span class="line">                     &#125;</span><br><span class="line">                     msg.next = null;</span><br><span class="line">                     if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                     msg.markInUse();</span><br><span class="line">                     return msg;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             //省略部分代码...</span><br><span class="line">             </span><br><span class="line">             // 第二处，退出循环消息队列</span><br><span class="line">             if (mQuitting) &#123;</span><br><span class="line">                 dispose();</span><br><span class="line">                 return null;</span><br><span class="line">             &#125;</span><br><span class="line">    //省略部分代码...</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中我们可以明显的看见，当我们的消息队列中仍然有消息的时候，是会取出消息并返回的。不管mQuitting的值是否设置为true。那么当整个消息队列中的消息取完以后。才会走返回null(图上代码 第二处)。</p>
<h3 id="当循环消息队列退出时，仍然发送消息"><a href="#当循环消息队列退出时，仍然发送消息" class="headerlink" title="当循环消息队列退出时，仍然发送消息"></a>当循环消息队列退出时，仍然发送消息</h3><p>其实有很多小朋友们肯定会关注，”当我整个循环消息队列退出的时候，如果我仍然使用Handler发送消息，那么我的消息去那里了呢，是被抛弃了，还是有什么特殊处理呢?”，下面我们就带着这些疑惑来看看Handler机制中具体的处理。</p>
<p>我们都知道当调用Handler发送消息的时候，最终走的方法就是enqueueMessage（）方法，其中该方法内部又会走MessageQueue的enqueueMessage（Message msg, long when）方法。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">     msg.target = this;</span><br><span class="line">     if (mAsynchronous) &#123;</span><br><span class="line">         msg.setAsynchronous(true);</span><br><span class="line">     &#125;</span><br><span class="line">     return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>MessageQueue的enqueueMessage（Message msg, long when）方法，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">       if (msg.target == null) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (msg.isInUse()) &#123;</span><br><span class="line">           throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           if (mQuitting) &#123;//如果当前消息循环队列已经退出，那么将该消息回收。</span><br><span class="line">               IllegalStateException e = new IllegalStateException(</span><br><span class="line">                       msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">               Log.w(TAG, e.getMessage(), e);</span><br><span class="line">               msg.recycle();//回收消息</span><br><span class="line">               return false;//返回该消息没有加入消息队列的标志</span><br><span class="line">           &#125;</span><br><span class="line">       //省略部分代码。。。</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过观察MessageQueue的enqueueMessage（Message msg, long when）方法，我们能得出该方法内部会判断当前循环消息队里是否退出，如果已经结束，那么会将Handler发送的消息回收，同时会返回该消息没有加入消息队列的标志（return false)。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>循环消息队列的退出是通过调用Loooper的quitSafely（）或quit（）方法，两个退出方法都会导致消息队列中的消息回收。</li>
<li>quitSafely（）与quit()方法的区别是，quit()会直接回收消息队列中的消息，而quitSafely（）会根据当前的时间进行判断，如果消息的meesage.when比当前时间大，那么就会被回收，反之仍然被取出执行。</li>
<li>在整个循环消息队列退出的时候，如果在发送消息，那么该消息是会被会收的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Android-Handler机制之循环消息队列的退出/" data-id="cjsheb861000bdsr7axccj836" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android-注解系列之APT工具（三）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Android-注解系列之APT工具（三）/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>该文章中涉及的代码，我已经提交到GitHub上了，大家按需下载—-&gt;<a href="https://github.com/AndyJennifer/AptDemo" target="_blank" rel="noopener">源码</a></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-1f146c8640782324.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="骑车车.jpg"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上篇文章<a href="https://www.jianshu.com/p/65c4af2ce8f0" target="_blank" rel="noopener">Android 注解系列之Annotation（二）</a>中，简要的介绍了注解的基本使用与定义。同时也提出了以下几个问题，<code>当我们声明了一个注解后，是不是需要手动找到所有的Class对象或Field、Method？</code>，<code>怎么通过注解生成新的类的定义呢？</code>当面对这些问题的时候，我相信大家的第一反应肯定会想，”有不有相应的三方库呢？Java是否提供了相应库或者方法来解决呢？”，当然Java肯定给我们提供了啦，就是我们既陌生又熟悉的<code>APT</code>工具啦。</p>
<p>为什么这里我会说既陌生又熟悉呢？我相信对于大多数安卓程序，我们都或多或少使用了一些主流库，如<code>Dagger2、ButterKnife、EventBus</code>等，这些库都使用了APT技术。既然大佬们都在使用，那我们怎么不去了解呢？好了，书归正传，下面我们就来看看怎么通过APT来处理之前我们提到的问题。</p>
<h3 id="APT技术简介"><a href="#APT技术简介" class="headerlink" title="APT技术简介"></a>APT技术简介</h3><p>在具体了解APT技术之前，先简单的对其进行介绍。<code>APT(Annotation Processing Tool)</code>是javac中提供的一种编译时扫描和处理注解的工具，它会对源代码文件进行检查，并找出其中的注解，然后根据用户自定义的注解处理方法进行额外的处理。APT工具不仅能解析注解，还能根据注解生成其他的源文件，最终将生成的新的源文件与原来的源文件共同编译（<code>注意：APT并不能对源文件进行修改操作，只能生成新的文件，例如在已有的类中添加方法</code>）。具体流程图如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-c1ef896348dd225e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="apt使用流程图.png"></p>
<h3 id="APT技术使用规则"><a href="#APT技术使用规则" class="headerlink" title="APT技术使用规则"></a>APT技术使用规则</h3><p>APT技术的使用，需要我们遵守一定的规则。大家先看一下整个APT项目项目构建的一个规则图，具体如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-add6236329f14878.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="apt_rule.png"></p>
<h4 id="APT使用依赖"><a href="#APT使用依赖" class="headerlink" title="APT使用依赖"></a>APT使用依赖</h4><p>从图中我们可以整个APT项目的构建需要三个部分：</p>
<ul>
<li>注解处理器库(包含我们的注解处理器)</li>
<li>注解声明库(用于存储声明的注解)</li>
<li>实际使用APT的Android/Java项目</li>
</ul>
<p>且三个部分的依赖关系为<code>注解处理工具依赖注解声明库</code>，<code>Android/Java项目同时依赖注解处理工具库与注解声明库</code>。</p>
<h5 id="为什么把注解处理器独立抽成一个库呢？"><a href="#为什么把注解处理器独立抽成一个库呢？" class="headerlink" title="为什么把注解处理器独立抽成一个库呢？"></a>为什么把注解处理器独立抽成一个库呢？</h5><p>对于Android项目默认是不包含 APT相关类的。所以要使用APT技术，那么就必须创建一个Java Library。对于Java项目，独立抽成一个库，更容易维护与扩展。</p>
<h5 id="为什么把注解声明也单独抽成一个库，而不放到注解处理工具库中呢？"><a href="#为什么把注解声明也单独抽成一个库，而不放到注解处理工具库中呢？" class="headerlink" title="为什么把注解声明也单独抽成一个库，而不放到注解处理工具库中呢？"></a>为什么把注解声明也单独抽成一个库，而不放到注解处理工具库中呢？</h5><p>举个例子，如果注解声明与注解处理器为同一个库，如果有开发者希望把我们的注解处理器用于他的项目中，那么就必须包含注解声明与整个注解处理器的代码，我们能非常确定是，他并不希望已经编译好的项目中包含处理器相关的代码。他仅仅希望使用我们的注解。所以将注解处理器与注解分开单独抽成一个库时非常有意义的。接下来的文章中会具体会描述有哪些方法可以将我们的注解处理器不打包在我们的实际项目中。</p>
<h3 id="注解处理器的声明"><a href="#注解处理器的声明" class="headerlink" title="注解处理器的声明"></a>注解处理器的声明</h3><p>在了解了ATP的使用规则后，现在我们再来看看怎么声明一个注解处理器，每一个注解处理器都需要承<code>AbstractProcessor</code>类，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MineProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnv) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>init(ProcessingEnvironment processingEnv)</code>：每个注解处理器被初始化的时候都会被调用，该方法会被传入ProcessingEnvironment 参数。ProcessingEnvironment 能提供很多有用的工具类，Elements、Types和Filer。后面我们将会看到详细的内容。</li>
<li><code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</code>：注解处理器实际处理方法，一般要求子类实现该抽象方法，你可以在在这里写你的扫描与处理注解的代码，以及生成Java文件。其中参数RoundEnvironment ，可以让你查询出包含特定注解的被注解元素，后面我们会看到详细的内容。</li>
<li><code>getSupportedAnnotationTypes()</code>: 返回当前注解处理器处理注解的类型，返回值为一个字符串的集合。其中字符串为处理器需要处理的注解的<code>合法全称</code>。</li>
<li><code>getSupportedSourceVersion()</code>:用来指定你使用的Java版本，通常这里返回<code>SourceVersion.latestSupported()</code>。如果你有足够的理由指定某个Java版本的话，你可以返回SourceVersion.RELAEASE_XX。但是还是推荐使用前者。</li>
</ul>
<p>在Java1.6版本中提供了<code>SupportedAnnotationTypes</code>与<code>SupportedSourceVersion</code>两个注解来替代<code>getSupportedSourceVersion</code>与<code>getSupportedAnnotationTypes</code>两个方法，也就是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_6)</span><br><span class="line">@SupportedAnnotationTypes(&#123;&quot;合法注解的名称&quot;&#125;)</span><br><span class="line">class MineProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnv) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是以上提到的两个注解是JAVA 1.6新增的，所以出于兼容性的考虑，建议还是直接重写<code>getSupportedSourceVersion()</code>与<code>getSupportedAnnotationTypes()</code>方法。</p>
<h3 id="注册注解处理器"><a href="#注册注解处理器" class="headerlink" title="注册注解处理器"></a>注册注解处理器</h3><p>到了现在我们基本了解了处理器声明，现在我们可能会有个疑问，<code>怎么样将注解处理器注册到Java编译器中去呢？</code>你必须提供一个<code>.jar</code>文件，就像其他.jar文件一样，你需要打包你的注解处理器到此文件中，并且在你的jar中，你需要打包一个特定的文件<code>javax.annotation.processing.Processor</code>到<code>META-INF/services路径</code>下。就像下面这样：</p>
<blockquote>
<p>META-INF/services 相当于一个信息包，目录中的文件和目录获得Java平台的认可与解释用来配置应用程序、扩展程序、类加载器和服务文件，在jar打包时自动生成</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-4c3e9534ab7839c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="放入特定文件夹.png"></p>
<p>其中javax.annotation.processing.Processor文件中的内容为每个注解处理器的合法的全名列表，每一个元素换行分割，也就是类似下面这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.jennifer.andy.processor.MineProcessor1</span><br><span class="line">com.jennifer.andy.processor.MineProcessor2</span><br><span class="line">com.jennifer.andy.processor.MineProcessor3</span><br></pre></td></tr></table></figure></p>
<p>最后我们只要将你生成的<code>.jar</code>放到你的buildPath中，那么Java编译器会自动的检查和读取<code>javax.annotation.processing.Processor</code>中的内容，并注册该注解处理器。</p>
<p>当然对于现在我们的编译器，如IDEA、AndroidStudio等中，我们只创建相应文件与文件夹就行了，并不同用放在buildPath中去。当然原因是这些编译器都帮我们处理了啦。如果你还是嫌麻烦，那我们可以使用Google为我们提供的<code>AutoService</code><br>注解处理器，用于生成META-INF/services/javax.annotation.processing.Processor文件的。也就是我们可以像下面这样使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_6)</span><br><span class="line">@SupportedAnnotationTypes(&#123;&quot;合法注解的名称&quot;&#125;)</span><br><span class="line">@AutoService(Processor.class)</span><br><span class="line">class MineProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnv) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们只需要在类上声明<code>@AutoService(Processor.class)</code>，那么就不用考虑其他的东西啦。是不是很方便呢？（当然使用AutoService在Gralde中你需要添加依赖<code>compile &#39;com.google.auto.service:auto-service:1.0-rc2&#39;</code>）。</p>
<h3 id="注解处理器的扫描"><a href="#注解处理器的扫描" class="headerlink" title="注解处理器的扫描"></a>注解处理器的扫描</h3><p>在注解处理过程中，我们需要扫描所有的Java源文件，源代码的每一个部分都是一个特定类型的<code>Element</code>，也就是说Element代表源文件中的元素，例如包、类、字段、方法等。整体的关系如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-be96d0fe35599a5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="element继承关系.png"></p>
<ul>
<li>Parameterizable：表示混合类型的元素（不仅只有一种类型的Element)</li>
<li>TypeParameterElement：带有泛型参数的类、接口、方法或者构造器。</li>
<li>VariableElement：表示字段、常量、方法或构造函数。参数、局部变量、资源变量或异常参数。</li>
<li>QualifiedNameable：具有限定名称的元素</li>
<li>ExecutableElement：表示类或接口的方法、构造函数或初始化器（静态或实例），包括注释类型元素。</li>
<li>TypeElement :表示类和接口</li>
<li>PackageElement：表示包</li>
</ul>
<p>那接下来我们通过下面的例子来具体的分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.jennifer.andy.aptdemo.domain;//PackageElement</span><br><span class="line">class Person &#123;//TypeElement </span><br><span class="line">    private String where;//VariableElement</span><br><span class="line">    </span><br><span class="line">    public void doSomething() &#123; &#125;//ExecutableElement</span><br><span class="line">    </span><br><span class="line">    public void run() &#123;//ExecutableElement</span><br><span class="line">        int runTime;//VariableElement</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上述例子我们可以看出，APT对整个源文件的扫描。有点类似于我们解析XML文件（这种结构化文本一样）。</p>
<p>既然在扫描的时候，<code>源文件是一种结构化的数据</code>，那么我们能不能获取一个元素的父元素和子元素呢？。当然是可以的啦，举例来说，假如我们有个<code>public class Person的TypeElement元素</code>，那么我们可以遍历它的所有的孩子元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TypeElement person= ... ;  </span><br><span class="line">for (Element e : person.getEnclosedElements())&#123; // 遍历它的孩子 </span><br><span class="line">    Element parent = e.getEnclosingElement();  // 拿到孩子元素的最近的父元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>getEnclosedElements()</code>与<code>getEnclosingElement()</code>为<code>Element</code>中接口的声明，想了解更多的内容，大家可以查看一下源码。</p>
<h4 id="元素种类判断"><a href="#元素种类判断" class="headerlink" title="元素种类判断"></a>元素种类判断</h4><p>现在我们已经了解了<code>Element</code>元素的分类，但是我们发现Element有时会代表多种元素。例如<code>TypeElement代表类或接口</code>，那有什么方法具体区别呢？我们继续看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SpiltElementProcessor extends AbstractProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">	    //这里通过获取所有包含Who注解的元素set集合</span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(Who.class);</span><br><span class="line">        for (Element element : elements) &#123;</span><br><span class="line">            if (element.getKind() == ElementKind.CLASS) &#123;//如果元素是类</span><br><span class="line"></span><br><span class="line">            &#125; else if (element.getKind() == ElementKind.INTERFACE) &#123;//如果当前元素是接口</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	...省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，我们通过<code>roundEnvironment.getElementsAnnotatedWith(Who.class)</code>获取源文件中所有包含<code>@Who</code>注解的元素，通过调用element.getKind()具体判断当前元素种类，其中具体元素类型为<code>ElementKind枚举类型</code>。<code>ElementKind</code>枚举声明如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">枚举类型</th>
<th style="text-align:center">种类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PACKAGE</td>
<td style="text-align:center">包</td>
</tr>
<tr>
<td style="text-align:center">ENUM</td>
<td style="text-align:center">枚举</td>
</tr>
<tr>
<td style="text-align:center">CLASS</td>
<td style="text-align:center">类</td>
</tr>
<tr>
<td style="text-align:center">ANNOTATION_TYPE</td>
<td style="text-align:center">注解</td>
</tr>
<tr>
<td style="text-align:center">INTERFACE</td>
<td style="text-align:center">接口</td>
</tr>
<tr>
<td style="text-align:center">ENUM_CONSTANT</td>
<td style="text-align:center">枚举常量</td>
</tr>
<tr>
<td style="text-align:center">FIELD</td>
<td style="text-align:center">字段</td>
</tr>
<tr>
<td style="text-align:center">PARAMETER</td>
<td style="text-align:center">参数</td>
</tr>
<tr>
<td style="text-align:center">LOCAL_VARIABLE</td>
<td style="text-align:center">本地变量</td>
</tr>
<tr>
<td style="text-align:center">EXCEPTION_PARAMETER</td>
<td style="text-align:center">异常参数</td>
</tr>
<tr>
<td style="text-align:center">METHOD</td>
<td style="text-align:center">方法</td>
</tr>
<tr>
<td style="text-align:center">CONSTRUCTOR</td>
<td style="text-align:center">构造函数</td>
</tr>
<tr>
<td style="text-align:center">OTHER</td>
<td style="text-align:center">其他</td>
</tr>
<tr>
<td style="text-align:center">省略…</td>
<td style="text-align:center">省略…</td>
</tr>
</tbody>
</table>
<h4 id="元素类型判断"><a href="#元素类型判断" class="headerlink" title="元素类型判断"></a>元素类型判断</h4><p>那接下来大家又会有一个问题了，既然我们在扫描的是获取的元素且这些元素代表着源文件中的结构化数据。那么假如我们想获得元素更多的信息怎么办呢？例如对于某个类，现在我们已经知道了其为<code>ElementKind.CLASS</code>种类，但是我想获取其父类的信息，需要通过什么方式呢？对于某个方法，我们也同样知道了其为<code>ElementKind.METHOD</code>种类，那么我想获取该方法的返回值类型、参数类型、参数名称，需要通过什么方式呢？</p>
<p>当然Java已经为我们提供了相应的方法啦。使用<code>mirror API</code>就能解决这些问题啦，<code>它能使我们在未经编译的源代码中查看方法、域以及类型信息</code>。在实际使用中通过<code>TypeMirror</code>来获取元素类型。看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TypeKindSpiltProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(Who.class);</span><br><span class="line">        for (Element element : elements) &#123;</span><br><span class="line">            if (element.getKind() == ElementKind.METHOD) &#123;//如果当前元素是接口</span><br><span class="line">                ExecutableElement methodElement = (ExecutableElement) element;</span><br><span class="line">                TypeMirror returnType = methodElement.getReturnType();//获取TypeMirror</span><br><span class="line">                TypeKind kind = returnType.getKind();//获取元素类型</span><br><span class="line">                System.out.println(&quot;print return type-----&gt;&quot; + kind.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>观察上述代码我们可以发现，当我们使用注解处理器时，我们会先找到相应的Element，如果你想获得该Element的更多的信息，那么可以配合TypeMirror使用<code>TypeKind</code>来判断当前元素的类型。当然对于不同种类的Element，其获取的TypeMirror方法可能会不同。<code>TypeKind</code>枚举声明如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">枚举类型</th>
<th style="text-align:center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BOOLEAN</td>
<td style="text-align:center">boolean 类型</td>
</tr>
<tr>
<td style="text-align:center">BYTE</td>
<td style="text-align:center">byte 类型</td>
</tr>
<tr>
<td style="text-align:center">SHORT</td>
<td style="text-align:center">short 类型</td>
</tr>
<tr>
<td style="text-align:center">INT</td>
<td style="text-align:center">int 类型</td>
</tr>
<tr>
<td style="text-align:center">LONG</td>
<td style="text-align:center">long 类型</td>
</tr>
<tr>
<td style="text-align:center">CHAR</td>
<td style="text-align:center">char 类型</td>
</tr>
<tr>
<td style="text-align:center">FLOAT</td>
<td style="text-align:center">float 类型</td>
</tr>
<tr>
<td style="text-align:center">DOUBLE</td>
<td style="text-align:center">double 类型</td>
</tr>
<tr>
<td style="text-align:center">VOID</td>
<td style="text-align:center">void类型，主要用于方法的返回值</td>
</tr>
<tr>
<td style="text-align:center">NONE</td>
<td style="text-align:center">无类型</td>
</tr>
<tr>
<td style="text-align:center">NULL</td>
<td style="text-align:center">空类型</td>
</tr>
<tr>
<td style="text-align:center">ARRAY</td>
<td style="text-align:center">数组类型</td>
</tr>
<tr>
<td style="text-align:center">省略…</td>
<td style="text-align:center">省略…</td>
</tr>
</tbody>
</table>
<h4 id="元素可见性修饰符"><a href="#元素可见性修饰符" class="headerlink" title="元素可见性修饰符"></a>元素可见性修饰符</h4><p>在注解处理器中，我们不仅能获得元素的种类和信息，我们还能获取该元素的可见性修饰符（例如public、private等）。我们可以直接调用<code>Element.getModifiers()</code>，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class GetModifiersProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(Who.class);</span><br><span class="line">        for (Element element : elements) &#123;</span><br><span class="line">            if (element.getKind() == ElementKind.CLASS) &#123;//如果元素是类</span><br><span class="line">                Set&lt;Modifier&gt; modifiers = element.getModifiers();//获取可见性修饰符</span><br><span class="line">                if (!modifiers.contains(Modifier.PUBLIC)) &#123;//如果当前类不是public</span><br><span class="line">                    throw new ProcessingException(classElement, &quot;The class %s is not public.&quot;,</span><br><span class="line">                            classElement.getQualifiedName().toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中<code>Modifer为枚举类型</code>，具体枚举如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public enum Modifier &#123;</span><br><span class="line"></span><br><span class="line">    /** The modifier &#123;@code public&#125; */          PUBLIC,</span><br><span class="line">    /** The modifier &#123;@code protected&#125; */       PROTECTED,</span><br><span class="line">    /** The modifier &#123;@code private&#125; */         PRIVATE,</span><br><span class="line">    /** The modifier &#123;@code abstract&#125; */        ABSTRACT,</span><br><span class="line">    /**</span><br><span class="line">     * The modifier &#123;@code default&#125;</span><br><span class="line">     * @since 1.8</span><br><span class="line">     */</span><br><span class="line">     DEFAULT,</span><br><span class="line">    /** The modifier &#123;@code static&#125; */          STATIC,</span><br><span class="line">    /** The modifier &#123;@code final&#125; */           FINAL,</span><br><span class="line">    /** The modifier &#123;@code transient&#125; */       TRANSIENT,</span><br><span class="line">    /** The modifier &#123;@code volatile&#125; */        VOLATILE,</span><br><span class="line">    /** The modifier &#123;@code synchronized&#125; */    SYNCHRONIZED,</span><br><span class="line">    /** The modifier &#123;@code native&#125; */          NATIVE,</span><br><span class="line">    /** The modifier &#123;@code strictfp&#125; */        STRICTFP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在注解处理器的自定义中，我们不仅能调用相关方法获取源文件中的元素信息，还能通过处理器提供的<code>Messager</code>来报告错误、警告以及提示信息。可以直接使用<code>processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, msg);</code>需要注意的是它并不是处理器开发中的日志工具，而是用来写一些信息给使用此注解库的第三方开发者的。也就是说如果我们像传统的Java应用程序抛出一个异常的话，那么运行注解处理器的JVM就会崩溃，并且关于JVM中的错误信息对于第三方开发者并不是很友好，所以推荐并且强烈建议使用<code>Messager</code>。就像下面这样，当我们判断某个类不是public修饰的时候，我们通过<code>Messager</code>来报告错误。</p>
<blockquote>
<p>注解处理器是运行它自己的虚拟机JVM中。是的，你没有看错，javac启动一个完整Java虚拟机来运行注解处理器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class GetModifiersProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(Who.class);</span><br><span class="line">        for (Element element : elements) &#123;</span><br><span class="line">            if (element.getKind() == ElementKind.CLASS) &#123;//如果元素是类</span><br><span class="line">                Set&lt;Modifier&gt; modifiers = element.getModifiers();//获取可见性修饰符</span><br><span class="line">                if (!modifiers.contains(Modifier.PUBLIC)) &#123;//如果当前类不是public</span><br><span class="line">	                roundEnvironment.getMessager().printMessage(Diagnostic.Kind.ERROR, &quot;the class is not public&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>同时，在<a href="https://docs.oracle.com/javase/7/docs/api/javax/tools/Diagnostic.Kind.html" target="_blank" rel="noopener">官方文档</a>中，描述了消息的不同级别，关于更多的消息级别，大家可以通过从<code>Diagnostic.Kind</code>枚举中查看。</p>
<h3 id="文件生成"><a href="#文件生成" class="headerlink" title="文件生成"></a>文件生成</h3><p>到了现在我们已经基本了解整个APT的基础知识。现在来讲讲APT技术如何<code>生成新的类的定义（也就是创建新的源文件）</code>。对于创建新的文件，我们并不用像基本文件操作一样，通过调用IO流来进行读写操作。而是通过<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a>来构造源文件。（当然当你使用<code>JavaPoet</code>时，在gradle中你需要添加依赖<code>compile &#39;com.google.auto.service:auto-service:1.0-rc2&#39;</code>)，<code>JavaPoet</code>的使用也非常简单，就像下面这样：</p>
<blockquote>
<p>当进行注释处理或与元数据文件（例如，数据库模式、协议格式）交互时，JavaPoet对于源文件的生成可能非常有用。通过生成代码，消除了编写样板的必要性，同时也保持了元数据的单一来源。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br><span class="line">@SupportedAnnotationTypes(&quot;com.jennifer.andy.apt.annotation.Who&quot;)</span><br><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_7)</span><br><span class="line">public class CreateFileByJavaPoetProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        createFileByJavaPoet(set, roundEnvironment);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 通过JavaPoet生成新的源文件</span><br><span class="line">     */</span><br><span class="line">    private void createFileByJavaPoet(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        //创建main方法</span><br><span class="line">        MethodSpec main = MethodSpec.methodBuilder(&quot;main&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)//设置可见性修饰符public static</span><br><span class="line">                .returns(void.class)//设置返回值为void</span><br><span class="line">                .addParameter(String[].class, &quot;args&quot;)//添加参数类型为String数组，且参数名称为args</span><br><span class="line">                .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)//添加语句</span><br><span class="line">                .build();</span><br><span class="line">        //创建类</span><br><span class="line">        TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(main)//将main方法添加到HelloWord类中</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        //创建文件，第一个参数是包名，第二个参数是相关类</span><br><span class="line">        JavaFile javaFile = JavaFile.builder(&quot;com.jennifer.andy.aptdemo.domain&quot;, helloWorld)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //创建文件</span><br><span class="line">            javaFile.writeTo(processingEnv.getFiler());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 调用打印语句而已</span><br><span class="line">     */</span><br><span class="line">    private void log(String msg) &#123;</span><br><span class="line">        processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们build上述代码后，我们可以在我们的build目录下得到下列文件：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-94edf5bddf649087.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成文件结果.png"></p>
<p>关于JavaPoet的更多的详细使用，大家可以参考官方文档——–&gt;<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a></p>
<h3 id="分离处理器和项目"><a href="#分离处理器和项目" class="headerlink" title="分离处理器和项目"></a>分离处理器和项目</h3><p>在上文中描述的APT使用规则中，我们是将<code>注解声明库</code>与<code>注解处理器库</code>分成了两个库，具体原因我也做了详细的解释，现在我们来思考如下问题。就算我们把两个库都抽成了两个独立的库，但是如果有开发者想把我们自定义的注解处理器用于他的项目中，那么他整个项目的编译就必须也要把注解处理器与注解声明库包括进来。对于开发者来说，他们并不希望已经编译好的项目中有包含注解处理器的相关代码。所以将<code>注解声明库与注解处理器库不打包进入项目是非常有必要的！！</code>换句话说，注解处理器只在编译处理期间需要用到，编译处理完后就没有实际作用了，而主项目添加了这个库会引入很多不必要的文件。</p>
<p><code>因为作者我本身是Android开发人员，所以以下都是针对Android项目展开讨论。</code></p>
<h4 id="使用android-apt"><a href="#使用android-apt" class="headerlink" title="使用android-apt"></a>使用android-apt</h4><p><a href="https://bitbucket.org/hvisser/android-apt" target="_blank" rel="noopener">anroid-apt</a>是Hugo Visser开发的一个Gradle插件，该插件的主要作用有如下两点：</p>
<ul>
<li>允许只将编译时注释处理器配置为依赖项，而不在最终APK或库中包括工件</li>
<li>设置源路径，以便Android Studio能正确地找到注释处理器生成的代码</li>
</ul>
<p>但是 Google爸爸看到别人这个功能功能不错，所以为自己的Android Gradle 插件也添加了名为<code>annotationProcessor</code> 的功能来完全代替 android-apt，既然官方支持了。那我们就去看看annotationProcessor的使用吧。</p>
<h4 id="annotationProcessor使用"><a href="#annotationProcessor使用" class="headerlink" title="annotationProcessor使用"></a>annotationProcessor使用</h4><p>其实annotationProcessor的使用也非常简单，分为两种类型，具体使用如下代码所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">annotationProcessor project(&apos;:apt_compiler&apos;)//如果是本地库</span><br><span class="line">annotationProcessor &apos;com.jakewharton:butterknife-compiler:9.0.0-rc1&apos;//如果是远程库</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个APT的流程下来，自己也查阅了非常多的资料，也解决了许多问题。虽然写博客也花了非常多的时间。但是自己也发现了很多有趣的问题。我发现查阅的相关资料都会有一个<code>通病</code>。也就是没有真正搞懂<code>android apt与annotationProcessor</code>的具体作用。所以这里这里也要告诫大家，<code>对于网上的资料，自己一定要带着怀疑与疑问的态度去浏览</code>。</p>
<p>同时个人觉得Gradle这一块的知识点也非常重要。因为关于怎么不把库打包到实际项目中也是构建工具的特性与功能。希望大家有时间，<code>一定要学习下相关Gradle知识</code>。作者最近也在学习呢。和我一起加油吧~</p>
<blockquote>
<p>该文章中涉及的代码，我已经提交到GitHub上了，大家按需下载—-&gt;<a href="https://github.com/AndyJennifer/AptDemo" target="_blank" rel="noopener">源码</a></p>
</blockquote>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>该文章参考以下博客与图书，站在巨人的肩膀上。可以看得更远。</p>
<p><a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="noopener">ANNOTATION PROCESSING 101</a></p>
<p><a href="https://blog.csdn.net/github_35180164/article/details/52121038" target="_blank" rel="noopener">自定义注解之编译时注解(RetentionPolicy.CLASS)</a></p>
<p><a href="https://blog.csdn.net/xx326664162/article/details/68490059" target="_blank" rel="noopener">你必须知道的APT、annotationProcessor、android-apt、Provided、自定义注解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Android-注解系列之APT工具（三）/" data-id="cjsheb871000sdsr79n18t3yo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android-Handler机制之ThreadLocal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Android-Handler机制之ThreadLocal/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-04bd2a2f4dcf1849.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小积木.jpg"></p>
<blockquote>
<p>该文章属于Android Handler系列文章，如果想了解更多，请点击<br><a href="https://www.jianshu.com/p/43bb31d8a742" target="_blank" rel="noopener">《Android Handler机制之总目录》</a></p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>要想了解Android 的Handle机制，我们首先要了解ThreadLocal，根据字面意思我们都能猜出个大概。就是线程本地变量。那么我们把变量存储在本地有什么好处呢？其中的原理又是什么呢？下面我们就一起来讨论一下ThreadLocal的使用与原理。</p>
<h3 id="ThreadLocal简单介绍"><a href="#ThreadLocal简单介绍" class="headerlink" title="ThreadLocal简单介绍"></a>ThreadLocal简单介绍</h3><p>该类提供线程局部变量。这些变量不同于它们的正常变量，即每一个线程访问自身的局部变量时，都有它自己的，独立初始化的副本。该变量通常是与线程关联的私有静态字段，列如用于ID或事物ID。大家看了介绍后，有可能还是不了解其主要的主要作用，简单的画个图帮助大家理解。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-550960f5459468ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ThreadLocal示意图.png"></p>
<p>从图上可以看出，通过ThreadLocal，每个线程都能获取自己线程内部的私有变量，有可能大家觉得无图无真相，“你一个人在那里神吹，我怎么知道你说的对还是不对呢？”，下面我们通过具体的例子详细的介绍，来看下面的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class ThreadLocalTest &#123;</span><br><span class="line">	//会出现内存泄漏的问题，下文会描述</span><br><span class="line">    private static ThreadLocal&lt;String&gt; mThreadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        mThreadLocal.set(&quot;线程main&quot;);</span><br><span class="line">        new Thread(new A()).start();</span><br><span class="line">        new Thread(new B()).start();</span><br><span class="line">        System.out.println(mThreadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class A implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            mThreadLocal.set(&quot;线程A&quot;);</span><br><span class="line">            System.out.println(mThreadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class B implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            mThreadLocal.set(&quot;线程B&quot;);</span><br><span class="line">            System.out.println(mThreadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上诉代码中，我们在主线程中设置mThreadLocal的值为”线程main”,在线程A中设置为”线程A“，在线程B中设置为”线程B”,运行程序打印结果如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">线程A</span><br><span class="line">线程B</span><br></pre></td></tr></table></figure>
<p>从上面结果可以看出，虽然是在不同的线程中访问的同一个变量mThreadLocal，但是他们通过ThreadLocl获取到的值却是不一样的。也就验证了上面我们所画的图是正确的了，那么现在，我们已经知道了ThreadLocal的用法，那么我们现在来看看其中的内部原理。</p>
<h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><p>为了帮助大家快速的知晓ThreadLocal原理，这里我将ThreadLocal的原理用下图表示出来了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-7b553ff229bcd302.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="threadLocal.png"></p>
<p>在上图中我们可以发现，整个ThreadLocal的使用都涉及到线程中<code>ThreadLocalMap</code>,虽然我们在外部调用的是ThreadLocal.set(value)方法，但本质是通过线程中的<code>ThreadLocalMap中的set(key,value)方法</code>，那么通过该情况我们大致也能猜出get方法也是通过ThreadLocalMap。那么接下来我们一起来看看ThreadLocal中set与get方法的具体实现与ThreadLocalMap的具体结构。</p>
<h3 id="ThreadLocal的set方法"><a href="#ThreadLocal的set方法" class="headerlink" title="ThreadLocal的set方法"></a>ThreadLocal的set方法</h3><p>在使用ThreadLocal时，我们会调用ThreadLocal的set(T value)方法对线程中的私有变量设置，我们来查看ThreadLocal的set方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();//获取当前线程</span><br><span class="line">    ThreadLocalMap map = getMap(t);//拿到线程的LocalMap</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);//设值 key-&gt;当前ThreadLocal对象。value-&gt;为当前赋的值</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);//创建新的ThreadLocalMap并设值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当调用set(T value) 方法时，方法内部会获取当前线程中的ThreadLocalMap，获取后进行判断，如果不为空，就<strong>调用ThreadLocalMap的set方法</strong>（其中key为当前ThreadLocal对象，value为当前赋的值）。反之，让当前线程创建新的ThreadLocalMap并设值，其中getMap()与createMap()方法具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">      return t.threadLocals;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">      t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>简简单单的通过ThreadLocalMap的set()方法，我们已经大致了解了。ThreadLocal为什么能操作线程内的私有数据了，ThreadLocal中所有的数据操作都与线程中的ThreadLocalMap有关，同时那我们接下来看看ThreadLocalMap相关代码。</p>
<h4 id="ThreadLocalMap-内部结构"><a href="#ThreadLocalMap-内部结构" class="headerlink" title="ThreadLocalMap 内部结构"></a>ThreadLocalMap 内部结构</h4><p>ThreadLocalMap是ThreadLocal中的一个静态内部类，官方的注释写的很全面，这里我大概的翻译了一下，<strong>ThreadLocalMap是为了维护线程私有值创建的自定义哈希映射。其中线程的私有数据都是非常大且使用寿命长的数据</strong>(其实想一想，为什么要存储这些数据呢，第一是为了把常用的数据放入线程中提高了访问的速度，第二是如果数据是非常大的，避免了该数据频繁的创建，不仅解决了存储空间的问题，也减少了不必要的IO消耗)。</p>
<p>ThreadLocalMap 具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line">	//存储的数据为Entry,且key为弱引用</span><br><span class="line">       static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">           /** The value associated with this ThreadLocal. */</span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               super(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //table初始容量</span><br><span class="line">       private static final int INITIAL_CAPACITY = 16;</span><br><span class="line">     </span><br><span class="line">       //table 用于存储数据</span><br><span class="line">       private Entry[] table;</span><br><span class="line">       </span><br><span class="line">    //负载因子，用于数组容量扩容</span><br><span class="line">       private int threshold; // Default to 0</span><br><span class="line">       </span><br><span class="line">	//负载因子，默认情况下为当前数组长度的2/3</span><br><span class="line">       private void setThreshold(int len) &#123;</span><br><span class="line">           threshold = len * 2 / 3;</span><br><span class="line">       &#125;</span><br><span class="line">    //第一次放入Entry数据时，初始化数组长度，定义扩容阀值，</span><br><span class="line">       ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">           table = new Entry[INITIAL_CAPACITY];//初始化数组长度为16</span><br><span class="line">           int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">           table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">           size = 1;</span><br><span class="line">           setThreshold(INITIAL_CAPACITY);//阀值为当前数组默认长度的2/3</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看出，虽然官方申明为ThreadLocalMap是一个哈希表，但是它与我们传统认识的HashMap等哈希表内部结构是不一样的。ThreadLocalMap内部仅仅维护了<strong>Entry[] table,</strong>数组。其中<strong>Entry实体中对应的key为弱引用（下文会将为什么会用弱引用）</strong>，在第一次放入数据时，会初始化数组长度（为16),定义数组扩容阀值（当前默认数组长度的2/3)。</p>
<h4 id="ThreadLocalMap-的set-方法"><a href="#ThreadLocalMap-的set-方法" class="headerlink" title="ThreadLocalMap 的set()方法"></a>ThreadLocalMap 的set()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">	    //根据哈希值计算位置</span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           int len = tab.length;</span><br><span class="line">           int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">           </span><br><span class="line">           //判断当前位置是否有数据，如果key值相同，就替换，如果不同则找空位放数据。</span><br><span class="line">           for (Entry e = tab[i];</span><br><span class="line">                e != null;</span><br><span class="line">                e = tab[i = nextIndex(i, len)]) &#123;//获取下一个位置的数据</span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">		//判断key值相同否，如果是直接覆盖 （第一种情况）</span><br><span class="line">               if (k == key) &#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">		//如果当前Entry对象对应Key值为null,则清空所有Key为null的数据（第二种情况）</span><br><span class="line">               if (k == null) &#123;</span><br><span class="line">                   replaceStaleEntry(key, value, i);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //以上情况都不满足，直接添加（第三种情况）</span><br><span class="line">           tab[i] = new Entry(key, value);</span><br><span class="line">           int sz = ++size;</span><br><span class="line">           if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)//如果当前数组到达阀值，那么就进行扩容。</span><br><span class="line">               rehash();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>直接通过代码理解比较困难,这里直接将set方法分为了三个步骤，下面我们我们就分别对这个三个步骤，分别通过图与代码的方式讲解。</p>
<h5 id="第一种情况，-Key值相同"><a href="#第一种情况，-Key值相同" class="headerlink" title="第一种情况， Key值相同"></a>第一种情况， Key值相同</h5><p>如果当前数组中，如果当前位置对应的Entry的key值与新添加的Entry的key值相同，直接进行覆盖操作。具体情况如下图所示</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-70b6cc18bc656b19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="key值相同情况.png"></p>
<p>如果当前数组中。存在key值相同的情况，ThreadLocal内部操作是直接覆盖的。这种情况就不过多的介绍了。</p>
<h5 id="第二种情况，如果当前位置对应Entry的Key值为null"><a href="#第二种情况，如果当前位置对应Entry的Key值为null" class="headerlink" title="第二种情况，如果当前位置对应Entry的Key值为null"></a>第二种情况，如果当前位置对应Entry的Key值为null</h5><p>第二种情况相对来说比较复杂，这里先给图，然后会根据具体代码来讲解。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-7bdc448fcc55fc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对应位置Key值为null.png"></p>
<p>从图中我们可以看出来。当我们添加新Entry(key=19,value =200,index = 3)时，数组中已经存在旧Entry(key =null,value = 19),当出现这种情况是，方法内部会将新Entry的值全部赋值到旧Entry中，<strong>同时会将所有数组中key为null的Entry全部置为null（图中大黄色数据）</strong>。在源码中，当新Entry对应位置存在数据，且key为null的情况下，会走<code>replaceStaleEntry</code>方法。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="line">                                    int staleSlot) &#123;</span><br><span class="line">         Entry[] tab = table;</span><br><span class="line">         int len = tab.length;</span><br><span class="line">         Entry e;</span><br><span class="line"></span><br><span class="line">      //记录当前要清除的位置</span><br><span class="line">         int slotToExpunge = staleSlot;</span><br><span class="line">         </span><br><span class="line">         //往前找，找到第一个过期的Entry(key为空)</span><br><span class="line">         for (int i = prevIndex(staleSlot, len);</span><br><span class="line">              (e = tab[i]) != null;</span><br><span class="line">              i = prevIndex(i, len))</span><br><span class="line">             if (e.get() == null)//判断引用是否为空，如果为空,擦除的位置为第一个过期的Entry的位置</span><br><span class="line">                 slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">   //往后找，找到最后一个过期的Entry(key为空)，</span><br><span class="line">         for (int i = nextIndex(staleSlot, len);//这里要注意获得位置有可能为0，</span><br><span class="line">              (e = tab[i]) != null;</span><br><span class="line">              i = nextIndex(i, len)) &#123;</span><br><span class="line">             ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">             //在往后找的时候，如果获取key值相同的。那么就重新赋值。</span><br><span class="line">             if (k == key) &#123;</span><br><span class="line">             	//赋值到之前传入的staleSlot对应的位置</span><br><span class="line">                 e.value = value;</span><br><span class="line">                 tab[i] = tab[staleSlot];</span><br><span class="line">                 tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                 //如果往前找的时候，没有过期的Entry,那么就记录当前的位置（往后找相同key的位置）</span><br><span class="line">                 if (slotToExpunge == staleSlot)</span><br><span class="line">                     slotToExpunge = i;</span><br><span class="line">                     </span><br><span class="line">                 //那么就清除slotToExpunge位置下所有key为null的数据</span><br><span class="line">                 cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">    //如果往前找的时候，没有过期的Entry,且key =null那么就记录当前的位置（往后找key==null位置）</span><br><span class="line">             if (k == null &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                 slotToExpunge = i;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // 把当前key为null的对应的数据置为null，并创建新的Entry在该位置上</span><br><span class="line">         tab[staleSlot].value = null;</span><br><span class="line">         tab[staleSlot] = new Entry(key, value);</span><br><span class="line"></span><br><span class="line">         //如果往后找，没有过期的实体， </span><br><span class="line">         //且staleSlot之前能找到第一个过期的Entry(key为空)，</span><br><span class="line">         //那么就清除slotToExpunge位置下所有key为null的数据</span><br><span class="line">         if (slotToExpunge != staleSlot)</span><br><span class="line">             cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码看起来比较繁杂，但是大家仔细梳理就会发现其实该方法，主要对四种情况进行了判断，具体情况如下图表所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-218dc09b044027f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TIM截图20180731110649.png"></p>
<p>我们已经了解了replaceStaleEntry方法内部会清除key==null的数据，而其中具体的方法与expungeStaleEntry()方法与cleanSomeSlots()方法有关，所以接下来我们来分析这两个方法。看看其的具体实现。</p>
<p> <strong>expungeStaleEntry ()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        int len = tab.length;</span><br><span class="line"></span><br><span class="line">        // 将staleSlot位置下的数据置为null</span><br><span class="line">        tab[staleSlot].value = null;</span><br><span class="line">        tab[staleSlot] = null;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        Entry e;</span><br><span class="line">        int i;</span><br><span class="line">        //往后找。</span><br><span class="line">        for (i = nextIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != null;</span><br><span class="line">             i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            if (k == null) &#123;//清除key为null的数据</span><br><span class="line">                e.value = null;</span><br><span class="line">                tab[i] = null;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            //如果key不为null,但是该key对应的threadLocalHashCode发生变化，</span><br><span class="line">            //计算位置，并将元素放入新位置中。</span><br><span class="line">                int h = k.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                if (h != i) &#123;</span><br><span class="line">                    tab[i] = null;</span><br><span class="line">                    while (tab[h] != null)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    tab[h] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i;//返回最后一个tab[i]) != null的位置</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>expungeStaleEntry（）方法主要干了三件事，第一件，将staleSlot的位置对应的数据置为null,第二件,删除并删除此位置后对应相关联位置key = null的数据。第三件，如果如果key不为null,但是该key对应的threadLocalHashCode发生变化，计算变化后的位置，并将元素放入新位置中。</p>
<p><strong>cleanSomeSlots（）方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private boolean cleanSomeSlots(int i, int n) &#123;</span><br><span class="line">        boolean removed = false;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        int len = tab.length;</span><br><span class="line">        do &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">            Entry e = tab[i];</span><br><span class="line">            if (e != null &amp;&amp; e.get() == null) &#123;</span><br><span class="line">                n = len;</span><br><span class="line">                removed = true;</span><br><span class="line">                i = expungeStaleEntry(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while ( (n &gt;&gt;&gt;= 1) != 0);</span><br><span class="line">        return removed;//如果有过期的数据被删除,就返回true,反之false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在了解了expungeStaleEntry（）方法后，再来理解cleanSomeSlots（）方法就很简单了。其中第一个参数表示开始扫描的位置，第二个参数是扫描的长度。从代码我们明显的看出。就是简单的遍历删除所有位置下key==null的数据。</p>
<h5 id="第三种情况，当前对应位置为null"><a href="#第三种情况，当前对应位置为null" class="headerlink" title="第三种情况，当前对应位置为null"></a>第三种情况，当前对应位置为null</h5><p><img src="https://upload-images.jianshu.io/upload_images/2824145-b33d9fa695210adf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="没有数据的情况.png"></p>
<p><strong>图上为了方便大家，理解清空上下数据的情况，我并没有重新计算位置（希望大家注意！！！）</strong></p>
<p>看到这里，为了方便大家避免不必要的查阅代码，我直接将代码贴出来了。代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tab[i] = new Entry(key, value);</span><br><span class="line">int sz = ++size;</span><br><span class="line">if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br></pre></td></tr></table></figure></p>
<p>从上述代码其实，大家很明显的看出来，就是清除key==null的数据，判断当前数据的长度是不是到达阀值（默认没扩容前为INITIAL_CAPACITY *2/3，其中INITIAL_CAPACITY = 16），如果达到了重新计算数据的位置。关于rehash()方法，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private void rehash() &#123;</span><br><span class="line">        expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">        // Use lower threshold for doubling to avoid hysteresis</span><br><span class="line">        if (size &gt;= threshold - threshold / 4)</span><br><span class="line">               resize();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">//清空所有key==null的数据</span><br><span class="line">private void expungeStaleEntries() &#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        int len = tab.length;</span><br><span class="line">        for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">            Entry e = tab[j];</span><br><span class="line">            if (e != null &amp;&amp; e.get() == null)</span><br><span class="line">                expungeStaleEntry(j);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">//重新计算key!=null的数据。新的数组长度为之前的两倍      </span><br><span class="line">private void resize() &#123;</span><br><span class="line">		//对原数组进行扩容，容量为之前的两倍</span><br><span class="line">           Entry[] oldTab = table;</span><br><span class="line">           int oldLen = oldTab.length;</span><br><span class="line">           int newLen = oldLen * 2;</span><br><span class="line">           Entry[] newTab = new Entry[newLen];</span><br><span class="line">           int count = 0;</span><br><span class="line">		//重新计算位置</span><br><span class="line">           for (int j = 0; j &lt; oldLen; ++j) &#123;</span><br><span class="line">               Entry e = oldTab[j];</span><br><span class="line">               if (e != null) &#123;</span><br><span class="line">                   ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                   if (k == null) &#123;</span><br><span class="line">                       e.value = null; // Help the GC</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       int h = k.threadLocalHashCode &amp; (newLen - 1);</span><br><span class="line">                       while (newTab[h] != null)</span><br><span class="line">                           h = nextIndex(h, newLen);</span><br><span class="line">                       newTab[h] = e;</span><br><span class="line">                       count++;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">		//重新计算阀值（负载因子）为扩容之后的数组长度的2/3</span><br><span class="line">           setThreshold(newLen);</span><br><span class="line">           size = count;</span><br><span class="line">           table = newTab;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>rehash内部所有涉及到的方法，我都列举出来了。可以看出在添加数据的时候，会进行判断是否扩容操作，如果需要扩容，会清除所有的key==null的数据，（也就是调用expungeStaleEntries（）方法，其中expungeStaleEntry（）方法已经介绍了，就不过多描述），同时会重新计算数据中的位置。</p>
<h3 id="ThreadLocal的get-方法"><a href="#ThreadLocal的get-方法" class="headerlink" title="ThreadLocal的get()方法"></a>ThreadLocal的get()方法</h3><p>在了解了ThreadLocal的set()方法之后，我们看看怎么获取ThreadLocal中的数据，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">      Thread t = Thread.currentThread();//获取当前线程</span><br><span class="line">      ThreadLocalMap map = getMap(t);//拿到线程中的Map</span><br><span class="line">      if (map != null) &#123;</span><br><span class="line">          //根据key值（ThreadLocal）对象，获取存储的数据</span><br><span class="line">          ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">          if (e != null) &#123;</span><br><span class="line">              @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">              T result = (T)e.value;</span><br><span class="line">              return result;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //如果ThreadLocalMap为空，创建新的ThreadLocalMap </span><br><span class="line">      return setInitialValue();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>其实ThreadLocal的get方法其实很简单，就是获取当前线程中的ThreadLocalMap对象，如果没有则创建，如果有，则根据当前的 key(当前ThreadLocal对象)，获取相应的数据。其中内部调用了ThreadLocalMap的getEntry（）方法区获取数据，我们继续查看getEntry（）方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">           int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">           Entry e = table[i];</span><br><span class="line">           if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">               return e;</span><br><span class="line">           else</span><br><span class="line">               return getEntryAfterMiss(key, i, e);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>getEntry（）方法内部也很简单，也只是根据当前key哈希后计算的位置，去找数组中对应位置是否有数据，如果有，直接将数据放回，如果没有，则调用getEntryAfterMiss（）方法，我们继续往下看 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           int len = tab.length;</span><br><span class="line"></span><br><span class="line">           while (e != null) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">               if (k == key)//如果key相同，直接返回</span><br><span class="line">                   return e;</span><br><span class="line">               if (k == null)//如果key==null,清除当前位置下所有key=null的数据。</span><br><span class="line">                   expungeStaleEntry(i);</span><br><span class="line">               else</span><br><span class="line">                   i = nextIndex(i, len);</span><br><span class="line">               e = tab[i];</span><br><span class="line">           &#125;</span><br><span class="line">           return null;//没有数据直接返回null</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码我们可以知道，如果从数组中，获取的key==null的情况下，get方法内部也会调用expungeStaleEntry（）方法，去清除当前位置所有key==null的数据，<strong>也就是说现在不管是调用ThreadLocal的set（）还是get()方法，都会去清除key==null的数据。</strong></p>
<h3 id="ThreadLocal内存泄漏的问题"><a href="#ThreadLocal内存泄漏的问题" class="headerlink" title="ThreadLocal内存泄漏的问题"></a>ThreadLocal内存泄漏的问题</h3><p>通过整个ThreadLocal机制的探索，我相信大家肯定会有一个疑惑，<code>为什么ThreadLocalMap中采用是的是弱引用作为Key?</code>关于该问题，涉及到Java的回收机制。</p>
<h4 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h4><p>在Java中判断一个对象到底是不是需要回收，都跟引用相关。在Java中引用分为了4类。</p>
<ul>
<li>强引用：只要引用存在，垃圾回收器永远不会回收Object obj = new Object();而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉。</li>
<li>软引用：是用来描述，一些还有但并非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。（SoftReference)</li>
<li>弱引用：也是用来描述非必须的对象，但是它的强度要比软引用更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作是，无论当前内存是否足够，都会回收掉被弱引用关联的对象。（WeakReference)</li>
<li>虚引用：也被称为幽灵引用，它是最弱的一种关系。一个对象是否有引用的存在，完全不会对其生存时间构成影响，也无法通过一个虚引用来取得一个实例对象。</li>
</ul>
<p>通过该知识点的了解后，我们再来了解为什么ThreadLocal不能使用强引用，<strong>如果key使用强引用，那么当引用ThreadLocal的对象被回收了，但ThreadLocalMap中还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致内存泄漏。</strong></p>
<h4 id="弱引用带来的问题"><a href="#弱引用带来的问题" class="headerlink" title="弱引用带来的问题"></a>弱引用带来的问题</h4><p>当我们知道了为什么采用弱引用来作为ThreadLocalMap中的key的知识点后，这个时候又会引申出另一个问题<code>不管是调用ThreadLocal的set（）还是get()方法，都会去清除key==null的数据。为毛我们要去清除那些key==null的Entry呢？</code></p>
<p>为什么清除key==null的Entry主要有以下两个原因，具体如下所示：</p>
<ul>
<li>从上面我们已经知道了，<strong>ThreadLocalMap使用ThreadLocal的弱引用作为key</strong>，也就是说，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收。这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，</li>
<li>如果当前线程迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref（当前线程引用） -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value，那么将会导致这些Entry永远无法回收，造成内存泄漏。</li>
</ul>
<p>通过以上分析，我们可以了解在ThreadLocalMap的设计中其实已经考虑到上述两种情况，也加上了一些防护措施。（在调用ThreadLocal的get(),set(),remove()方法的时候都会清除线程ThreadLocalMap里所有key为null的Entry）</p>
<h3 id="ThreadLocal使用注意事项"><a href="#ThreadLocal使用注意事项" class="headerlink" title="ThreadLocal使用注意事项"></a>ThreadLocal使用注意事项</h3><p>虽然ThreadLocal帮我们考虑了内存泄漏的问题，为我们加上了一些防护措施。但是在实际使用中，我们还是需要注意避免以下两种情况，下述两种情况仍然有可能会导致内存泄漏。</p>
<h4 id="避免使用static的ThreadLocal"><a href="#避免使用static的ThreadLocal" class="headerlink" title="避免使用static的ThreadLocal"></a>避免使用static的ThreadLocal</h4><p>使用static修饰的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏。具体原因是在Java虚拟机在加载类的过程中为静态变量分配内存。static变量的生命周期取决于类的生命周期，也就是说类被卸载时，静态变量才会被销毁并释放内存空间。而类的生命周期结束与下面三个条件相关。</p>
<ol>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有任何地方被引用，没有在任何地方通过反射访问该类的方法。</li>
</ol>
<h4 id="分配使用了ThreadLocal又不再调用get-set-remove-方法"><a href="#分配使用了ThreadLocal又不再调用get-set-remove-方法" class="headerlink" title="分配使用了ThreadLocal又不再调用get(),set(),remove()方法"></a>分配使用了ThreadLocal又不再调用get(),set(),remove()方法</h4><p>其实理解起来也很简单，就是第一次调用了ThreadLocal设置数据后，就不在调用get()、set()、remove()方法。也就是说现在ThreadLocalMap中就只有一条数据。那么如果调用ThreadLocal的线程一直不结束的话，即使ThreadLocal已经被置为null（被GC回收）,也一直存在一条强引用链：Thread Ref（当前线程引用） -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value，导致数据无法回收，造成内存泄漏。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>ThreadLocal本质是操作线程中ThreadLocalMap来实现本地线程变量的存储的</li>
<li>ThreadLocalMap是采用数组的方式来存储数据，其中key(弱引用)指向当前ThreadLocal对象，value为设的值</li>
<li>ThreadLocal为内存泄漏采取了处理措施，在调用ThreadLocal的get(),set(),remove()方法的时候都会清除线程ThreadLocalMap里所有key为null的Entry</li>
<li>在使用ThreadLocal的时候，我们仍然需要注意，避免使用static的ThreadLocal，分配使用了ThreadLocal后，一定要根据当前线程的生命周期来判断是否需要手动的去清理ThreadLocalMap中清key==null的Entry。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Android-Handler机制之ThreadLocal/" data-id="cjsheb870000rdsr7nlv61guv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Kotlin下的5种单例模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Kotlin下的5种单例模式/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-e740353ee09bfb69.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kotlin.jpg"></p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在学习Kotlin这门语言，在项目开发中，运用到了单例模式。因为其表达方式与Java是不同的。所以对不同单例模式的实现进行了分别探讨。主要单例模式实现如下：</p>
<ul>
<li>饿汉式</li>
<li>懒汉式</li>
<li>线程安全的懒汉式</li>
<li>双重校验锁式</li>
<li>静态内部类式</li>
</ul>
<p>PS:<strong>该篇文章不讨论单例模式的运用场景与各种模式下的单例模式的优缺点。只讨论在Java下不同单例模式下的对应Kotlin实现。</strong></p>
<h4 id="一、饿汉式实现"><a href="#一、饿汉式实现" class="headerlink" title="一、饿汉式实现"></a>一、饿汉式实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//Java实现</span><br><span class="line">public class SingletonDemo &#123;</span><br><span class="line">    private static SingletonDemo instance=new SingletonDemo();</span><br><span class="line">    private SingletonDemo()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static SingletonDemo getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Kotlin实现</span><br><span class="line">object SingletonDemo</span><br></pre></td></tr></table></figure>
<p>这里很多小伙伴，就吃了一惊。我靠一个<strong>object</strong> 关键字就完成相同的功能？一行代码？</p>
<h5 id="Kotlin的对象声明"><a href="#Kotlin的对象声明" class="headerlink" title="Kotlin的对象声明"></a>Kotlin的对象声明</h5><p>学习了Kotlin的小伙伴肯定知道,在Kotlin中类没有静态方法。如果你需要写一个可以无需用一个类的实例来调用，但需要访问类内部的函数（例如，工厂方法,单例等），你可以把该类声明为一个<strong>对象</strong>。该<strong>对象</strong>与其他语言的静态成员是类似的。如果你想了解Kotlin对象声明的更多内容。请点击- - - <a href="https://www.kotlincn.net/docs/reference/object-declarations.html#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">传送门</a></p>
<p>到这里，如果还是有很多小伙伴不是很相信一行代码就能解决这个功能，我们可以通过一下方式查看Kotlin的字节码。</p>
<h5 id="查看Kotlin对应字节码"><a href="#查看Kotlin对应字节码" class="headerlink" title="查看Kotlin对应字节码"></a>查看Kotlin对应字节码</h5><p><img src="https://upload-images.jianshu.io/upload_images/2824145-5fe46fc3107931b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看Kotlin字节码.png"></p>
<p>我们进入我们的Android Studio(我的Android Studio 3.0,如果你的编译器版本过低，请自动升级) 选择<strong>Tools工具栏</strong>，选择”<strong>Kotlin</strong>“,选择“<strong>Show Kotlin Bytecode</strong>“</p>
<p>选择过后就会进入到下方界面：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-8056feb96cf437ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看Kotlin字节码.png"></p>
<p>点击”<strong>Decompile</strong>“ 根据字节码得到以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class SingletonDemo &#123;</span><br><span class="line">   public static final SingletonDemo INSTANCE;</span><br><span class="line">   private SingletonDemo()&#123;&#125;</span><br><span class="line">   static &#123;</span><br><span class="line">      SingletonDemo var0 = new SingletonDemo();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上代码，我们了解事实就是这个样子的，使用Kotlin”object”进行对象声明与我们的饿汉式单例的代码是相同的。</p>
<h4 id="二、懒汉式"><a href="#二、懒汉式" class="headerlink" title="二、懒汉式"></a>二、懒汉式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//Java实现</span><br><span class="line">public class SingletonDemo &#123;</span><br><span class="line">    private static SingletonDemo instance;</span><br><span class="line">    private SingletonDemo()&#123;&#125;</span><br><span class="line">    public static SingletonDemo getInstance()&#123;</span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            instance=new SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Kotlin实现</span><br><span class="line">class SingletonDemo private constructor() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private var instance: SingletonDemo? = null</span><br><span class="line">            get() &#123;</span><br><span class="line">                if (field == null) &#123;</span><br><span class="line">                    field = SingletonDemo()</span><br><span class="line">                &#125;</span><br><span class="line">                return field</span><br><span class="line">            &#125;</span><br><span class="line">        fun get(): SingletonDemo&#123;</span><br><span class="line">        //细心的小伙伴肯定发现了，这里不用getInstance作为为方法名，是因为在伴生对象声明时，内部已有getInstance方法，所以只能取其他名字</span><br><span class="line">         return instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，我们可以发现在Kotlin实现中，我们让其<strong>主构造函数私有化</strong>并自定义了其<strong>属性访问器</strong>，其余内容大同小异。</p>
<ul>
<li>如果有小伙伴不清楚Kotlin构造函数的使用方式。请点击 - - - <a href="https://www.kotlincn.net/docs/reference/classes.html" target="_blank" rel="noopener">构造函数</a></li>
<li>不清楚Kotlin的属性与访问器，请点击 - - -<a href="https://www.kotlincn.net/docs/reference/properties.html" target="_blank" rel="noopener">属性和字段</a></li>
</ul>
<h4 id="三、线程安全的懒汉式"><a href="#三、线程安全的懒汉式" class="headerlink" title="三、线程安全的懒汉式"></a>三、线程安全的懒汉式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//Java实现</span><br><span class="line">public class SingletonDemo &#123;</span><br><span class="line">    private static SingletonDemo instance;</span><br><span class="line">    private SingletonDemo()&#123;&#125;</span><br><span class="line">    public static synchronized SingletonDemo getInstance()&#123;//使用同步锁</span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            instance=new SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Kotlin实现</span><br><span class="line">class SingletonDemo private constructor() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private var instance: SingletonDemo? = null</span><br><span class="line">            get() &#123;</span><br><span class="line">                if (field == null) &#123;</span><br><span class="line">                    field = SingletonDemo()</span><br><span class="line">                &#125;</span><br><span class="line">                return field</span><br><span class="line">            &#125;</span><br><span class="line">        @Synchronized</span><br><span class="line">        fun get(): SingletonDemo&#123;</span><br><span class="line">            return instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家都知道在使用懒汉式会出现线程安全的问题，需要使用使用同步锁，在Kotlin中，如果你需要将方法声明为同步，需要添加<strong>@Synchronized</strong>注解。</p>
<h4 id="四、双重校验锁式（Double-Check"><a href="#四、双重校验锁式（Double-Check" class="headerlink" title="四、双重校验锁式（Double Check)"></a>四、双重校验锁式（Double Check)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Java实现</span><br><span class="line">public class SingletonDemo &#123;</span><br><span class="line">    private volatile static SingletonDemo instance;</span><br><span class="line">    private SingletonDemo()&#123;&#125; </span><br><span class="line">    public static SingletonDemo getInstance()&#123;</span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            synchronized (SingletonDemo.class)&#123;</span><br><span class="line">                if(instance==null)&#123;</span><br><span class="line">                    instance=new SingletonDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//kotlin实现</span><br><span class="line">class SingletonDemo private constructor() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val instance: SingletonDemo by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) &#123;</span><br><span class="line">        SingletonDemo() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哇！小伙伴们惊喜不，感不感动啊。我们居然几行代码就实现了多行的Java代码。其中我们运用到了Kotlin的<strong>延迟属性 Lazy</strong>。</p>
<p><strong>Lazy</strong>是接受一个 lambda 并返回一个 Lazy 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。</p>
<p>这里还有有两个额外的知识点。</p>
<ul>
<li>高阶函数，高阶函数是将函数用作参数或返回值的函数（我很纠结我到底讲不讲，哎）。大家还是看这个 —<a href="https://www.kotlincn.net/docs/reference/lambdas.html" target="_blank" rel="noopener">高阶函数</a></li>
<li><a href="https://www.kotlincn.net/docs/reference/delegated-properties.html" target="_blank" rel="noopener">委托属性</a></li>
</ul>
<p>如果你了解以上知识点，我们直接来看Lazy的内部实现。</p>
<h5 id="Lazy内部实现"><a href="#Lazy内部实现" class="headerlink" title="Lazy内部实现"></a>Lazy内部实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; lazy(mode: LazyThreadSafetyMode, initializer: () -&gt; T): Lazy&lt;T&gt; =</span><br><span class="line">        when (mode) &#123;</span><br><span class="line">            LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)</span><br><span class="line">            LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)</span><br><span class="line">            LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，因为我们传入的<strong>mode = LazyThreadSafetyMode.SYNCHRONIZED</strong>，<br>那么会直接走 SynchronizedLazyImpl，我们继续观察SynchronizedLazyImpl。</p>
<h5 id="Lazy接口"><a href="#Lazy接口" class="headerlink" title="Lazy接口"></a>Lazy接口</h5><p>SynchronizedLazyImpl实现了Lazy接口，Lazy具体接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Lazy&lt;out T&gt; &#123;</span><br><span class="line">     //当前实例化对象，一旦实例化后，该对象不会再改变</span><br><span class="line">    public val value: T</span><br><span class="line">    //返回true表示，已经延迟实例化过了，false 表示，没有被实例化，</span><br><span class="line">    //一旦方法返回true，该方法会一直返回true,且不会再继续实例化</span><br><span class="line">    public fun isInitialized(): Boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续查看SynchronizedLazyImpl，具体实现如下：</p>
<h5 id="SynchronizedLazyImpl内部实现"><a href="#SynchronizedLazyImpl内部实现" class="headerlink" title="SynchronizedLazyImpl内部实现"></a>SynchronizedLazyImpl内部实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private class SynchronizedLazyImpl&lt;out T&gt;(initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable &#123;</span><br><span class="line">    private var initializer: (() -&gt; T)? = initializer</span><br><span class="line">    @Volatile private var _value: Any? = UNINITIALIZED_VALUE</span><br><span class="line">    // final field is required to enable safe publication of constructed instance</span><br><span class="line">    private val lock = lock ?: this</span><br><span class="line"></span><br><span class="line">    override val value: T</span><br><span class="line">        get() &#123;</span><br><span class="line">            val _v1 = _value</span><br><span class="line">            //判断是否已经初始化过，如果初始化过直接返回，不在调用高级函数内部逻辑</span><br><span class="line">            if (_v1 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                @Suppress(&quot;UNCHECKED_CAST&quot;)</span><br><span class="line">                return _v1 as T</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return synchronized(lock) &#123;</span><br><span class="line">                val _v2 = _value</span><br><span class="line">                if (_v2 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                    @Suppress(&quot;UNCHECKED_CAST&quot;) (_v2 as T)</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    val typedValue = initializer!!()//调用高级函数获取其返回值</span><br><span class="line">                    _value = typedValue   //将返回值赋值给_value,用于下次判断时，直接返回高级函数的返回值</span><br><span class="line">                    initializer = null</span><br><span class="line">                    typedValue  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		//省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码，我们发现 SynchronizedLazyImpl 覆盖了Lazy接口的value属性，并且重新了其属性访问器。其具体逻辑与Java的双重检验是类似的。</p>
<p>到里这里其实大家还是肯定有疑问，我这里<strong>只是实例化了SynchronizedLazyImpl对象，并没有进行值的获取，它是怎么拿到高阶函数的返回值呢？</strong>。这里又涉及到了<strong>委托属性</strong>。</p>
<p>委托属性语法是： val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;。在 by 后面的表达式是该 委托， 因为属性对应的 get()（和 set()）会被委托给它的 getValue() 和 setValue() 方法。 属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（和 setValue()——对于 var 属性）。 </p>
<p>而Lazy.kt文件中，声明了Lazy接口的getValue扩展函数。故在最终赋值的时候会调用该方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">//返回初始化的值。</span><br><span class="line">public inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = value</span><br></pre></td></tr></table></figure>
<h4 id="五、静态内部类式"><a href="#五、静态内部类式" class="headerlink" title="五、静态内部类式"></a>五、静态内部类式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Java实现</span><br><span class="line">public class SingletonDemo &#123;</span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        private static SingletonDemo instance=new SingletonDemo();</span><br><span class="line">    &#125;</span><br><span class="line">    private SingletonDemo()&#123;</span><br><span class="line">        System.out.println(&quot;Singleton has loaded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static SingletonDemo getInstance()&#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//kotlin实现</span><br><span class="line">class SingletonDemo private constructor() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val instance = SingletonHolder.holder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private object SingletonHolder &#123;</span><br><span class="line">        val holder= SingletonDemo()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态内部类的实现方式，也没有什么好说的。Kotlin与Java实现基本雷同。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在该篇文章结束后，有很多小伙伴咨询，如何在Kotlin版的Double Check，给单例添加一个属性，这里我给大家提供了一个实现的方式。（不好意思，最近才抽出时间来解决这个问题）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class SingletonDemo private constructor(private val property: Int) &#123;//这里可以根据实际需求发生改变</span><br><span class="line">  </span><br><span class="line">    companion object &#123;</span><br><span class="line">        @Volatile private var instance: SingletonDemo? = null</span><br><span class="line">        fun getInstance(property: Int) =</span><br><span class="line">                instance ?: synchronized(this) &#123;</span><br><span class="line">                    instance ?: SingletonDemo(property).also &#123; instance = it &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中关于<code>?:</code>操作符，如果 <code>?:</code> 左侧表达式非空，就返回其左侧表达式，否则返回右侧表达式。 请注意，当且仅当左侧为空时，才会对右侧表达式求值。</p>
<p>观察代码我们可以发现大致上和我们的Java中的Double check是一样的。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>附上我写的一个基于Kotlin 仿开眼的项目<a href="https://github.com/AndyJennifer/SimpleEyes" target="_blank" rel="noopener">SimpleEyes</a>(ps: 其实在我之前，已经有很多小朋友开始仿这款应用了，但是我觉得要做就做好。所以我的项目和其他的人应该不同，不仅仅是简单的一个应用。但是，但是。但是。重要的话说三遍。还在开发阶段，不要打我)，欢迎大家follow和start</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Kotlin下的5种单例模式/" data-id="cjsheb867000edsr7du0i1tc9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Lambda表达式（Java)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Lambda表达式（Java)/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-9f3c46b3bc5b44c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="天使爱美丽.jpg"></p>
<p>我们都知道Java 8 支持Lambda表达式，但是平时开发中也很难用到这个东东，但是作为专业的程序员，技多不压身（其实我是在学Kotlin中，发现里面大量的运用到了Lambda表达式，看的我一脸懵逼，所以只好来学习学习，不然怎么出去装逼，怎么骚浪贱）。好，收，让我们来看看Lambda的前世今生。</p>
<p>###一、Lambda到底是什么鬼？<br>说到Lambda，不得不说到<strong>函数式编程</strong>，说到函数式编程不得不说到<strong>λ演算</strong>，<a href="https://baike.baidu.com/item/%CE%BB%E6%BC%94%E7%AE%97/8019133?fr=aladdin" target="_blank" rel="noopener">λ演算</a>是数学家<strong>Church</strong>提出的。λ演算中最关键的要素就是<strong>函数被当作变量处理</strong>能够参与运算。（看到这里我社会大佬，才是这些数学家好嘛，打call,打call)。</p>
<p>继续继续，我们来看看Lambda的官方定义。</p>
<blockquote>
<p>A lambda expression is like a method: it provides a list of formal parameters and a body - an expression or block - expressed in terms of those parameters.<br>翻译如下：Lambda表达式类似于一种方法：它提供了一个形参列表和一个表达式或用这些形参的代码块。</p>
</blockquote>
<p>我去。反正官方的解释我是一点都没有看懂。个人觉得Lambda表达式更像是“语法糖”, 不仅使代码变的更加简洁，还是代码更有阅读性。说了这么多，无码无真相。让我们来探讨探讨Lambda表达式。开车开车，请上车~~~</p>
<h4 id="1-1-Lambda表达式分析"><a href="#1-1-Lambda表达式分析" class="headerlink" title="1.1 Lambda表达式分析"></a>1.1 Lambda表达式分析</h4><p>那在Java中如果我们要给一个变量赋值，我们一般的操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">String b = &quot;abc&quot;;</span><br><span class="line">boolean c = true;</span><br></pre></td></tr></table></figure></p>
<p>但是如果我们根据λ演算要素，<strong>将函数当做变量处理</strong>，将函数赋值给一个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addMethod = public void add(int a,int b)&#123;</span><br><span class="line"> return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>哇，这代码真是蛇皮，这与我们实际编码中书写的Lambda表达式代码完全不一样好嘛，对啊！作为一个程序员，我们万事都要讲究一个<strong>优雅</strong>好嘛，不优雅，<strong>你就是要我命</strong>，你造否？所以为了代码简洁与优雅。Sun公司的大佬们移除了一些不必要的声明。我们一步一步的来分析。</p>
<h5 id="1-1-1-去除函数修饰符"><a href="#1-1-1-去除函数修饰符" class="headerlink" title="1.1.1 去除函数修饰符"></a>1.1.1 去除函数修饰符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addMethod = void add(int a,int b)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面操作，我们发现了我们移除了public 修饰符，设想，如果我们需要将一个函数赋值给一个变量，那么起访问权限控制的，肯定是变量的修饰符，所以说函数的修饰符可以移除。我们继续往下走。</p>
<h5 id="1-1-2-去除函数名称"><a href="#1-1-2-去除函数名称" class="headerlink" title="1.1.2 去除函数名称"></a>1.1.2 去除函数名称</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addMethod = void (int a,int b)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去除函数名称，主要的原因是，既然我已将函数赋值给变量了。那所有的操作都是与这个变量相关，所以函数的名称是可以不要的。对实际的操作没有影响。</p>
<h5 id="1-1-3-去除函数返回类型"><a href="#1-1-3-去除函数返回类型" class="headerlink" title="1.1.3 去除函数返回类型"></a>1.1.3 去除函数返回类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addMethod = (int a,int b)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会去掉函数返回类型呢？函数内部到底有没有返回值，你觉得编译器心里难道没有一点B数嘛，所以我们完全可以省略这个返回类型。</p>
<h5 id="1-1-4-去除参数类型"><a href="#1-1-4-去除参数类型" class="headerlink" title="1.1.4 去除参数类型"></a>1.1.4 去除参数类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addMethod = (a, b)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去掉参数类型，同1.1.2原因，编译器知道传入的参数类型。所以可以省略。</p>
<h5 id="1-1-5-参数与函数体区分"><a href="#1-1-5-参数与函数体区分" class="headerlink" title="1.1.5 参数与函数体区分"></a>1.1.5 参数与函数体区分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addMethod = (a, b)-&gt;&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了更好的将参数与函数体分开。Java中的语法是使用<strong>“-&gt;”</strong>来区分，这些代码看起来更简洁。</p>
<h4 id="1-2-Lambda表达式对应变量类型"><a href="#1-2-Lambda表达式对应变量类型" class="headerlink" title="1.2 Lambda表达式对应变量类型"></a>1.2 Lambda表达式对应变量类型</h4><p>到现在为止，我们已经成功的将一个函数赋值给一个变量。这个时候我们需要理解的是这个变量的具体类型是什么，我们都知道我们声明变量的时候，前方都会声明其类型。那这个变量的类型到底是什么呢？</p>
<p>在Java8中，<strong>Lambda表达式所对应的类型都是接口</strong>，Lambda所表达的就是那个接口对应函数的具体代码。可能大家这里不是很清楚。概念还是很模糊。我们看一下下面的例子，我相信大家就能清楚的明白了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> //声明一个Person接口</span><br><span class="line">  public interface Person &#123;</span><br><span class="line">        void smile(int time);</span><br><span class="line">    &#125;</span><br><span class="line"> //在java8以前我们实现接口</span><br><span class="line"> Person p = new Person() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void smile(int time) &#123;</span><br><span class="line">                System.out.println(&quot;我笑了&quot; + time + &quot;秒&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> //通过Lambda实现接口</span><br><span class="line">Person p = time -&gt; System.out.println(&quot;我笑了&quot; + time + &quot;秒&quot;);</span><br></pre></td></tr></table></figure></p>
<p>观察上述代码，我们发现。通过Lambda表达式来实现接口，相比之前的实现接口的方式，Lambda表达式是代码更加清晰，且代码量较少。</p>
<h4 id="1-2-1-Lambda表达式表达的方法个数。"><a href="#1-2-1-Lambda表达式表达的方法个数。" class="headerlink" title="1.2.1 Lambda表达式表达的方法个数。"></a>1.2.1 Lambda表达式表达的方法个数。</h4><p>说到这里，我相信大家都有一个疑问，就是假如Person接口中不止有一个smile方法，还有其他方法呢？那这个时候我该怎么用Lambda表达式来表示呢？ 这个问题其实在最初的Lambda表达式分析那里已经侧面表现了。既然是将函数赋值给变量，那么一个变量对应的函数就只能<strong>有且只有一个</strong>，不然怎么知道你在调用的时候具体调用的哪个函数呢？你说呢，兄die.</p>
<p>说到这里，有的兄die就会说，我怎么才能让我的接口有且只有一个方法呢？,那就引出我们的<strong>@FunctionalInterface</strong>注解，直接通过英文直译的话意思是“函数式接口”。我去，什么鬼，不了解其意思，我们就直接看源码吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">An informative annotation type used to indicate that an interface</span><br><span class="line"> * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as</span><br><span class="line"> * defined by the Java Language Specification.</span><br><span class="line"> *</span><br><span class="line"> * Conceptually, a functional interface has exactly one abstract</span><br><span class="line"> * method.  Since &#123;@linkplain java.lang.reflect.Method#isDefault()</span><br><span class="line"> * default methods&#125; have an implementation, they are not abstract.  If</span><br><span class="line"> * an interface declares an abstract method overriding one of the</span><br><span class="line"> * public methods of &#123;@code java.lang.Object&#125;, that also does</span><br><span class="line"> * &lt;em&gt;not&lt;/em&gt; count toward the interface&apos;s abstract method count</span><br><span class="line"> * since any implementation of the interface will have an</span><br><span class="line"> * implementation from &#123;@code java.lang.Object&#125; or elsewhere.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我截取了部分FunctionalInterface的部分注释，<strong>@FunctionalInterface</strong> 注解主要是用于修饰接口。且修饰的接口中有且只有一个方法，到这里我们就明白了，那么我可以用<strong>@FunctionalInterface</strong>注解来修饰我们的接口啦。这个接口是不是很牛逼啊。</p>
<h3 id="二、Lambda表达式语法"><a href="#二、Lambda表达式语法" class="headerlink" title="二、Lambda表达式语法"></a>二、Lambda表达式语法</h3><p>在了解Lambda的由来，以及表现形式后，我们现在可以来了解一下Lambda的语法啦，知道原理，当然也必须知道怎么使用，对吧。（授人鱼不如授人以渔,你说是不是这个道理，哈哈哈，秀秀我的语文功底）。</p>
<ul>
<li>Lambad表达式总是在花括号中；</li>
<li>其参数（如果有的话）在 —&gt;<strong>之前</strong>声明（参数类型可以省略）;</li>
<li>函数体（如果存在的话）在—&gt;<strong>之后</strong>声明;</li>
</ul>
<p>基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(formal parameter list) -&gt; &#123; expression or statements&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-1-Lambda表达式例子"><a href="#2-1-Lambda表达式例子" class="headerlink" title="2.1 Lambda表达式例子"></a>2.1 Lambda表达式例子</h4><p>Lambda 表达式实际上是一种匿名方法实现（有的人说是匿名内部类实现，看个人怎么理解了），Lambda表达式的求值不会导致函数体的执行，而是在调用该方法后发生，下面是一些Lambda表达式的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;&#125;                //无参，空的函数体⑤</span><br><span class="line">   () -&gt; 42                //无参，函数体返回42⑥</span><br><span class="line">   () -&gt; null              // 无参，函数体返回null⑦</span><br><span class="line">   () -&gt; &#123; return 42; &#125;    //  无参，函数体返回42</span><br><span class="line">   () -&gt; &#123; System.gc(); &#125;  // 无参，执行语句，函数体返Void</span><br><span class="line">   () -&gt;  System.gc()  // 无参，执行语句，函数体返Void⑨</span><br><span class="line"></span><br><span class="line">   () -&gt; &#123;                 // 带返回语句的完整函数体</span><br><span class="line">       if (true) return 12;</span><br><span class="line">       else &#123;</span><br><span class="line">           int result = 15;</span><br><span class="line">           for (int i = 1; i &lt; 10; i++)</span><br><span class="line">           result *= i;</span><br><span class="line">           return result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   (int x) -&gt; x+1              // 声明类型的单个参数⑧</span><br><span class="line">   (int x) -&gt; &#123; return x+1; &#125;  // 声明类型的单个参数</span><br><span class="line">   (x) -&gt; x+1                  // 隐藏参数类型的单个参数③</span><br><span class="line">   x -&gt; x+1                    // 花括号可选④</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   (String s) -&gt; s.length()      // 声明类型的单个参数</span><br><span class="line">   (Thread t) -&gt; &#123; t.start(); &#125;  // 声明类型的单个参数</span><br><span class="line">   s -&gt; s.length()               // 隐藏参数类型的单个参数</span><br><span class="line">   t -&gt; &#123; t.start(); &#125;           // 隐藏参数类型的单个参数⑩</span><br><span class="line"></span><br><span class="line">   (int x, int y) -&gt; x+y  // 声明参数类型的多个参数①</span><br><span class="line">   (x, y) -&gt; x+y          // 隐藏参数类型的多个参数②</span><br><span class="line">   (x, int y) -&gt; x+y    // 错误：不能同时单个的声明类型或隐藏类型</span><br><span class="line">   (x, final y) -&gt; x+y  // 错误：没有推断类型的修饰符</span><br></pre></td></tr></table></figure>
<p>相信大家从上面例子中可以看出一下语法规则，那我们将这语法规则分为两个部分<strong>Lambda参数规则</strong>与<strong>lambda函数体规则</strong>。</p>
<h4 id="2-2-Lambda参数规则"><a href="#2-2-Lambda参数规则" class="headerlink" title="2.2 Lambda参数规则"></a>2.2 Lambda参数规则</h4><ul>
<li>参数列表必须是以逗号分隔的形式。见①</li>
<li>参数列表的参数类型是可选的，如果未指定参数类型，将从上下文进行推断。见②</li>
<li>参数列表参数的个数大于2则必须用小括号括起来 。见②</li>
<li>参数列表参数的个数为1，则小括号可以省略。见⑩</li>
<li>如果函数体中，没有使用参数，那么必须指定空括号。见⑤⑥⑦</li>
</ul>
<h4 id="2-3-Lambda函数体规则"><a href="#2-3-Lambda函数体规则" class="headerlink" title="2.3 Lambda函数体规则"></a>2.3 Lambda函数体规则</h4><ul>
<li>如果函数体只包含单条表达式或语句，就不需要使用大括号。见⑧⑨</li>
</ul>
<h3 id="三、-Lambda使用注意事项"><a href="#三、-Lambda使用注意事项" class="headerlink" title="三、 Lambda使用注意事项"></a>三、 Lambda使用注意事项</h3><p>现在我们基本了解了Lambda的使用方式，已经使用场景，那么现在我们看看在Lambda使用中需要注意的问题。</p>
<h4 id="3-1-Lambda访问变量为final类型"><a href="#3-1-Lambda访问变量为final类型" class="headerlink" title="3.1 Lambda访问变量为final类型"></a>3.1 Lambda访问变量为final类型</h4><p>我们都知道在匿名内部类中访问变量时，需要将变量修饰为<strong>final</strong>类型。因为如果该该内部类运行在另一线程中，必将会出现线程安全的问题。（这里肯定有很多读者就会提出这样一个问题，那这个内部类修饰变量为<strong>final</strong>和我们Lambda表达式有毛关系啊？）请听我细细道来。</p>
<p>如果你仔细阅读了该文，你应该知道Lambda表达式相当于声明匿名内部类。只是换了一种表达方式而已。那么本质是一样的。所以在访问变量的时候我们也需要注意这些问题。看下面代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   public interface A &#123;</span><br><span class="line">       void fuck();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public void test() &#123;</span><br><span class="line">       int count = 10;</span><br><span class="line">       A a = () -&gt; &#123; count++&#125;;//错误 count 类型为final类型。</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，大家肯定会疑惑，为什么我这里没有申明count为<strong>final</strong>类型。因为在java8中，在编译器编译的时候会将Lambda表达式访问的变量，自动声明为final类型。有点语法糖的味道。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上文分析。我们发现Lambda表达式不仅使程序变得更加简洁。还能节省程序员的代码量，节省了很多码代码的时间。再有一个我觉得更重要的是，这样代码看起来很骚，你说是吗？</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>站在巨人的肩膀上。可以看得更远。感谢下列博主，和官方文档。人类的知识是大家的。<br><a href="https://www.zhihu.com/question/20125256" target="_blank" rel="noopener">Lambda 表达式有何用处？如何使用</a><br><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27" target="_blank" rel="noopener">Oracle Lambda官方文档</a></p>
<p>最后，附上我写的一个基于Kotlin 仿开眼的项目<a href="https://github.com/AndyJennifer/SimpleEyes" target="_blank" rel="noopener">SimpleEyes</a>(ps: 其实在我之前，已经有很多小朋友开始仿这款应用了，但是我觉得要做就做好。所以我的项目和其他的人应该不同，不仅仅是简单的一个应用。但是，但是。但是。重要的话说三遍。还在开发阶段，不要打我)，欢迎大家follow和start</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Lambda表达式（Java)/" data-id="cjsheb869000fdsr7qik84lmw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ArrayList分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/ArrayList分析/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://upload-images.jianshu.io/upload_images/2824145-5dda6fec988df5dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="超杀女.jpg"></p>
<p> 对于集合的源码分析，一般我会采用这几种方式</p>
<ol>
<li>怎么添加元素？</li>
<li>怎么获取元素？</li>
<li>怎么删除元素？</li>
<li>内部数据结构实现？</li>
</ol>
<p>话不多说，直接走起。</p>
<h2 id="一-怎么添加元素？"><a href="#一-怎么添加元素？" class="headerlink" title="一.怎么添加元素？"></a>一.怎么添加元素？</h2><p>一般我们通过ArrayList添加元素。一般会调用其构造方法,然后调用其对象的add方法</p>
<h3 id="查看空参构造函数"><a href="#查看空参构造函数" class="headerlink" title="查看空参构造函数"></a>查看空参构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Constructs an empty list with an initial capacity of ten.</span><br><span class="line"> public ArrayList() &#123;</span><br><span class="line">        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过构造函数可以发现。ArrayList在调用无参的构造函数时，会构造一个长度为10的缓存数组</p>
<h3 id="查看add方法"><a href="#查看add方法" class="headerlink" title="查看add方法"></a>查看add方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1); </span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过该方法发现 ArralyList内部的数据结构其实是一个<strong>数组</strong>（elementData[size++] = e;）并且在添加时会先判断当前容器在添加了一个对象之后该对象的容纳能力（主要为了，在下一次添加元素的时候，缓存数组能够有足够的空间添加元素)。之后将元素添加到数组末尾。</p>
<h3 id="继续查看ensureCapacityInternal（）方法"><a href="#继续查看ensureCapacityInternal（）方法" class="headerlink" title="继续查看ensureCapacityInternal（）方法"></a>继续查看ensureCapacityInternal（）方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现，如果当前elementData为空的话，minCapacity=DEFAULT_CAPACITY,同时DEFAULT_CAPACITY的默认值是<strong>10</strong>,从这我们可以看出，在第一次初始化的时候，ArrayList内部会默认<strong>创建一个内部长度为10的数组。</strong></p>
<h3 id="继续点击ensureExplicitCapacity（）方法"><a href="#继续点击ensureExplicitCapacity（）方法" class="headerlink" title="继续点击ensureExplicitCapacity（）方法"></a>继续点击ensureExplicitCapacity（）方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    //判断添加元素后，缓存数组时候需要扩展</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会记录当前数组的更改次数，并且判断当前数组添加后，是否需要进行增长，</p>
<h3 id="继续走grow方法（重点的来了！！！）"><a href="#继续走grow方法（重点的来了！！！）" class="headerlink" title="继续走grow方法（重点的来了！！！）"></a>继续走grow方法（重点的来了！！！）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    //扩展数组的长度，</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会扩展缓存为当前数组的长度为 <strong>原数组长度+原数组长度的二分之一</strong>，也就是按照原数组的<strong>50%</strong>进行增长，同时该数组最大的扩展长度是<strong>Integer.MAX_VALUE - 8</strong>。也就是ArrayList最多能存储的数据长度，通过扩展数组长度以后，在下一次添加数据的时候，ArrayList就有足够的空间去添加新的元素了。</p>
<h2 id="二-怎么获取元素"><a href="#二-怎么获取元素" class="headerlink" title="二.怎么获取元素"></a>二.怎么获取元素</h2><p>其实ArrayList获取其中的元素很简单，根据角标获取对应数组中的元素，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">       if (index &gt;= size)//判断当前角标长度是否超过数组长度，如果是抛出异常，反之返回数据</span><br><span class="line">           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">       return (E) elementData[index];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>##三.怎么删除元素<br>在ArrayList中，有两个关于删除元素的方法，一个是<strong>remove(int)</strong>,另一个是<strong>remove(Object)</strong></p>
<h3 id="1-remove-int-方法"><a href="#1-remove-int-方法" class="headerlink" title="1.remove(int)方法"></a>1.remove(int)方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        if (index &gt;= size)</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = (E) elementData[index];</span><br><span class="line"></span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = null; // 将数组最后一位置null</span><br><span class="line"></span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里先判断删除角标是否超过数组长度，然后通过System.arrayCopty()方法将角标对应的元素删除。</p>
<p>这里对System.arrayCopty()方法解释一下。该方法的第一个参数是<strong>源数组</strong>，第二个参数是复制的<strong>开始角标</strong>，第二个参数是<strong>目标数组</strong>。第三个参数是<strong>目标数组</strong>与<strong>源数组</strong>的复制数据开始角标。最后一个参数是复制的长度。(注意：！！！复制的长度不能大于<strong>目标数组减去开始角标的长度</strong>或<strong>源数组减去开始角标的长度</strong>)</p>
<h4 id="eg"><a href="#eg" class="headerlink" title="eg:"></a>eg:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> int[] a = &#123;0, 1, 2, 3, 4&#125;;</span><br><span class="line"> int[] b = &#123;5, 6, 7, 8, 9&#125;;</span><br><span class="line"> System.arraycopy(a, 0, b, 1, 3);</span><br><span class="line">// 则进行操作后 b = &#123;5，0,1,2,9&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-remove-Object-方法"><a href="#2-remove-Object-方法" class="headerlink" title="2.remove(Object)方法"></a>2.remove(Object)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">       if (o == null) &#123;//判断当前元素是否为空，遍历数组，获取其角标</span><br><span class="line">           for (int index = 0; index &lt; size; index++)</span><br><span class="line">               if (elementData[index] == null) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           for (int index = 0; index &lt; size; index++)</span><br><span class="line">               if (o.equals(elementData[index])) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> private void fastRemove(int index) &#123;//根据角标，删除相应元素</span><br><span class="line">       modCount++;</span><br><span class="line">       int numMoved = size - index - 1;</span><br><span class="line">       if (numMoved &gt; 0)</span><br><span class="line">           System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>remove(Object)根据object在数组的角标，执行fastRemove(index)方法。删除方法与remoIndex(int)一样。这里就不在分析了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>ArrayList内部实现是数组，且当数组长度不够时，数组的会进行原数组长度的<strong>1.5倍扩容</strong>。</li>
<li>ArrayList内部元素是<strong>可以重复的</strong>。且<strong>有序</strong>的，因为是按照数组一个一个进行添加的。</li>
<li>ArrayList是<strong>线程不安全的</strong>，因为其内部添加、删除、等操作，没有进行同步操作。</li>
<li>ArrayList<strong>增删元素速度较慢</strong>，因为内部实现是数组，每次操作都会对数组进行复制操作，复制操作是比较耗时的</li>
</ul>
<p>最后，附上我写的一个基于Kotlin 仿开眼的项目<a href="https://github.com/AndyJennifer/SimpleEyes" target="_blank" rel="noopener">SimpleEyes</a>(ps: 其实在我之前，已经有很多小朋友开始仿这款应用了，但是我觉得要做就做好。所以我的项目和其他的人应该不同，不仅仅是简单的一个应用。但是，但是。但是。重要的话说三遍。还在开发阶段，不要打我)，欢迎大家follow和start</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/ArrayList分析/" data-id="cjsheb85h0002dsr7e1vhzywe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android-Handler机制之消息池的扩展-SimplePool与SynchronizedPool" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Android-Handler机制之消息池的扩展-SimplePool与SynchronizedPool/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-0be39b98baebb871.gif?imageMogr2/auto-orient/strip" alt="消息池.gif"></p>
<blockquote>
<p>该文章属于Android Handler系列文章，如果想了解更多，请点击<br><a href="https://www.jianshu.com/p/43bb31d8a742" target="_blank" rel="noopener">《Android Handler机制之总目录》</a></p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上篇文章<a href="https://www.jianshu.com/p/d0ef4edd4407" target="_blank" rel="noopener">《Android Handler机制之Message及Message回收机制 》</a>我们讲解了Message中所携带的信息及消息池中的实现方式。其中我们已经了解了Message中消息池是以链表的形式来完成。在完成了上篇文章后，我就一直想在Java或Android中是否已经为我们提供了一种对象池来帮助我们来实现缓存对象的实现呢。果真在Android中的android.support.v4.util下的Pools类就为我们提供了SimplePool、SynchronizedPool来创建对象池。下面我就对该包下的类进行讲解。</p>
<h3 id="Android中提供的对象池"><a href="#Android中提供的对象池" class="headerlink" title="Android中提供的对象池"></a>Android中提供的对象池</h3><p>在android.support.v4.util包下的Pools类中，分别声明了Pool接口，SimplePool实现类与SynchronizedPool实现类，其中具体的UML关系如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-0cc634c790076912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="继承关系.png"><br>在上图中，Pool的具体实现类为SimplePool，而SynchronizedPool为SimplePool的子类。</p>
<h3 id="简单对象池（SimplePool）"><a href="#简单对象池（SimplePool）" class="headerlink" title="简单对象池（SimplePool）"></a>简单对象池（SimplePool）</h3><p>在讨论了具体的UML关系后，现在我们来看看SimplePool的代码实现，具体代码如下图所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public static class SimplePool&lt;T&gt; implements Pool&lt;T&gt; &#123;</span><br><span class="line">      private final Object[] mPool;//存储对象的数组</span><br><span class="line">      private int mPoolSize;//当前对象池中的对象个数</span><br><span class="line"></span><br><span class="line">      public SimplePool(int maxPoolSize) &#123;</span><br><span class="line">          if (maxPoolSize &lt;= 0) &#123;</span><br><span class="line">              throw new IllegalArgumentException(&quot;The max pool size must be &gt; 0&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          mPool = new Object[maxPoolSize];//初始化对象池的最大容量</span><br><span class="line">      &#125;</span><br><span class="line">//从对象池中获取数据</span><br><span class="line">      @Override</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">      public T acquire() &#123;</span><br><span class="line">          if (mPoolSize &gt; 0) &#123;</span><br><span class="line">              final int lastPooledIndex = mPoolSize - 1;</span><br><span class="line">              T instance = (T) mPool[lastPooledIndex];</span><br><span class="line">              mPool[lastPooledIndex] = null;</span><br><span class="line">              mPoolSize--;//当前对象池中对象个数减1</span><br><span class="line">              return instance;</span><br><span class="line">          &#125;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">//回收当前对象到对象池中，</span><br><span class="line">      @Override</span><br><span class="line">      public boolean release(@NonNull T instance) &#123;</span><br><span class="line">          if (isInPool(instance)) &#123;//如果对象池中已经有当前对象了，会抛出异常</span><br><span class="line">              throw new IllegalStateException(&quot;Already in the pool!&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          if (mPoolSize &lt; mPool.length) &#123;</span><br><span class="line">              mPool[mPoolSize] = instance;</span><br><span class="line">              mPoolSize++;</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">//判断当前对象是否在对象池中</span><br><span class="line">      private boolean isInPool(@NonNull T instance) &#123;</span><br><span class="line">          for (int i = 0; i &lt; mPoolSize; i++) &#123;</span><br><span class="line">              if (mPool[i] == instance) &#123;</span><br><span class="line">                  return true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于SimplePool的代码其实很好理解，其对象池是以数组的方式来实现的。其中对象池的最大容量是通过用户手动设定。从对象池中获取数据是通过acquire方法。回收当前对象到对象池中是通过release方法。关于这两个方法的详细流程会在下文具体介绍。</p>
<h4 id="关于acquire方法"><a href="#关于acquire方法" class="headerlink" title="关于acquire方法"></a>关于acquire方法</h4><p>在acquire方法中，会从对象池中取出对象。具体列子如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-f78d7c7a39ac57c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="acquire.png"><br>在上图中，当前对象池中存储了10个object对象，当前sPoolSize = 10。当调用acquire（）方法时，会获取最后一个对象（也就是 mPool[9],将该对象取出后，会将该位置置为null（mPool9] =null)，当前sPoolSize = 9。当再次调用acquire（）方法时，会获取mPool[8]位置下的对象。同理将该位置置为null，当前sPoolSize = 8。</p>
<p>总结：<strong>acquire()方法总会取当前对象池中存储的最后一个数据。如果有则返回。同时将该位置置为null。反之返回为null。</strong></p>
<h4 id="关于release方法"><a href="#关于release方法" class="headerlink" title="关于release方法"></a>关于release方法</h4><p>在release方法中，会将对象缓存到对象池中。如果当前对象已经存在，会抛出异常。反之则存储。具体列子如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-4a6a47a74c4d2913.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="realase.png"><br>在上图中。当前对象池存储了8个object对象。当前sPoolSize = 8。当调用realse方法将object9对象回收到对象池中去时，会存储在 mPool[8]位置下。且当前sPoolSize = 9，那么当再次调用realse方法将object10对象放入时，会将object10对象存储在mPool[9]位置下。</p>
<p>总结：<strong>release( T instance)方法，总会将需要回收的对象存入当前对象池中存储的最后一个数据的下一个位置。如果当前回收的对象已经存在会抛出异常。反之则成功。</strong></p>
<h3 id="同步对象池（SynchronizedPool）"><a href="#同步对象池（SynchronizedPool）" class="headerlink" title="同步对象池（SynchronizedPool）"></a>同步对象池（SynchronizedPool）</h3><p>在前面的文章中我们介绍了SimplePool的存取数据的主要实现。细心的小伙伴肯定都已经发现了。在多线程的情况下，如果使用SimplePool肯定是会出现问题的。但是Google已经为我们考虑到了，为我们提供了线程安全的对象池SynchronizedPool，下面我们就来看看SynchronizedPool的具体实现。具体代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static class SynchronizedPool&lt;T&gt; extends SimplePool&lt;T&gt; &#123;</span><br><span class="line">      private final Object mLock = new Object();</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">       * Creates a new instance.</span><br><span class="line">       *</span><br><span class="line">       * @param maxPoolSize The max pool size.</span><br><span class="line">       *</span><br><span class="line">       * @throws IllegalArgumentException If the max pool size is less than zero.</span><br><span class="line">       */</span><br><span class="line">      public SynchronizedPool(int maxPoolSize) &#123;</span><br><span class="line">          super(maxPoolSize);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public T acquire() &#123;</span><br><span class="line">          synchronized (mLock) &#123;</span><br><span class="line">              return super.acquire();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public boolean release(@NonNull T element) &#123;</span><br><span class="line">          synchronized (mLock) &#123;</span><br><span class="line">              return super.release(element);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>SynchronizedPool的代码理解起来也同样非常简单，直接继承SimplePool。并重写了SimplePool的两个方法。并为其加上了锁，保证了多线程情况下使用的安全性。</p>
<h3 id="对象池的使用"><a href="#对象池的使用" class="headerlink" title="对象池的使用"></a>对象池的使用</h3><p>上面我们讨论了两种不同的对象池的实现，下面我们来看看对于这两种对象池的使用。这里就使用官方的SynchronizedPool的使用例子（这里对SimplePool的使用也是通用的，根据是否需要多线程操作来选择不同的对象池）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> public class MyPooledClass &#123;</span><br><span class="line"> </span><br><span class="line">  //声明对象池的大小</span><br><span class="line">     private static final SynchronizedPool&lt;MyPooledClass&gt; sPool =</span><br><span class="line">             new SynchronizedPool&lt;MyPooledClass&gt;(10);</span><br><span class="line">             </span><br><span class="line">  //从对象池中获取数据，如果为null,则创建</span><br><span class="line">     public static MyPooledClass obtain() &#123;</span><br><span class="line">        MyPooledClass instance = sPool.acquire();</span><br><span class="line">       return (instance != null) ? instance : new MyPooledClass();</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  //回收对象到对象池中。当然你也可以清除对象的状态</span><br><span class="line">     public void recycle() &#123;</span><br><span class="line">          // 清除对象的状态，如果你自己需要的话，</span><br><span class="line">         sPool.release(this);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>对于频繁创建的对象，可以考虑使用对象池。</li>
<li>实现对象池的方式有几种，可以采用数组的形式，也可以采用链表的形式。</li>
<li>在实现对象池缓存对象时，需要考虑到线程安全的问题。该加锁就加锁。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Android-Handler机制之消息池的扩展-SimplePool与SynchronizedPool/" data-id="cjsheb85e0001dsr7ick146ec" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-哈希表之HashMap(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/哈希表之HashMap(二)/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-c6655b07bfd9b105.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="你说是什么图就是什么图.jpg"></p>
<blockquote>
<p>在写这篇文章之前，看了很多关于HashMap解析的文章。对于大多数人来说，可了跟着别人的文章走一遍。大家都能了解HashMap的内部结构，使用方法以及注意事项。我还是觉得知道用是一回事。知道原理是另一回事。只有了解了其数据结构设计初衷。才能更好的使用它。此系列文章主要分为两个部分，具体目录如下：</p>
</blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/345019b77571" target="_blank" rel="noopener">哈希表初识(一)</a></li>
<li>哈希表之HashMap(二)</li>
</ul>
<p>提示：该篇文章作为彻底理解哈希表的第二个部分。主要讲了HashMap在Java中基于JDK1.8(不同版本HashMap可能实现不同)的具体实现。如果你对哈希表还不算太熟，建议先阅读上一篇文章，我相信等你看完之后，在回来看这篇文章，会有一种<strong>飞翔的感觉</strong>。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Java中java.util包下，定义了Map接口来实现键值对的映射关系。常用的类为HashMap,LinkedHashMap,TreeMap。其主要的类关系如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-23a8b487bb761aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Map类关系图.png"></p>
<p>在平时项目的开发中，我们主要使用的是HashMap及其子类，那我们接下来就了解一下HashMap的主要特征。</p>
<ul>
<li>采用数组+链表的形式对数据进行存储。</li>
<li>根据hashCode值存储数据，访问速度较快。</li>
<li>有且只有一个key为null的数组。</li>
<li>遍历是无序的。</li>
<li>线程非安全。</li>
</ul>
<h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><p>既然上文提到了数组+链表的形式，大家是否想起我们上篇文章提到的<strong>链地址法</strong>呢？如果你忘记了链地址法的具体实现，没关系，让我们一起看看在Java中HashMap具体的内部结构,具体的结构如下图所示：(注意:<strong>在JDK1.8中如果链表的长度大于8时会将该链表转换为红黑树</strong>)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-bd641cc0ee4fd0b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内部结构.png"></p>
<p>从图中看出，HashMap底层存储的是<strong>Node</strong>节点，本质是一个映射（键值对）。上图中，每个<strong>黑色圆点</strong>就是一个<strong>Node</strong>对象，<strong>数组table</strong>对应Node&lt;K,V&gt;[] table。</p>
<p>查看Node对应源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       final int hash;</span><br><span class="line">       final K key;</span><br><span class="line">       V value;</span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       Node(int hash, K key, V value, HashMapEntry&lt;K,V&gt; next) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">       public final K getKey()       &#123;...&#125;</span><br><span class="line">       public final V getValue()      &#123;...&#125;</span><br><span class="line">       public final String toString() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">       public final int hashCode()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">       public final V setValue(V newValue) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">       public final boolean equals(Object o) &#123;...&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从代码中我们可以看出，<strong>Node</strong>是HashMap的一个内部类，实现了Map.Entry接口。该类中保存了当前存储数据的hash值，关键字、和当前存储数据、及下一个Node节点的引用。既然我们已经知道了HashMap到底存储的是什么东西，那么我们继续看看HashMap的初始化。</p>
<p>###HashMap初始化</p>
<p>在我们初始化HashMap实例对象的时候，我们默认调用是其参数为空的构造函数，查看具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public HashMap() &#123;</span><br><span class="line">	  //DEFAULT_LOAD_FACTOR = 0.75</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上，不知道大家看到熟悉的东西没<strong>loadFactor</strong>,还记得上篇文章我们提到的<strong>装载因子</strong>(我们不可能等到数组快满时，才进行扩容操作，因为会影响效率），我们发现默认情况下，HashMap初始容量为16，且装载因子为0.75，也就是当容量为12(当前数组容量*装载因子)时，进行下一次添加数据的时候，会对HashMap内部的数组进行扩容。</p>
<h3 id="HashMap放入键值对"><a href="#HashMap放入键值对" class="headerlink" title="HashMap放入键值对"></a>HashMap放入键值对</h3><h4 id="查看put方法"><a href="#查看put方法" class="headerlink" title="查看put方法"></a>查看put方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">       return putVal(hash(key), key, value, false, true);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在HashMap调用put方法，放入键值对时，会先调用hash方法计算当前key对象的哈希值，对应hash方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>hash方法内部会获取当前key的hashCode,通过当前hashCode与当前hashCode右移后的数字，进行异或运算得到哈希值。</p>
<h4 id="查看putVal方法"><a href="#查看putVal方法" class="headerlink" title="查看putVal方法"></a>查看putVal方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">         //第一步，如果当前table为空，则初始化</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        //第二步，如果当前数据未放入，则添加</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">                //第三步，如果当前key已存在，则进行覆盖操作</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">                //第四步，判断该链表是否是红黑树</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;//第五步，是否是链表</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        //如果当前链表长度大于等于8则转会红黑树处理</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果是链表中的key已存在，则进行覆盖操作</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; </span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                //第六步，是否覆盖已存在的key对应的value</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        //如果添加完后，当前数组容量大于临界值，对数组进行扩容。</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中我们可以看出，HashMap添加元素主要分为六个步骤。经过这六个步骤完成了相应的键值对的映射。下面我们将具体的来分析这六个步骤。</p>
<p>####（一）创建table数组<br>如果当前数组为空，会调用相应resize()方法。创建相应table数组。这里省略了扩容数组代码，因为其比较复杂，下面我们会单独进行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">       int oldThr = threshold;</span><br><span class="line">       int newCap, newThr = 0;</span><br><span class="line">       //判断当前数组是否被创建</span><br><span class="line">       if (oldCap &gt; 0) &#123;</span><br><span class="line">           if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               return oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           //如果当前数组到达临界值</span><br><span class="line">           //数组容量为原来的2倍</span><br><span class="line">           //新的临界值为原来的2倍</span><br><span class="line">           else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">       &#125;</span><br><span class="line">       else if (oldThr &gt; 0)</span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       else &#123;            </span><br><span class="line">           //默认没有数据的情况下，初始化数组，与临界值</span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       if (newThr == 0) &#123;</span><br><span class="line">           float ft = (float)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (int)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       //设置当前临界值</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       </span><br><span class="line">    		....省略扩容代码</span><br><span class="line">    		</span><br><span class="line">    	 //返回新的数组</span><br><span class="line">       return newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码很好理解。判断当前数组是否为空，如果为空，则初始化当前数组，且当前数组容量为DEFAULT_INITIAL_CAPACITY=16,且临界值为12（16*0.75），最后该方法会将创建的数组进行返回。</p>
<p>####（二）如果当前数据未放入，则添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">           tab[i] = newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure>
<p>上述代码，知根据当前key值计算出来的hash值。获取对应数组中的下标，如果当前数组单元没有放入数据，则添加数据到相应的数组单元中。</p>
<p>####（三）如果当前key已存在，则进行覆盖操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">       e = p;</span><br></pre></td></tr></table></figure>
<p>上面代码也是很好理解，如果当前数组单元有数据，且相同hash值且key值相同，那么就进行替换操作。</p>
<p>####（四）判断当前是否是红黑树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">else if (p instanceof TreeNode)</span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br></pre></td></tr></table></figure>
<p>如果当前数组单元对应的是红黑树，那么调用相应红黑树添加方法。这里我们不讨论红黑树，这里我们只要知道。在使用红黑树的时候，查找效率是要优于传统的链表就好了。</p>
<p>####（五）、（六）添加元素到链表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">               if ((e = p.next) == null) &#123;</span><br><span class="line">                   p.next = newNode(hash, key, value, null);</span><br><span class="line">                   if (binCount &gt;= TREEIFY_THRESHOLD - 1) </span><br><span class="line">                   	 //如果当前链表长度大于8，转换为红黑树</span><br><span class="line">                       treeifyBin(tab, hash);</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               //获取hash值相同与key值相同，直接返回当前节点。</span><br><span class="line">               if (e.hash == hash &amp;&amp;</span><br><span class="line">                   ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                   break;</span><br><span class="line">               p = e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (e != null) &#123; //替换相同key值的value</span><br><span class="line">           V oldValue = e.value;</span><br><span class="line">           if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">               e.value = value;</span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">           return oldValue;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>这里我把第五步与第六部合并来讲解。从代码代码大家就可以理解。获取数组单元链表的长度，如果当前链表长度大于8，转换为红黑树，如果存在相同hash值或者key值相同的节点。直接替换对应的value,反之。添加键值对到相应链表中。</p>
<h3 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h3><p>上面我们省略了扩容代码的具体，下面我们来仔细探讨一下HashMap的扩容机制。<br>主要扩容代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//oldTab是原来的talble 数组</span><br><span class="line">if (oldTab != null) &#123;</span><br><span class="line">			  //遍历原来数组单元中对应的链表，oldCap是原来数组的容量</span><br><span class="line">          for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                  oldTab[j] = null;</span><br><span class="line">                  //如果数组单元只有一个节点则计算其新位置，</span><br><span class="line">                  if (e.next == null)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                  //如果是红黑树，特殊处理</span><br><span class="line">                  else if (e instanceof TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                  //获取数组单元中的链表中的节点，并且重新定义位置。</span><br><span class="line">                  else &#123; // preserve order</span><br><span class="line">                      Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      do &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          //原位置的节点</span><br><span class="line">                          if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                              if (loTail == null)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              else</span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          //原位置+oldCap的节点</span><br><span class="line">                          else &#123;</span><br><span class="line">                              if (hiTail == null)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              else</span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; while ((e = next) != null);</span><br><span class="line">                      //把原位置的节点放入</span><br><span class="line">                      if (loTail != null) &#123;</span><br><span class="line">                          loTail.next = null;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      //把新位置的节点放入</span><br><span class="line">                      if (hiTail != null) &#123;</span><br><span class="line">                          hiTail.next = null;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>直接去理解这段代码很难，根据上篇文章的经验，我们知道在数组进行扩容的时候，需要根据hash值去与新的数组长度进行取余运算（hash&amp;length -1),但是从上述代码中，我们没有发现进行取余的操作。这是怎么回事呢？没事大家一起来看下图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-6d1e5de02c67b206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="取余流程.png"></p>
<p>上图中，我们假设某个节点hash值为1111 1111 1111 1111 11111 0000 1011 1111，并且在添加该值时，数组进行了扩容操作（为原来的数组长度的2倍）。我们发现节点在重新计算角标的时候，因为数组的长度变为之前的两倍，所以在新数组中的bit位中，始终要比原来的高一位（图中红色以表示区分），那么我们就可以根据下图得知。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-c6b296754a7c63c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实例分析.png"></p>
<p>从上图可以得知，只要我们通过<strong>e.hash &amp; oldCap==0</strong>，我们就可以得知，该节点的新位置是在原位置，还是在原来的位置基础上+oldCap。不得不说这段代码非常优雅与巧妙，提高的效率不是吹的（因为没有重新取余去计算角标）。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>站在巨人的肩膀上。可以看得更远。<br>[Java 8系列之重新认识HashMap]–美团技术团队</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后，附上我写的一个基于Kotlin 仿开眼的项目<a href="https://github.com/AndyJennifer/SimpleEyes" target="_blank" rel="noopener">SimpleEyes</a>(ps: 其实在我之前，已经有很多小朋友开始仿这款应用了，但是我觉得要做就做好。所以我的项目和其他的人应该不同，不仅仅是简单的一个应用。但是，但是。但是。重要的话说三遍。还在开发阶段，不要打我)，欢迎大家follow和start.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/哈希表之HashMap(二)/" data-id="cjsheb86g000idsr7763t3ivp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-在安卓的道路上铿锵前行" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/在安卓的道路上铿锵前行/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-4ec6af876f3092d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="你不是一个人.png"></p>
<p>时间过的真快，马上现在已是2018年的最后一个月了。算算日子，从毕业到现在。从事安卓开发，快三个年头。这一路走来，着实不易，想和大家分享我的故事。分享这一路走来的点点滴滴与心路历程。或许在如此寒冷的冬季，大家能相偎取暖。</p>
<p>对于所有从事<code>IT</code>事业的工作者来说，选择这个行业的原因有千千万。而我，很幸运的就与计算机早早的结缘了。</p>
<h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>一切都应该从小学说起，小学二年纪的时候，学校开设了微机课（也就是计算机课程），而最吸引我的就是电脑中的超级玛丽。作为一个天真烂漫的小男孩。被游戏吸引而喜欢电脑。情有可原。</p>
<p>后来，在其他小学的家长们都把自己的孩子送去少年宫学奥数，学钢琴等其他特长时，我却吵着闹着要让母亲给我报电脑的培训班。也就那时我了解了计算机的基本常识，学会了用五笔打字，学会了ppt，学会了word。到现在，我也非常感谢我的母亲，<strong>在那个年代，能让我去学习我喜欢的东西是一件非常开明与可贵的事</strong>。当然我也不负众望，从小到大唯一得到的奖状，全有关于计算机。这里本来想和大家一起分享，但是搬过几次家后，这些奖状都遗失了。真的是非常遗憾与可惜。</p>
<h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>读到现在，很可能大家会觉得，又是一个<code>优越狗</code>，在晒自己的辉煌成就与亮眼的经历。但好像我并没有像大家觉得那样，<strong>我只是一个高考失利后的普通人。因为痛哭流涕，感受过痛苦，所以才会有洗心革面</strong>。</p>
<p>因为喜欢计算机，进入大学后，所以选择了计算机专业，和其他的计算机专业的学生一样，我也被那些专业知识折磨的死去活来，数据结构中的什么冒泡排序，什么栈与队列。什么二叉树，c++中的指针，什么面向对象，操作系统中的死锁，进程调度。数据库中的sql语句….</p>
<p>在编程方面，我也没有特别好的学习方法与技巧，<code>我一直都采用的笨方法</code>，我坚信书读百遍，其义自现的道理。所以对于我无法理解的知识，我总是将书看了一遍又一遍，习题中的代码敲了一遍又一遍。</p>
<p>下图就是我学习Java与Android时期的项目截图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-7ebb47de1f568273.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="javaweb.jpeg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-f43ccdf626ef3396.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android.jpeg"></p>
<p>回顾整个大学，我也不知道自己敲了多少行代码，只是单纯的凭着自己的计算机的热爱与坚持。<br>有可能，给大家一种错觉，感觉我也是特别乖巧爱学习的孩子，可是好像我的自制力还是比较差，我也玩游戏，我也玩英雄联盟。玩上瘾的时候也没日没夜。虽然工作之后会后悔自己浪费时间的行为。但是仍然怀念寝室一起开黑的日子。<strong>哎，工作之后，很难在有一群人再聚在一起，简简单单的玩游戏了</strong>。</p>
<h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><p>2016年，我开始准备实习。即将踏入社会生活的我，第一次感受到了学历和大学的重要性。一线的科技公司校招都是在名校，就算是普通的中小型公司，<strong>一个岗位,有可能是10个人，甚至是20多个人参与竞争！</strong>所以只有吃了亏，才知道有些事情的重要性。</p>
<p>所以这里由衷的建议，计算机专业的同胞兄弟姐妹们：</p>
<p>如果打算以后从事这方面的工作，请务必学好你的专业知识，多做项目，如果有想法考研的，想出国深造的，只要在家庭条件允许的情况下，那么一定要行动起来。<strong>学历这个东西，虽然不一定给你带来很好的收入，但是肯定给你提供一些不错的机会与人脉</strong>。</p>
<p>如果本科又是非985，211大学（本人并非将人分为三六九等，只是社会现实却是如此，作为一个企业，它只有通过这个来筛选他认为优秀的员工）️又不是什么富二代，官二代。星二代。那我们需要更加努力，<strong>以后的生活，除了父母亲以及要好的朋友能帮你之外。需要我们独立的去面对社会与生活</strong>。</p>
<p>当然说到这里，我也希望家长们也不要给我们灌输，初中要好好学习。考个好高中。高中要好好学习，考个好大学。然后考上了大学的这种思想了。那么大学之后呢？就没有了！没有了！what？？？<strong>在这种观念下成长的孩子，完全没有了思想，根本不知道以后要从事什么行业，到了大学就完全的释放了自己，如脱缰野马，拉都拉不住</strong>.</p>
<p>当然道理大家都懂，我就不多说什么了，可能只有自己经历过了，才会懂吧。</p>
<p>在<code>2016年4月1日愚人节</code>,那天我收到了人生中第一家公司的邀请， 上班时间为996，工资并不高，2k。但是对于当时的自己，有公司要自己都觉得是非常幸运的，我非常珍惜与感恩。就这样我踏出了职业生涯的第一步。</p>
<p>这一年，我也曾纠结过为什么需要在主线程更新ui。我也挣扎于handler机制，为事件机制抓耳挠腮，也为自定义view困扰过….每当遇见这些问题，经常鏖战到半夜。</p>
<p>这一年，我也特别幸运，遇见了我人生中第一个师傅，随时随地只要有问题请教他。他总能给及时给我解惑。对与他，我心存感激。</p>
<p>这一年，我疯狂的看书，《Android开发艺术探索》、《Android 设计模式》、《CleanCode》、《Thinking in Java》这些书籍都被我读了几遍。</p>
<p><code>这一年，终于能用自己挣的钱，给自己的家人买一些东西。</code></p>
<h3 id="四"><a href="#四" class="headerlink" title="四"></a>四</h3><p>也许，天降大任于斯人也，必先苦其心志，饿其体肤，9个月后。公司️因为资产问题，面临倒闭。没有办法，自己又再次踏上了寻找工作的道路。最终，找到了我现在所在的公司。虽然在新的公司中，还算顺风顺水，<code>但️内心却极其浮躁</code>。</p>
<p>有可能是我听到了某个我认为怎么样的同学，混的风生水起，有可能是我听到了某个同事又喜提某款车，有可能是看见了某个同事又换了最新款的苹果手机。又有可能是自己讨厌的那个人，混的比自己好。虽然这是别人的生活，虽然这一切都与我无关，但是还是会忍不住去怀疑自己，怀疑自己所做的一切。</p>
<p>尤其是加班过后，独自一个人走在回家的路上。这种感觉尤为强烈。看着身边的高楼大厦。看着穿行的车流。想想自己的工资。哎~~</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-840610a5145254d9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="软件园.jpg"></p>
<p>内心迫切与焦虑的我，为了缓解自己焦虑，我迫切的在网络上，搜索所有让我内心感到安慰的文章，《Android 2年怎么月入两万?》、《如何在5年之内赚够500万?》、《28岁之前怎么达到财务自由?》、《怎么从Android 菜鸟到大神?》….这些类似的文章我都看过。</p>
<p>我一度认为学习他人的方法，找到他人的成功窍门，复制别人所走多路，就能让自己和别人一样。但是后来证明，这一切都只是自己的臆想。</p>
<p>我也头脑发热，想走捷径，去花几千大洋去买彩票，去博那几百万万分之一的概率。幻想着一夜暴富。可最后不仅一个屁都不冒，一段时间内还让自己生活更拮据起来。</p>
<p>还好，最后我清醒了起来。我渐渐的意识到，人生是没有捷径的，所有的路，所有的坎，都需要一步一步的走，没有谁能一步登天。吃的苦中苦，方位人上人。</p>
<p><strong>感谢那段日子，让我重新认识了自己，看清了自己，也看清了以后的路。</strong></p>
<h3 id="五"><a href="#五" class="headerlink" title="五"></a>五</h3><p>2018年,经过上年的痛苦挣扎之后,我开始更加坚定自己的目标与希望。</p>
<p>这一年，我开始写博客，我开始记录自己的学习经历，我开始做自己的开源项目。<strong>我希望通过自己的努力，去我自己想去的公司。我想去大厂。我想去认识更多厉害的程序猿。</strong></p>
<p>我也不用管<code>这一年是否是互联网寒冬，我也不管各大科技公司是否裁员</code>。我并不焦虑，我也并不迷惘。因为我知道安安心心写自己的代码，学习自己想学的技术，才是不被社会淘汰的条件。焦虑，迷惘，担心。这一切的一切都没有任何作用。</p>
<p><strong>该来的都回来，该有的都会有。年轻人不要太着急，不忘初心，心怀感恩。</strong></p>
<p>我是AndyJennifer，我是成都的一个普通安卓程序员。与你相约在安卓的道路上，2019年我们继续前行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/在安卓的道路上铿锵前行/" data-id="cjsheb86h000jdsr7awv6ad5w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/23/RecyclerView-smoothScrollToPosition了解一下/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/RecyclerView滚动位置，滚动速度设置/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/从ButterKnife-kt-了解Kotlin-委托与扩展/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/Gradle系列-引导篇（一）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/哈希表初识(一)/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 AndyJennifer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/bangbangtang-32*32.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/bangbangtang-16*16.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="前言在之前的文章 Android 注解系列之APT工具(三)中，我们介绍了 APT 技术的及其使用方式，也提到了一些知名的开源框架如 Dagger2、ButterKnife、EventBus 都使用了该技术。为了让大家更好的了解 APT 技术的使用，在接下来的文章中我将会着重带领大家来了解 EventBus 中 APT 技术的使用，在了解该知识之前，需要我们对 EventBus 内部原理较为熟悉">
<meta name="keywords" content="EventBus">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 注解系列之 EventBus3 原理（四）">
<meta property="og:url" content="http://yoursite.com/2019/10/23/Android-注解系列之EventBus3原理（四）/index.html">
<meta property="og:site_name" content="AndyJennifer&#39;Blog">
<meta property="og:description" content="前言在之前的文章 Android 注解系列之APT工具(三)中，我们介绍了 APT 技术的及其使用方式，也提到了一些知名的开源框架如 Dagger2、ButterKnife、EventBus 都使用了该技术。为了让大家更好的了解 APT 技术的使用，在接下来的文章中我将会着重带领大家来了解 EventBus 中 APT 技术的使用，在了解该知识之前，需要我们对 EventBus 内部原理较为熟悉">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/10/23/Android-注解系列之EventBus3原理（四）/bus.jpg">
<meta property="og:image" content="http://yoursite.com/2019/10/23/Android-注解系列之EventBus3原理（四）/EventBus-Publish-Subscribe.png">
<meta property="og:image" content="http://yoursite.com/2019/10/23/Android-注解系列之EventBus3原理（四）/EventBus粗暴理解.jpg">
<meta property="og:image" content="http://yoursite.com/2019/10/23/Android-注解系列之EventBus3原理（四）/subscribe()实际做的事.jpg">
<meta property="og:image" content="http://yoursite.com/2019/10/23/Android-注解系列之EventBus3原理（四）/PositingThreadState与线程的关系.jpg">
<meta property="og:image" content="http://yoursite.com/2019/10/23/Android-注解系列之EventBus3原理（四）/简单事件的发送.jpg">
<meta property="og:image" content="http://yoursite.com/2019/10/23/Android-注解系列之EventBus3原理（四）/简单事件发送的整个流程.jpg">
<meta property="og:image" content="http://yoursite.com/2019/10/23/Android-注解系列之EventBus3原理（四）/订阅方法规则.png">
<meta property="og:updated_time" content="2019-10-22T16:17:31.078Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 注解系列之 EventBus3 原理（四）">
<meta name="twitter:description" content="前言在之前的文章 Android 注解系列之APT工具(三)中，我们介绍了 APT 技术的及其使用方式，也提到了一些知名的开源框架如 Dagger2、ButterKnife、EventBus 都使用了该技术。为了让大家更好的了解 APT 技术的使用，在接下来的文章中我将会着重带领大家来了解 EventBus 中 APT 技术的使用，在了解该知识之前，需要我们对 EventBus 内部原理较为熟悉">
<meta name="twitter:image" content="http://yoursite.com/2019/10/23/Android-注解系列之EventBus3原理（四）/bus.jpg">






  <link rel="canonical" href="http://yoursite.com/2019/10/23/Android-注解系列之EventBus3原理（四）/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Android 注解系列之 EventBus3 原理（四） | AndyJennifer'Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AndyJennifer'Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">What would life be if we had no courage to attempt anything?</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

  <a href="https://github.com/AndyJennifer" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/23/Android-注解系列之EventBus3原理（四）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AndyJennifer">
      <meta itemprop="description" content="AndyJennifer 个人站，主要涉及Android、Java、Kotlin等相关知识，愿与大家共同学习，共同进步">
      <meta itemprop="image" content="http://upload-images.jianshu.io/upload_images/2824145-e320240ea6ec767d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AndyJennifer'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android 注解系列之 EventBus3 原理（四）

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-23 00:17:31" itemprop="dateCreated datePublished" datetime="2019-10-23T00:17:31+08:00">2019-10-23</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码分析/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">29k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">52 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <img src="/2019/10/23/Android-注解系列之EventBus3原理（四）/bus.jpg" title="bus">
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在之前的文章 <a href="/2019/02/23/Android-注解系列之APT工具(三)/" title="Android 注解系列之APT工具(三)">Android 注解系列之APT工具(三)</a>中，我们介绍了 APT 技术的及其使用方式，也提到了一些知名的开源框架如 <a href="https://github.com/google/dagger" target="_blank" rel="noopener">Dagger2</a>、<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">ButterKnife</a>、<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a> 都使用了该技术。为了让大家更好的了解 APT 技术的使用，在接下来的文章中我将会着重带领大家来了解 EventBus 中 APT 技术的使用，在了解该知识之前，需要我们对 EventBus 内部原理较为熟悉，如果你已经熟悉其内部机制了，可以跳过该篇文章，直接阅读直接阅读 <a href="/2019/10/23/Android-注解系列之EventBus3“加速引擎”（五）/" title="Android-注解系列之EventBus3”加速引擎“（五）">Android-注解系列之EventBus3”加速引擎“（五）</a></p>
<p>阅读该篇文章，我们能够学到如下知识点：</p>
<ul>
<li>EventBus3 内部原理</li>
<li>EventBus3 订阅与发送消息原理</li>
<li>EventBus3 线程切换的原理</li>
<li>EventBus3 粘性事件的处理</li>
</ul>
<blockquote>
<p>整篇文章结合 EventBus 3.1.1 版本进行讲解。</p>
</blockquote>
<h3 id="EventBus-简介"><a href="#EventBus-简介" class="headerlink" title="EventBus 简介"></a>EventBus 简介</h3><p>EventBus 对于 Android 程序员来说应该不是很陌生，它是基于观察者模式的事件发布/订阅框架，我们常常用它来实现不同组件的通讯，后台线程通信等。</p>
<img src="/2019/10/23/Android-注解系列之EventBus3原理（四）/EventBus-Publish-Subscribe.png" title="EventBus-Publish-Subscribe">
<p>虽然 EventBus 非常简单好用，但是还是会因为 EventBus 满天飞，使程序代码结构非常混乱，难以测试和追踪。即使 EventBus 有很多诟病，但仍然不影响我们去学习其中的原理与编程思想~</p>
<h3 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h3><p>在了解 EventBus 内部原理之前，我们先了解一下 EventBus 框架的一个大概流程。如下图所示：</p>
<img src="/2019/10/23/Android-注解系列之EventBus3原理（四）/EventBus粗暴理解.jpg" title="EventBus粗暴理解">
<blockquote>
<p>上图中<code>绿色</code>为订阅流程，<code>红色</code>为发送事件流程，大家可以结合上图，来理解源码。</p>
</blockquote>
<p>在上图中我们在 <code>A.java</code> 中订阅了事件 <code>AEvent</code>，在 <code>B.java</code> 中订阅了事件 <code>AEvent</code> 与 <code>BEvent</code>，下面我们来分析 EventBus 中注册与事件发送的两个流程，在介绍两个流程之前，先介绍一下 <code>Subscription</code> 与 <code>SubscriberMethod</code> 中所包含的内容。</p>
<p><code>Subscription</code> 类中包含以下内容：</p>
<ul>
<li>当前注册对象</li>
<li>对应订阅方法的封装对象 SubscriberMethod</li>
</ul>
<p><code>SubscriberMethod</code> 类中包含以下内容：</p>
<ul>
<li>包含 <code>@Subscribe</code> 注解的方法的 Method (<code>java.lang.reflect</code> 包下的对象)。</li>
<li><code>@Subscribe</code> 注解中设置的线程模式 ThreadMode</li>
<li>方法的注册的事件类型的 Class 对象</li>
<li><code>@Subscribe</code>中设置的优先级 priority</li>
<li><code>@Subscribe</code>中设置事件是否是粘性事件 sticky</li>
</ul>
<h4 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h4><p>当我们通过调用 EventBus.register() 注册 A、B 两个对象时，EventBus 会做以下几件事件：</p>
<ul>
<li>通过内部的 <code>SubscriberMethodFinder</code> 来获取 A、B类中含有 <code>@Subscribe</code> 注解的方法，并将该注解中的内容与对应方法封装为 <code>SubscriberMethod</code> 对象。然后再将当前订阅对象与对应的 <code>SubscriberMethod</code> 再封装为 <code>Subscription</code> 对象。</li>
<li>将所有的 <code>Subscription</code> 放在名为 <code>subscriptionsByEventType</code> 类型为 <code>Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt;</code> 数据结构（key 为事件类型的 Class 对象） 中，因为 <code>Subscription</code> 对象内部包含 <code>SubscriberMethod</code>， 那么就能知道订阅的事件类型，所以我们可以根据事件类型来区分 <code>Subscription</code> ，又因为相同事件可以被不同订阅者中的方法来订阅，所以相同类型的事件也就以对应不同的 <code>Subscription</code>。</li>
<li>将订阅者中的所有订阅的事件都封装在名为 <code>typesBySubscriber</code> 类型为 <code>Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt;</code>数据结构（key 为订阅对象，value 为该对象订阅的事件类型 Class 对象）。该集合主要用于取消订阅，在下文中我们会进行介绍。</li>
</ul>
<p>在整个注册流程中，最主要的流程就是 EventBus 通过 <code>SubscriberMethodFinder</code> 去获取类中包含 <code>@Subscribe</code> 注解的订阅方法。在 EventBus 3.0 之前该流程一直都是通过<code>反射</code>的方式去获取。在 3.0 及以后版本，EventBus 采用了 APT 技术，对 <code>SubscriberMethodFinder</code> 查找订阅方法流程进行了优化，使其能在 <code>EventBus.register()</code> 方法调用之前就能知道相关订阅事件的方法，这样就减少了程序在运行期间使用反射遍历获取方法所带来的时间消耗。在下文中我们也会指出具体的优化点。</p>
<h4 id="事件发送流程"><a href="#事件发送流程" class="headerlink" title="事件发送流程"></a>事件发送流程</h4><p>知道了 EventBus 的注册过程，再来了解事件的发生流程就非常简单了。因为我们已经通过 <code>subscriptionsByEventType</code> 存储事件对应的 <code>Subscription</code>，只要找到了 <code>Subscription</code> ，那么我们就能从 <code>Subscription</code> 拿到订阅事件的对象 <code>subscriber</code> ，以及对应的订阅方法 Method (<code>java.lang.reflect</code> 包下的对象)。然后通过反射调用：</p>
<blockquote>
<p>Subscription 内部包含订阅者及 SubscriberMethod（内部包含订阅方法 Method )</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> method.invoke(subscription.subscriber, event)</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>通过上述方法，就能将对应事件发送到相关订阅者了。当然这里只是简单的介绍了事件是如何发送到相关订阅者的。关于 EventBus 中粘性事件的处理，线程如何切换。会在下文中进行详细介绍。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在了解了 EventBus 的内部大概流程后，现在我们通过源码来更深层次的了解其内部实现。还是从订阅过程与事件的发送两个过程进行讲解。</p>
<h4 id="订阅过程源码分析"><a href="#订阅过程源码分析" class="headerlink" title="订阅过程源码分析"></a>订阅过程源码分析</h4><p>EventBus 的订阅入口为 register() 方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">      Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">      <span class="comment">//流程1：获取对应类中所有的订阅方法</span></span><br><span class="line">      List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="comment">//流程2：实际订阅</span></span><br><span class="line">          <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">              subscribe(subscriber, subscriberMethod);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在该方法中，主要涉及到 SubscriberMethodFinder 查找方法与实际订阅两个流程，下面我们会对这两个流程进行介绍。</p>
<h4 id="SubscriberMethodFinder-查找方法流程"><a href="#SubscriberMethodFinder-查找方法流程" class="headerlink" title="SubscriberMethodFinder 查找方法流程"></a>SubscriberMethodFinder 查找方法流程</h4><p>在该流程中，主要通过 <code>SubscriberMethodFinder</code> 去获取订阅者中所有的 SubscriberMethod ，我们先看 <code>findSubscriberMethods()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从缓存中获取订阅者中的订阅方法，如果有则读缓存，如果没有进行查找</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = (List)METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.ignoreGeneratedIndex) &#123;<span class="comment">//如果忽略索引类，则使用反射。</span></span><br><span class="line">            subscriberMethods = <span class="keyword">this</span>.findUsingReflection(subscriberClass);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则使用索引类</span></span><br><span class="line">            subscriberMethods = <span class="keyword">this</span>.findUsingInfo(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果订阅者没有订阅方法，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将对应类中的订阅方法，添加到缓存中，提高效率，方便下次查找</span></span><br><span class="line">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">            <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的逻辑也非常简单，为如下几个步骤：</p>
<ul>
<li>步骤1：先从缓存( <code>METHOD_CACHE</code> )中获取订阅者对应的 <code>SubscriberMethod（订阅方法)</code> ，如果有则从缓存中取。</li>
<li>步骤2：如果缓存中没有，则通过布尔变量 <code>ignoreGeneratedIndex</code>，来判断是直接使用反射获取订阅方法，还是通过<code>索引类</code>(EventBus 3.0 使用APT 增加的类）来获取。因为 <code>ignoreGeneratedIndex</code> 默认值为 false ，则默认会走 <code>findUsingInfo()</code> 方法</li>
<li>步骤3：将步骤2中获得的订阅方法集合，存储到缓存中，方便下一次获取，提高效率。</li>
</ul>
<p>因为默认会走 <code>findUsingInfo()</code> 方法，我们继续查看该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//步骤1：构建了查询状态缓存池，最多缓存4个类的查询状态</span></span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//步骤2，获取查找状态对应的订阅信息，👇这里EventBus 3.0 使用了索引类，</span></span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                <span class="comment">//将订阅者的所有的订阅方法添加到FindState的集合中</span></span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//步骤3：如果订阅信息为null，则通过反射来获取类中所有的方法</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;<span class="comment">// 继续查找父类的方法</span></span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//步骤4，获取findState中的所有方法，并清空对象池</span></span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>步骤1：创建与订阅者相关的 FindState 对象。会从 FinState 对象缓存池(最大为4个)中获取，一个订阅者对象对应一个FindState，一个订阅者对象对应一个或多个订阅方法。</li>
<li>步骤2：通过 FindState 对象 调用 <code>getSubscriberInfo()</code> 方法去获取订阅者相关的订阅方法信息。该方法使用了 APT 技术，构建了EventBus的索引类。关于具体的优化，会在下篇文章中 <a href="/2019/10/23/Android-注解系列之EventBus3“加速引擎”（五）/" title="Android-注解系列之EventBus3”加速引擎“（五）">Android-注解系列之EventBus3”加速引擎“（五）</a> 进行描述，大家这里有个印象就好了。</li>
<li>步骤3：如果通过步骤2获取不到订阅方法信息，则通过<code>反射</code>来获取类中的所有的订阅方法。并将获取的方法，封装到 FindState 中的 subscriberMethods 集合中去。</li>
<li>步骤4：将 FindState 对象中的 subscriberMethods 集合返回。</li>
</ul>
<p>在上述方法中，我们需要注意的是，如果当前订阅着没有相关的订阅方法，那么会依次遍历其父类的订阅方法。还有一个知识点，就是该方法中 FindState 使用了 <code>对象缓存池</code>，不会每次注册一个订阅者就创建 一个FindState 对象。这样就节约了内存的使用。</p>
<p>关于索引类的知识点，会在下篇文章中进行介绍，这里我们直接查看 <code>findUsingReflectionInSingleClass()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">      Method[] methods;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//获取当前订阅者中的所有的方法</span></span><br><span class="line">          methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">          <span class="comment">//获取该类的所有public 方法 包括继承的公有方法</span></span><br><span class="line">          methods = findState.clazz.getMethods();</span><br><span class="line">          findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//循环遍历所有的方法，通过相关注解找到相应的订阅方法。</span></span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">          <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">          <span class="comment">//满足修饰符为 public 并且非抽象、非静态</span></span><br><span class="line">          <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">              Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">              <span class="comment">//找到参数为1，且该方法包含Subscrile注解的方法</span></span><br><span class="line">              <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                  Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                  <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                      <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                          <span class="comment">// 创建订阅方法对象，并将对应方法对象，事件类型，线程模式，优先级，粘性事件封装到SubscriberMethod对象中。</span></span><br><span class="line">                          ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                          findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                  subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                  String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                          <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">              String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                      <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>该方法的逻辑也非常简单，通过获取 FindState 中的订阅者的 Class 对象，然后通过反射获取所有包含 <code>@Subscribe</code> 注解且参数为 <code>1</code> 的 Method 对象，并读取到该参数的类型<code>EventType</code>，接着读取注解中的 <code>thredMode</code>、<code>priority</code>、<code>sticy</code>，最后将这些数据都统一分装到新建的<code>SubscriberMethod</code> 对象中，最后将该对象添加到 FindState 中的 subscriberMethods 集合中去。</p>
<h4 id="实际订阅方法-subscribe"><a href="#实际订阅方法-subscribe" class="headerlink" title="实际订阅方法 subscribe"></a>实际订阅方法 subscribe</h4><p>当找到订阅者所有的方法集合后，最终会遍历调用 <code>subscribe()</code> 方法，查看该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//步骤1，将每个订阅方法和订阅者封装成Subscription</span></span><br><span class="line">        Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//步骤2，获取对应事件中所有的 Subscription，判断是否重复添加</span></span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = (CopyOnWriteArrayList)<span class="keyword">this</span>.subscriptionsByEventType.get(eventType);</span><br><span class="line">        <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line">            <span class="keyword">this</span>.subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span> + eventType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//步骤3，根据优先级，将当前新封装的Subscription对象添加到subscriptionsByEventType中去</span></span><br><span class="line">        <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; ((Subscription)subscriptions.get(i)).subscriberMethod.priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//步骤4，将当前订阅者中与当前订阅者所订阅的事件类型，添加到typesBySubscriber中去</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = (List)<span class="keyword">this</span>.typesBySubscriber.get(subscriber);</span><br><span class="line">        <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscribedEvents = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">this</span>.typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//步骤5，如果该方法有订阅了粘性事件，则从stickyEvents中获取相应粘性事件，并发送</span></span><br><span class="line">        <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        Object stickyEvent = entry.getValue();</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object stickyEvent = <span class="keyword">this</span>.stickyEvents.get(eventType);</span><br><span class="line">                <span class="keyword">this</span>.checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在上述方法中主要流程如下：</p>
<ul>
<li>步骤1，将每个订阅方法和订阅者封装成 Subscription。</li>
<li>步骤2，获取对应事件中所有的 Subscription ，判断是否重复添加。</li>
<li>步骤3，根据 <code>优先级</code>，将当前新封装的 Subscription 对象添加到 subscriptionsByEventType 中去。(设置了优先级后，EvenBus 就可以按照优先级顺序，将事件发送给订阅者)</li>
<li>步骤4，将当前订阅者中与当前订阅者所订阅的事件类型，添加到 typesBySubscriber 中去。</li>
<li>步骤5，如果该方法有订阅了粘性事件，则从 stickyEvents 中获取相应粘性事件，并发送。</li>
</ul>
<p>再结合我们最开始所画的 EventBus 大致流程，该方法其实就做了下图<code>红色虚线框</code>中的事：</p>
<img src="/2019/10/23/Android-注解系列之EventBus3原理（四）/subscribe()实际做的事.jpg" title="subscribe()实际做的事">
<p>关于粘性事件的知识点，需要我们了解事件的发送流程，我们会在下文进行详细介绍。</p>
<h3 id="事件发送流程源码分析"><a href="#事件发送流程源码分析" class="headerlink" title="事件发送流程源码分析"></a>事件发送流程源码分析</h3><p>事件的发送，主要分为<code>简单事件</code>与<code>粘性事件</code>，分别对应方法为  <code>post()</code> 与 <code>postSticky()</code> 两个方法。这里我们先看简单事件的发送，代码如下:</p>
<h4 id="简单事件的发送"><a href="#简单事件的发送" class="headerlink" title="简单事件的发送"></a>简单事件的发送</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//步骤1，获取当前线程中独立拥有的PostingThreadState，并从中获取事件队列（eventQueue），将发送的事件添加到该队列中</span></span><br><span class="line">      EventBus.PostingThreadState postingState = (EventBus.PostingThreadState)<span class="keyword">this</span>.currentPostingThreadState.get();</span><br><span class="line">      List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">      eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//步骤2：判断当前线程是否正在分发事件，如果不是，则循环遍历事件队列中的事件，并将事件分发出去，直到当前事件队列空为止</span></span><br><span class="line">      <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">          postingState.isMainThread = <span class="keyword">this</span>.isMainThread();</span><br><span class="line">          postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">//如果当前分发事件状态为取消，则抛出异常</span></span><br><span class="line">          <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//循环遍历事件队列，并将消息发送出去</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">while</span>(!eventQueue.isEmpty()) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">              postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在 EventBus 中会为个每调用 post() 方法的线程都会创建一个唯一的 <code>PostingThreadState</code> 对象，用于记录当前线程存储发送消息与发送的状态，其内部结构如下所示：</p>
<img src="/2019/10/23/Android-注解系列之EventBus3原理（四）/PositingThreadState与线程的关系.jpg" title="PositingThreadState与线程的关系">
<blockquote>
<p>PostingThreadState 使用了 ThreadLocal 不熟悉 ThreadLocal 的小伙伴，可以查看该篇文章：Android Handler机制之ThreadLocal</p>
</blockquote>
<p>也就是说当我们调用 <code>EventBus.post()</code> 方法，其实是从 EventQueue 队列中取出消息，然后通过调用 postSingleEvent（）方法 来实际发送消息，该方法代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, EventBus.PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">      Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">      <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">//步骤1：👇判断否事件传递发送</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.eventInheritance) &#123;</span><br><span class="line">          List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">          <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; ++h) &#123;</span><br><span class="line">              Class&lt;?&gt; clazz = (Class)eventTypes.get(h);</span><br><span class="line">              <span class="comment">//👇循环遍历遍历事件并发送</span></span><br><span class="line">              subscriptionFound |= <span class="keyword">this</span>.postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//步骤2：👇如果不支持事件的传递，那么这里开始发送事件。</span></span><br><span class="line">          subscriptionFound = <span class="keyword">this</span>.postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//步骤3：如果没有找到订阅的方式，提示用户</span></span><br><span class="line">      <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.logNoSubscriberMessages) &#123;</span><br><span class="line">              <span class="keyword">this</span>.logger.log(Level.FINE, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">              <span class="keyword">this</span>.post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要为如下三个步骤：</p>
<ul>
<li>步骤1：通过布尔变量 <code>eventInheritance</code> 判断是否支持事件是否传递发送，如果支持，那么通过<code>lookupAllEventTypes()</code> 方法获得发送事件祖先类及其接口。然后通过 <code>postSingleEventForEventType()</code>方法，将它们都发送出去，</li>
<li>步骤2：步骤1返回 false 那么就直接使用 <code>postSingleEventForEventType()</code> 方法发送事件。</li>
<li>步骤3：如果没有找到相关的订阅方法，那么就提示用户没有相关的订阅方法。</li>
</ul>
<blockquote>
<p>布尔变量 <code>eventInheritance</code> 默认为 <code>false</code> ,我们可以通过 EventBusBuilder 来配置该变量的值。</p>
</blockquote>
<p>那什么是事件的传递发送呢？我们来查看 <code>lookupAllEventTypes()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (eventTypesCache) &#123;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</span><br><span class="line">        <span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Class&lt;?&gt; clazz = eventClass;</span><br><span class="line">            <span class="comment">//👇获取该类所有祖先类及其接口</span></span><br><span class="line">            <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                eventTypes.add(clazz);</span><br><span class="line">                addInterfaces(eventTypes, clazz.getInterfaces());</span><br><span class="line">                clazz = clazz.getSuperclass();</span><br><span class="line">            &#125;</span><br><span class="line">            eventTypesCache.put(eventClass, eventTypes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eventTypes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将接口添加到集合中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInterfaces</span><span class="params">(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; interfaceClass : interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!eventTypes.contains(interfaceClass)) &#123;</span><br><span class="line">            eventTypes.add(interfaceClass);</span><br><span class="line">            addInterfaces(eventTypes, interfaceClass.getInterfaces());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该方法中，会获取发送事件的所有的祖先类及其接口，最后将他们以集合的方式返回，在 <code>postSingleEvent</code> 方法中拿到这个集合之后，那么就会将集合中所有的数据都发送出去。这样做会造成什么效果呢？如果当前我们的继承体系为 Aevent -&gt; Bevent -&gt; Cevent ( <code>-&gt;</code> 表示继承)，那么通过发送 Aevent，那么其他所有订阅过 Bevent 及 Cevent 的订阅者都会收到消息。</p>
<p>我们继续查看 <code>postSingleEventForEventType()</code> 方法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="comment">//👇从缓存中拿取之前存取的 Subscription</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//👇这里找到相应的方法后，开始切换线程了。</span></span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的逻辑非常简单，就是从我们之前的 <code>subscriptionsByEventType</code> 集合中拿到存储的 <code>Subscription</code>，并根据当前线程状态设置关联的 <code>PostingState</code> 中 <code>canceled</code> 、<code>subscription</code> 、<code>isMainThread</code> 等属性值，然后通过 <code>postToSubscription()</code> 方法来真正的执行事件的传递。</p>
<p>到目前为止整个流程如下所示：</p>
<img src="/2019/10/23/Android-注解系列之EventBus3原理（四）/简单事件的发送.jpg" title="简单事件的发送">
<h4 id="postToSubscription"><a href="#postToSubscription" class="headerlink" title="postToSubscription()"></a>postToSubscription()</h4><p>postToSubscription() 方法是真正实际将事件传递到订阅者的代码。查看该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述方法中，我们拿到 <code>Subscription</code> 中成员变量 <code>SubscriberMethod</code> 中的线程模式 <code>threadMode</code> 来判断订阅方法需要执行的线程。如果当前线程模式是 <code>POSTING</code> ，那么默认就直接调用 <code>invokeSubscriber()</code> 方法。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//👇直接通过反射调用订阅方法。</span></span><br><span class="line">        subscription.subscriberMethod.method.</span><br><span class="line">        invoke(subscription.subscriber, event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果为其他模式，那么会根据相应的 <code>poster</code> 调用 <code>enqueue()</code> 方法来控制执行订阅方法所在的线程。在 EventBus 中提供了如下三个 Poster 来控制订阅方法的所运行的线程。</p>
<ul>
<li>HandlerPoster （切换到主线程）</li>
<li>BackgroundPoster （切换到后台线程）</li>
<li>AsyncPoster （切换到后台线程）</li>
</ul>
<p>以上三个 Poster 都实现了 Poster 接口，且内部都维护了一个名为 <code>PendingPostQueue</code> 的队列，该队列以 <code>PendingPost</code> 为存储单元，其中 <code>PendingPost</code> 中存储内容为我们根据当前事件所找到的 <code>Subscription</code> 与当前所发生的事件。</p>
<p>那么结合整个流程，我们能得到下图：</p>
<img src="/2019/10/23/Android-注解系列之EventBus3原理（四）/简单事件发送的整个流程.jpg" title="简单事件发送的整个流程">
<p>针对上图，再进行一下简单的说明。</p>
<ul>
<li>当我们调用 <code>EventBus.post()</code> 发送简单事件时，会将该事件放入与线程相关的 <code>PostingThreadState</code> 的 <code>EventQueue</code> 中。</li>
<li>接着会从之前在 <code>subscriptionsByEventType</code> 集合中找到与该事件相关的 <code>Subscription</code>。</li>
<li>接着将找到的 <code>Subscription</code> 与当前所发送的事件都封装为 <code>PendingPost</code> 并添加到对应 <code>Poster</code> 中的 <code>PendingPostQueue</code> 队列中。</li>
<li>最后对应的 <code>Poster</code> 从队列中取出相应的 <code>PendingPost</code>,通过反射调用订阅者的订阅方法。</li>
</ul>
<p>其中订阅方法执行线程的规则，如下所示：</p>
<img src="/2019/10/23/Android-注解系列之EventBus3原理（四）/订阅方法规则.png" title="订阅方法规则">
<h4 id="线程的切换"><a href="#线程的切换" class="headerlink" title="线程的切换"></a>线程的切换</h4><p>在上节中，订阅者的订阅方法执行的所在线程，是由 EventBus 中内部的三个 <code>Poster</code>来实现的。那下面我们就来看看这三个 <code>Poster</code> 的实现。</p>
<h5 id="HandlerPoster"><a href="#HandlerPoster" class="headerlink" title="HandlerPoster"></a>HandlerPoster</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Poster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认会传递主线程的Looper</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HandlerPoster</span><span class="params">(EventBus eventBus, Looper looper, <span class="keyword">int</span> maxMillisInsideHandleMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        <span class="keyword">this</span>.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;</span><br><span class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//👇这里将PedingPost放入PendingPostQueue中，然后发送消息</span></span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">                handlerActive = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//👇从队列中取出最近的PendingPost</span></span><br><span class="line">                PendingPost pendingPost = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            handlerActive = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//👇直接通过反射，调用订阅者的订阅方法。</span></span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">                <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    rescheduled = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            handlerActive = rescheduled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HanderPoster 中的逻辑非常容易理解，继承 Handler，并在初始化的时候默认会关联 <code>主线程</code> 的 Looper，这样该 Handler 所发送的消息将会在主线程中被处理。</p>
<p>分析一下 HanderPoster 中主要的步骤：</p>
<ul>
<li>在调用 <code>enqueue()</code> 方法时，会将之前我们封装好的 <code>PendingPost</code> 放入 <code>PendingPostQueue</code> 队列中，同时发送消息。</li>
<li>在 <code>handleMessage()</code> 方法中，从 <code>PendingPostQueue</code> 队列中取出最近的 <code>PendingPost</code>，然后直接通过 <code>eventBus.invokeSubscriber()</code> 反射执行订阅者的订阅方法。</li>
</ul>
<h5 id="BackgroundPoster"><a href="#BackgroundPoster" class="headerlink" title="BackgroundPoster"></a>BackgroundPoster</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Poster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executorRunning;</span><br><span class="line"></span><br><span class="line">    BackgroundPoster(EventBus eventBus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="comment">//使用线程池来提交任务，该方法是线程安全的。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span> (!executorRunning) &#123;</span><br><span class="line">                executorRunning = <span class="keyword">true</span>;</span><br><span class="line">                eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    PendingPost pendingPost = queue.poll(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                            <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                            pendingPost = queue.poll();</span><br><span class="line">                            <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                executorRunning = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + <span class="string">" was interruppted"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorRunning = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BackgroundPoster 与 HandlerPoster 最大的不同是其内部使用了线程池，并且该类也实现了 Runnable 接口。</p>
<p>在 BackgroundPoster 中的 <code>enqueue()</code> 方法中，默认会使用 EventBus 中默认的线程池 <code>DEFAULT_EXECUTOR_SERVICE</code>来提交任务 ，该线程池的声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CachedThreadPool 适用于大量的且耗时较少的任务</p>
</blockquote>
<p>同样的，BackgroundPoster 也就是通过反射调用订阅者的订阅方法，只不过不同的是它是放入线程池中的非主线程中进行执行。</p>
<p>需要注意的是不管是在任何线程中发送消息，EventBus 总是线程安全的。从 BackgroundPoster 的代码中我们就可以看出。</p>
<h5 id="AsyncPoster"><a href="#AsyncPoster" class="headerlink" title="AsyncPoster"></a>AsyncPoster</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Poster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    AsyncPoster(EventBus eventBus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No pending post available"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不对 AsyncPoster 进行讲解了，相信大家根据之前的内容也能理解。</p>
<h4 id="粘性事件的发送"><a href="#粘性事件的发送" class="headerlink" title="粘性事件的发送"></a>粘性事件的发送</h4><p>现在我们还剩最后一个知识点了，就是粘性事件的发送。在 EventBus 中发送粘性事件，我们需要调用方法 <code>postSticky()</code> 方法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSticky</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">          stickyEvents.put(event.getClass(), event);</span><br><span class="line">      &#125;</span><br><span class="line">      post(event);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从代码中，我们不难看出，粘性的事件发送与简单事件的发送唯一的区别就是将发送的事件添加到 <code>stickyEvents</code> 集合中去了。那为什么要这么做呢？在了解具体的原因之前，我们需要了解粘性事件的概念。</p>
<p>粘性事件的概念：当订阅者还没有订阅相关事件 <code>A</code> 时，程序已经发送了一些事件 <code>A</code>，按照正常的逻辑，当订阅者开始订阅事件 <code>A</code> 时，是接受不到程序已经发送过的事件 <code>A</code> ,但是我们希望接受到那些已经发送过的消息。这种已经过时，但又被重新接受的事件，我们称之为粘性事件。</p>
<p>那么根据粘性事件的思想，我们需要将已经发送的事件存储下来，并在粘性事件的订阅的过程中进行特别的处理，也就是在 <code>EventBus.register()</code> 方法中进行处理。还记得之前注册过程中的 <code>subscribe()</code> 方法吗？该方法内部对粘性事件进行了特殊的处理，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//省略部分代码</span></span><br><span class="line">       <span class="comment">//判断是否是粘性事件</span></span><br><span class="line">       <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">           <span class="comment">//👇支持事件传递的粘性事件</span></span><br><span class="line">           <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">               Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">               <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                   Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                   <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                       Object stickyEvent = entry.getValue();</span><br><span class="line">                       checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//👇开始执行订阅方法。</span></span><br><span class="line">               Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">               checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在上述逻辑中，会从 <code>stickyEvents</code> 中获取之前发送的事件，然后调用 <code>checkPostStickyEventToSubscription()</code>。该方法代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">           postToSubscription(newSubscription, stickyEvent, isMainThread());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>又因为<code>checkPostStickyEventToSubscription()</code> 方法内部会调用 <code>postToSubscription()</code> 方法。那么最终订阅者就能接受到之前发送的事件，并执行相应的订阅方法啦。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>EventBus 主要的流程到现在已经讲完了。从实际的代码中，我们不仅能看到其良好的代码规范以及封装思想。还能看到该框架对性能的优化，尤其是添加了一些必要的缓存。我相信以上的这些点，都是值得我们借鉴与参考的。在接下来的文章中我们会讲解 EventBus 中的 <code>“加速引擎&quot;</code>  索引类。有兴趣的小伙伴可以继续关注。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/EventBus/" rel="tag"># EventBus</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/23/Android-注解系列之EventBus3“加速引擎”（五）/" rel="next" title="Android-注解系列之EventBus3”加速引擎“（五）">
                <i class="fa fa-chevron-left"></i> Android-注解系列之EventBus3”加速引擎“（五）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/19/Androidx下Fragment的懒加载/" rel="prev" title="Androidx 下 Fragment 懒加载的新实现">
                Androidx 下 Fragment 懒加载的新实现 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://upload-images.jianshu.io/upload_images/2824145-e320240ea6ec767d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AndyJennifer">
            
              <p class="site-author-name" itemprop="name">AndyJennifer</p>
              <p class="site-description motion-element" itemprop="description">AndyJennifer 个人站，主要涉及Android、Java、Kotlin等相关知识，愿与大家共同学习，共同进步</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">60</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/AndyJennifer" title="GitHub &rarr; https://github.com/AndyJennifer" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/andyjennifer@126.com" title="E-Mail &rarr; andyjennifer@126.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventBus-简介"><span class="nav-number">2.</span> <span class="nav-text">EventBus 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大概流程"><span class="nav-number">3.</span> <span class="nav-text">大概流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注册流程"><span class="nav-number">3.1.</span> <span class="nav-text">注册流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件发送流程"><span class="nav-number">3.2.</span> <span class="nav-text">事件发送流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析"><span class="nav-number">4.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#订阅过程源码分析"><span class="nav-number">4.1.</span> <span class="nav-text">订阅过程源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SubscriberMethodFinder-查找方法流程"><span class="nav-number">4.2.</span> <span class="nav-text">SubscriberMethodFinder 查找方法流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实际订阅方法-subscribe"><span class="nav-number">4.3.</span> <span class="nav-text">实际订阅方法 subscribe</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件发送流程源码分析"><span class="nav-number">5.</span> <span class="nav-text">事件发送流程源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单事件的发送"><span class="nav-number">5.1.</span> <span class="nav-text">简单事件的发送</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#postToSubscription"><span class="nav-number">5.2.</span> <span class="nav-text">postToSubscription()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的切换"><span class="nav-number">5.3.</span> <span class="nav-text">线程的切换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HandlerPoster"><span class="nav-number">5.3.1.</span> <span class="nav-text">HandlerPoster</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BackgroundPoster"><span class="nav-number">5.3.2.</span> <span class="nav-text">BackgroundPoster</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AsyncPoster"><span class="nav-number">5.3.3.</span> <span class="nav-text">AsyncPoster</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#粘性事件的发送"><span class="nav-number">5.4.</span> <span class="nav-text">粘性事件的发送</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最后"><span class="nav-number">6.</span> <span class="nav-text">最后</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AndyJennifer</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">612k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">18:32</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.0"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>

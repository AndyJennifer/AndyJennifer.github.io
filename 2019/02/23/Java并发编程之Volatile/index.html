<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>AndyJennifer‘Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="该文章属于《Java并发编程》系列文章，如果想了解更多，请点击《Java并发编程之总目录》  前言在前面的文章中,我们已经了解了Java的内存模型，了解了其可见性问题及指令重排序及Happen-Before原则，现在我们来了解一下关键字volatile。在Java中volatile可以算是Java提供的轻量级同步实现机制，但是在平时开发中，我们更多的是使用synchronized来进行同步。对">
<meta name="keywords" content="AndyJennifer">
<meta property="og:type" content="article">
<meta property="og:title" content="AndyJennifer‘Blog">
<meta property="og:url" content="http://yoursite.com/2019/02/23/Java并发编程之Volatile/index.html">
<meta property="og:site_name" content="AndyJennifer‘Blog">
<meta property="og:description" content="该文章属于《Java并发编程》系列文章，如果想了解更多，请点击《Java并发编程之总目录》  前言在前面的文章中,我们已经了解了Java的内存模型，了解了其可见性问题及指令重排序及Happen-Before原则，现在我们来了解一下关键字volatile。在Java中volatile可以算是Java提供的轻量级同步实现机制，但是在平时开发中，我们更多的是使用synchronized来进行同步。对">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-358b7664b318447b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-1f1b6e527993d110.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-a8134e7dee718eea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-1c644c59dafc8ac9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-c71aa78c0a3ca6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-e82e7109769d664a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-09aecb1676378953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-1c33efb57c437b3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-e20b80eb434f66ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-02-23T08:52:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AndyJennifer‘Blog">
<meta name="twitter:description" content="该文章属于《Java并发编程》系列文章，如果想了解更多，请点击《Java并发编程之总目录》  前言在前面的文章中,我们已经了解了Java的内存模型，了解了其可见性问题及指令重排序及Happen-Before原则，现在我们来了解一下关键字volatile。在Java中volatile可以算是Java提供的轻量级同步实现机制，但是在平时开发中，我们更多的是使用synchronized来进行同步。对">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2824145-358b7664b318447b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="AndyJennifer‘Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AndyJennifer‘Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">What would life be if we had no courage to attempt anything?</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java并发编程之Volatile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之Volatile/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-358b7664b318447b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="认真.png"></p>
<blockquote>
<p>该文章属于《Java并发编程》系列文章，如果想了解更多，请点击《Java并发编程之总目录》</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前面的文章中,我们已经了解了Java的内存模型，了解了其可见性问题及指令重排序及Happen-Before原则，现在我们来了解一下关键字<strong>volatile</strong>。在Java中volatile可以算是Java提供的轻量级同步实现机制，但是在平时开发中，我们更多的是使用synchronized来进行同步。对于volatile，大家总是不能正确的且完整的理解。所以下面，我就和大家一起来了解一下volatile。</p>
<h3 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h3><h4 id="线程的可见性"><a href="#线程的可见性" class="headerlink" title="线程的可见性"></a>线程的可见性</h4><p>当一个变量定义为volatile后，那么该变量对所有线程都是“可见的”，其中“可见的”是指当一条线程修改了这个变量的值，那么新值对于其他线程来说是可以立即知道的。可能大家还是不好的理解。如果你阅读过上篇文章<a href="https://www.jianshu.com/p/355b91f7baa8" target="_blank" rel="noopener">Java并发编程之Java内存模型</a>，你应该很快的理解。不过没有大碍，通过下列图片大家应该很快的了解。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-1f1b6e527993d110.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile可见性.png"></p>
<p>我们已经知道在Java内存模型中，内存分为了线程的工作内存及主内存。在上图中，线程A与线程B分别从主内存中获取变量a(<strong>用volatile修饰</strong>)到自己的工作内存中，也就是现在线程A与线程B中工作内存中的a现在的变量为12，当线程A修改a的值为8时，会将修改后的值（a=8)同步到主内存中，同时那么会导致线程B中的<strong>缓存a变量的值（a=12)无效</strong>，会让线程B重新重主内存中<strong>获取新的值(a=8)</strong>。</p>
<h4 id="volatile可见性的原理"><a href="#volatile可见性的原理" class="headerlink" title="volatile可见性的原理"></a>volatile可见性的原理</h4><p>在上篇文章<a href="https://www.jianshu.com/p/355b91f7baa8" target="_blank" rel="noopener">Java并发编程之Java内存模型</a>中我们曾经讲过，物理计算机为了处理缓存不一致的问题。提出了缓存一致性的协议，其中缓存一致性的核心思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<p>既然volatile修饰的变量能具有“可见性”，那么volatile内部肯定是走的底层，同时也肯定满足缓存一致性原则。因为涉及到底层汇编，这里我们不要去了解汇编语言，我们只要知道当用volatile修饰变量时，生成的汇编指令会比普通的变量声明会多一个<strong>Lock</strong>指令。那么<strong>Lock</strong>指令会在多核处理器下会做两件事情。</p>
<ul>
<li>将当前处理器缓存行的数据直接写会到系统内存中（从Java内存模型来理解，就是将线程中的工作内存的数据直接写入到主内存中）</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效（从Java内存模型理解，当线程A将工作内存的数据修改后（新值），同步到主内存中，那么线程B从主内存中初始的值（旧值）就无效了）</li>
</ul>
<h4 id="防止重排序"><a href="#防止重排序" class="headerlink" title="防止重排序"></a>防止重排序</h4><p>同样的在上篇文章《Java并发编程之内存模型》中，我们提到了为了提高CPU(处理器)的处理数据的速度，CPU(处理器)会对没有数据依赖性的指令进行重排序，但是CPU(处理器)的重排序会对多线程带来问题。具体问题我们用下列伪代码来阐述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    private int a = 0;</span><br><span class="line">    private boolean isInit = false;</span><br><span class="line">    private Config config;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        config = readConfig();//1</span><br><span class="line">        isInit = true;//2</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        if (isInit) &#123;//3</span><br><span class="line">            doSomethingWithconfig();//4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>isInit用来标志是否已经初始化配置。其中1，2操作是没有数据依赖性，同理3、4操作也是没有数据依赖性的。那么CPU(处理器)可能对1、2操作进行重排序。对3、4操作进行重排序。现在我们加入线程A操作Init()方法，线程B操作doSomething()方法，那么我们看看重排序对多线程情况下的影响。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-a8134e7dee718eea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="程序执行顺序.png"></p>
<p>上图中2操作排在了1操作前面。当CPU时间片转到线程B。线程B判断 if (isInit)为true,接下来接着执行 doSomethingWithconfig(),但是我们Config还没有初始化。所以在多线程的情况下。重排序会影响程序的执行结果。所以为了防止重排序带来的问题。Java内存模型规定了使用volatile来修饰相应变量时，可以防止CPU(处理器)在处理指令的时候禁止重排序。具体如下图所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    private int a = 0;</span><br><span class="line">    private volatile boolean isInit = false;</span><br><span class="line">    private Config config;</span><br><span class="line">	 public void init() &#123;</span><br><span class="line">        config = readConfig();//1</span><br><span class="line">        isInit = true;//2</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        if (isInit) &#123;//3</span><br><span class="line">            doSomethingWithconfig();//4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="volatile防止重排序规则"><a href="#volatile防止重排序规则" class="headerlink" title="volatile防止重排序规则"></a>volatile防止重排序规则</h4><p>那么为了处理CPU重排序的问题。Java定义了以下规则防止CPU的重排序。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-1c644c59dafc8ac9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile重排序规则.png"></p>
<p>从上表我们可以看出</p>
<ul>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序，这个规则确保voatile写之前的操作不会被编译器排序到volatile之后。</li>
<li>当第二个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当第一个操作是volatile写，第二个操作如果是volatile读时，不能进行重排序。</li>
</ul>
<h4 id="volatile防止重排序原理"><a href="#volatile防止重排序原理" class="headerlink" title="volatile防止重排序原理"></a>volatile防止重排序原理</h4><p>为了具体实现上诉我们提到的重排序规则，在Java中对于volatile修饰的变量，编译器在生成字节码时，会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序问题。在了解<strong>内存屏障</strong>之前，我们先复习之前的主内存与工作内存交互的8种原子操作，因为内存屏障主要是对Java内存模型的几种原子操作进行限制的。具体内存8种原子操作，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-c71aa78c0a3ca6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8种操作.png"><br>上述8中原子操作中，我们所涉及的是store与load操作，如果需要了解剩余6种操作，请参看上篇文章<a href="https://www.jianshu.com/p/355b91f7baa8" target="_blank" rel="noopener">Java并发编程之Java内存模型</a>。</p>
<p>这里对内存屏障所涉及到的两种操作进行解释：</p>
<ul>
<li>load：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存变量副本中。</li>
<li>store：作用于工作内存的变量，它把工作内存中一个变量值传送到主内存中。以便随后的write操作。</li>
</ul>
<h5 id="内存屏障插入策略"><a href="#内存屏障插入策略" class="headerlink" title="内存屏障插入策略"></a>内存屏障插入策略</h5><p>下面是基于volatile修饰的变量，编译器在指令序列插入的内存屏障<strong>保守插入策略</strong>如下：</p>
<ul>
<li>在每个volatile写操作的前面插入一个storestore屏障。</li>
<li>在每个volatile写操作的后面插入一个storeload屏障。</li>
<li>在每个volatile读操作的后面插入一个loadload屏障。</li>
<li>在每个volatile读操作的后面插入一个loadstore屏障。</li>
</ul>
<h4 id="volatile写内存屏障"><a href="#volatile写内存屏障" class="headerlink" title="volatile写内存屏障"></a>volatile写内存屏障</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-e82e7109769d664a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile写屏障.png"></p>
<ul>
<li>storestore屏障：对于这样的语句store1; storestore; store2，在store2及后续写入操作执行前，保证store1的写入操作对其它处理器可见。(也就是说如果出现storestore屏障，那么store1指令一定会在store2之前执行，CPU不会store1与store2进行重排序)</li>
<li>storeload屏障：对于这样的语句store1; storeload; load2，在load2及后续所有读取操作执行前，保证store1的写入对所有处理器可见。(也就是说如果出现storeload屏障，那么store1指令一定会在load2之前执行,CPU不会对store1与load2进行重排序)</li>
</ul>
<h4 id="volatile读内存屏障"><a href="#volatile读内存屏障" class="headerlink" title="volatile读内存屏障"></a>volatile读内存屏障</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-09aecb1676378953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile读屏障.png"></p>
<ul>
<li>loadload屏障：对于这样的语句load1; loadload; load2，在load2及后续读取操作要读取的数据被访问前，保证load1要读取的数据被读取完毕。（也就是说，如果出现loadload屏障，那么load1指令一定会在load2之前执行，CPU不会对load1与load2进行重排序）</li>
<li>loadstore屏障：对于这样的语句load1; loadstore; store2，在store2及后续写入操作被刷出前，保证load1要读取的数据被读取完毕。（也就是说，如果出现loadstore屏障，那么load1指令一定会在store2之前执行，CPU不会对load1与store2进行重排序）</li>
</ul>
<h4 id="编译器内存屏障的优化"><a href="#编译器内存屏障的优化" class="headerlink" title="编译器内存屏障的优化"></a>编译器内存屏障的优化</h4><p>上面我们讲到了在插入内存屏障时，编译器如果<strong>采用保守策略的情况下</strong>，分别会在volatile写与volatile读插入不同的内存屏障，那现在我们来看一下，在实际开发中，编译器在使用内存屏障时的优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileBarrierDemo &#123;</span><br><span class="line">    int a;</span><br><span class="line">    volatile int v1 = 1;</span><br><span class="line">    volatile int v2 = 2;</span><br><span class="line"></span><br><span class="line">    public void readAndWrite() &#123;</span><br><span class="line">        int i = v1;//第一个volatile读</span><br><span class="line">        int j = v2;//第二个volatile读</span><br><span class="line">        a = i + j;//普通写</span><br><span class="line">        v1 = i + 1;//第一个volatile写</span><br><span class="line">        v2 = j * 2;//第二个volatile写</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么针对上述代码，我们生成相应的屏障（图片在手机端观看可能会不太清除，建议在pc端上观看）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-1c33efb57c437b3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏障优化图.png"></p>
<p>观察上图，我们发现，在编译器生成屏障时，省略了第一个volatile读下的loadstore屏障，省略了第二个volatile读下的loadload屏障，省略了第一个volatile写下的storeload屏障。结合上诉我们所讲的loadstore屏障、loadload屏障、storeload屏障下的语义，我们能得到省略以下屏障的原因。</p>
<ul>
<li>省略第一个volatile读下的loadstore屏障：因为第一个volatile读下的下一个操作是第二个volatile的读，并不涉及到写的操作（也就是store)。所以可以省略。</li>
<li>省略第二个volatile读下的loadload屏障：因为第二个volatile读的下一个操作是普通写，并不涉及到读的操作（也就是load)。所以可以省略</li>
<li>省略第一个volatile写下的storeload屏障：因为第一个volatile写的下一个操作是第二个volatile的写，并不涉及到读的操作（也就是load)。所以可以省略。</li>
</ul>
<p><strong>其中大家要注意的是，优化结束后的storeload屏障时不能省略的，因为在第二个volatile写之后，方法理解return,此时编译器可能无法确定后面是否会有读写操作，为了安全起见，编译器通常会在这里加入一个storeload屏障。</strong></p>
<h4 id="处理器内存屏障的优化"><a href="#处理器内存屏障的优化" class="headerlink" title="处理器内存屏障的优化"></a>处理器内存屏障的优化</h4><p>上面我们讲了编译器在生成屏障的时候，会根据程序的逻辑操作省略不必要的内存屏障。但是由于不同的处理器有不同的“松耦度”的内存模型，内存屏障的优化根据不同的处理器有着不同的优化方式。以x86处理器为例。针对我们上面所描述的编译器内存屏障优化图。在x86处理器中，除最后的storeload屏障外，其他的屏障都会省略。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-e20b80eb434f66ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="x86处理器优化后.png"></p>
<p>x86处理器与其他处理器的内存屏障的优化，这里不过的描述，有兴趣的小伙伴可以查阅相关资料继续研究。</p>
<h3 id="volatile的使用注意事项"><a href="#volatile的使用注意事项" class="headerlink" title="volatile的使用注意事项"></a>volatile的使用注意事项</h3><p> <strong>在volatile使用的时候，需要注意volatile只保证可见性，并不能保证原子性</strong>，这里所提到的<strong>原子性</strong>需要给大家补充一个知识点。</p>
<h4 id="原子性定义"><a href="#原子性定义" class="headerlink" title="原子性定义"></a>原子性定义</h4><blockquote>
<p>在Java中，对基本的数据类型的变量的<strong>访问和读写</strong>操作都是原子性操作，且这些操作在CPU中不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p>
</blockquote>
<p>直接通过定义来理解确实比较困难，通过下面这个例子，让我们一起来了解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 10;         //语句1</span><br><span class="line">x++;           //语句2</span><br><span class="line">x = x + 1;     //语句3</span><br></pre></td></tr></table></figure></p>
<p>大家可以来猜一猜，以上3个语句有哪些是具有原子性呢。好了。我告诉答案吧，<strong>只有语句1具有原子性。</strong>大家对此会感到很疑惑。</p>
<p>对于语句1：是直接将数值10赋给x,也就是直接将数值10赋值到工作内存中。<br>对于语句2：先去读取x的值，然后计算x加上1后的值，最后将计算后的值赋值给x，<br>对于语句3：同语句3。</p>
<p>对于语句2，3因为涉及到多个操作，且在多线程的情况下，CPU可以进行时间片的切换操作（也就是可以暂停在某个操作后）。那么就可能出现线程安全的问题。</p>
<h4 id="volatile为什么不具备原子性"><a href="#volatile为什么不具备原子性" class="headerlink" title="volatile为什么不具备原子性"></a>volatile为什么不具备原子性</h4><p>描述了原子性后，相信大家都会有个疑问“volatile不具备原子性有什么关系呢？其实原因很简单，虽然volatile是具备可见性的（也就是指当一条线程修改了这个变量的值，那么新值对于其他线程来说是可以立即知道的），<strong>但是对于该变量有可能有多个操作例如上文提到的x++。那么在有多个操作的情况下，CPU任然可以先暂停然后在调度的。既然能被暂停后继续在调度，那么volatile肯定是不具备原子性的了。</strong></p>
<h4 id="volatile的使用场景"><a href="#volatile的使用场景" class="headerlink" title="volatile的使用场景"></a>volatile的使用场景</h4><p>现在我们已经了解了volatile的相关特性，那么就来说说，volatile的具体使用场景，因为volatie变量只能保证可见性，并不能保证原子性，所以在轻量级线程同步中我们可以使用volatile关键字。但是有两个前提条件：</p>
<ul>
<li>第一个条件：运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>第二个条件：变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<p>直接理解上述两个条件，可能会有点困难，下面分别对着两个前提条件进行解释：</p>
<h4 id="针对第一个条件"><a href="#针对第一个条件" class="headerlink" title="针对第一个条件"></a>针对第一个条件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> volatile int a  = 0;</span><br><span class="line">//在多线程情况下错误，在单线程情况下正确的方式</span><br><span class="line">   public void doSomeThingA() &#123;</span><br><span class="line">   //在单线程情况下，不会出现线程安全的问题，正确</span><br><span class="line">//在多线程情况下，a最终的值依赖于当前a的值，错误</span><br><span class="line">        a++;     </span><br><span class="line">   &#125;</span><br><span class="line">   //正确的使用方式</span><br><span class="line">   public void doSomeThingB() &#123;</span><br><span class="line">    //不管是在单线程还是多线程的情况下，都不会出现线程安全的问题</span><br><span class="line">	if(a==0)&#123;</span><br><span class="line">	 a = 1;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在上述伪代码中，我们能明确的看出，只要volatile修饰的变量不涉及与运算结果的依赖，那么不管是在多线程，还是单线程的情况下，都是正确的。当然我这里只是将a变量定义成成int，对于其他剩下的基础类型数据也是适用的。</p>
<h4 id="针对第二个条件"><a href="#针对第二个条件" class="headerlink" title="针对第二个条件"></a>针对第二个条件</h4><p>其实理解第二个条件，大家可以反过来理解，即使用volatile的变量不能包含在其他变量的不变式中，下面伪代码将会通过反例说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	private volatile int lower;</span><br><span class="line">    private volatile int upper;  </span><br><span class="line">  </span><br><span class="line">    public void setLower(int value) &#123;   </span><br><span class="line">        if (value &gt; upper)   </span><br><span class="line">            throw new IllegalArgumentException(...);  </span><br><span class="line">        lower = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void setUpper(int value) &#123;   </span><br><span class="line">        if (value &lt; lower)   </span><br><span class="line">            throw new IllegalArgumentException(...);  </span><br><span class="line">        upper = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，我们明显发现其中包含了一个不变式 —— 下界总是小于或等于上界（也就是lower&lt;=upper)。那么在多线程的情况下，两个线程在同一时间使用不一致的值执行 setLower 和 setUpper 的话，则会使范围处于不一致的状态。例如，如果初始状态是(0, 5)，同一时间内，线程 A 调用setLower(4) 并且线程 B 调用setUpper(3)，显然这两个操作交叉存入的值是不符合条件的，那么两个线程都会通过用于保护不变式的检查，使得最后的范围值是(4, 3)。很显然这个结果是错误的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>volatile具有可见性不具有原子性，同时能防止指令重排序。</li>
<li>volatile之所以具有可见性，是因为底层中的Lock指令，该指令会将当前处理器缓存行的数据直接写会到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。</li>
<li>volatile之所以能防止指令重排序，是因为Java编译器对于volatile修饰的变量，会插入内存屏障。内存屏障会防止CPU处理指令的时候重排序的问题</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之Volatile/" data-id="cjsheb86t000mdsr7f8a4drqh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/02/23/Java并发编程之Java-CAS操作/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2019/02/23/Java并发编程之原子类/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/23/RecyclerView-smoothScrollToPosition了解一下/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/RecyclerView滚动位置，滚动速度设置/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/从ButterKnife-kt-了解Kotlin-委托与扩展/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/Gradle系列-引导篇（一）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/哈希表初识(一)/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 AndyJennifer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
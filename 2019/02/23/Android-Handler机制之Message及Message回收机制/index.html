<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>AndyJennifer‘Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="该文章属于Android Handler系列文章，如果想了解更多，请点击《Android Handler机制之总目录》  前言在前面的文章中我们讲解了Handler、Looper、MessageQueue的具体关系，了解了具体的消息循环的流程。下面将一起来探讨最为整个消息循环的消息载体Message。 Message中可以携带的信息Message中可以携带的数据比较丰富，下面对一些常用的数据进">
<meta name="keywords" content="AndyJennifer">
<meta property="og:type" content="article">
<meta property="og:title" content="AndyJennifer‘Blog">
<meta property="og:url" content="http://yoursite.com/2019/02/23/Android-Handler机制之Message及Message回收机制/index.html">
<meta property="og:site_name" content="AndyJennifer‘Blog">
<meta property="og:description" content="该文章属于Android Handler系列文章，如果想了解更多，请点击《Android Handler机制之总目录》  前言在前面的文章中我们讲解了Handler、Looper、MessageQueue的具体关系，了解了具体的消息循环的流程。下面将一起来探讨最为整个消息循环的消息载体Message。 Message中可以携带的信息Message中可以携带的数据比较丰富，下面对一些常用的数据进">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-93bba9f12e53bb0d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-306faab2aad326ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-95edc85c2fec9e30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-012dc5d65a9d84b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-104a9f156f672df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-02-23T08:52:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AndyJennifer‘Blog">
<meta name="twitter:description" content="该文章属于Android Handler系列文章，如果想了解更多，请点击《Android Handler机制之总目录》  前言在前面的文章中我们讲解了Handler、Looper、MessageQueue的具体关系，了解了具体的消息循环的流程。下面将一起来探讨最为整个消息循环的消息载体Message。 Message中可以携带的信息Message中可以携带的数据比较丰富，下面对一些常用的数据进">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2824145-93bba9f12e53bb0d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="AndyJennifer‘Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AndyJennifer‘Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">What would life be if we had no courage to attempt anything?</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Android-Handler机制之Message及Message回收机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Android-Handler机制之Message及Message回收机制/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-93bba9f12e53bb0d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小松鼠.jpg"></p>
<blockquote>
<p>该文章属于Android Handler系列文章，如果想了解更多，请点击<br><a href="https://www.jianshu.com/p/43bb31d8a742" target="_blank" rel="noopener">《Android Handler机制之总目录》</a></p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前面的文章中我们讲解了Handler、Looper、MessageQueue的具体关系，了解了具体的消息循环的流程。下面将一起来探讨最为整个消息循环的消息载体Message。</p>
<h3 id="Message中可以携带的信息"><a href="#Message中可以携带的信息" class="headerlink" title="Message中可以携带的信息"></a>Message中可以携带的信息</h3><p>Message中可以携带的数据比较丰富，下面对一些常用的数据进行了分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用户定义的消息代码，以便当接受到消息是关于什么的。其中每个Hanler都有自己的命名控件，不用担心会冲突</span><br><span class="line"> */	</span><br><span class="line"> public int what;</span><br><span class="line">/**</span><br><span class="line"> * 如果你只想存很少的整形数据，那么可以考虑使用arg1与arg2,</span><br><span class="line"> * 如果需要传输很多数据可以使用Message中的setData(Bundle bundle)</span><br><span class="line"> */</span><br><span class="line"> public int arg1;</span><br><span class="line">/**</span><br><span class="line"> * 如果你只想存很少的整形数据，那么可以考虑使用arg1与arg2,</span><br><span class="line"> * 如果需要传输很多数据可以使用Message中的setData(Bundle bundle)</span><br><span class="line"> */</span><br><span class="line"> public int arg2;</span><br><span class="line">/**</span><br><span class="line"> * 发送给接受方的任意对象，在使用跨进程的时候要注意obj不能为null</span><br><span class="line"> */</span><br><span class="line"> public Object obj;</span><br><span class="line">/**</span><br><span class="line"> * 在使用跨进程通信Messenger时，可以确定需要谁来接收</span><br><span class="line"> */</span><br><span class="line"> public Messenger replyTo;</span><br><span class="line">/**</span><br><span class="line"> * 在使用跨进程通信Messenger时，可以确定需要发消息的uid</span><br><span class="line"> */</span><br><span class="line"> public int sendingUid = -1;</span><br><span class="line">/**</span><br><span class="line"> * 如果数据比较多，可以直接使用Bundle进行数据的传递</span><br><span class="line"> */</span><br><span class="line"> Bundle data;</span><br></pre></td></tr></table></figure></p>
<p>其中关于what的值为什么不会冲突的原因是，之前我们讲过的handler是与线程进行绑定的。也就是说不同消息循环消息的发送，处理的线程是不一样的。当然是不会冲突的。对于Messenger，因为涉及到Binder机制，这里就不过多的描述了，有兴趣的小伙伴可以自行查询相关资料学习。</p>
<h3 id="创建消息的方式"><a href="#创建消息的方式" class="headerlink" title="创建消息的方式"></a>创建消息的方式</h3><p>官方建议使用Message.obtain()系列方法来获取Message实例，因为其Message实例是直接从Handler的消息池中获取的，可以循环利用，不必另外开辟内存空间，效率比直接使用new Message（）创建实例要高。其中具体创建消息的方式，我已经为大家分好类了。具体分类如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//无参数</span><br><span class="line">public static Message obtain() &#123;...&#125;</span><br><span class="line">//带Messag参数</span><br><span class="line">public static Message obtain(Message orig) &#123;&#125;</span><br><span class="line">//带Handler参数</span><br><span class="line">public static Message obtain(Handler h) &#123;&#125;</span><br><span class="line">public static Message obtain(Handler h, Runnable callback)&#123;&#125;</span><br><span class="line">public static Message obtain(Handler h, int what)&#123;&#125;</span><br><span class="line">public static Message obtain(Handler h, int what, Object obj)&#123;&#125;</span><br><span class="line">public static Message obtain(Handler h, int what, int arg1, int arg2)&#123;&#125;</span><br><span class="line">public static Message obtain(Handler h, int what,int arg1, int arg2, Object obj) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中在Message的obtain带参数的方法中，内部都会调用无参的obtain()方法来获取消息后。然后并根据其传入的参数，对Message进行赋值。（关于具体的obtain方法会在下方消息池实现原理中具体描述）</p>
<h3 id="消息池实现原理"><a href="#消息池实现原理" class="headerlink" title="消息池实现原理"></a>消息池实现原理</h3><p>既然官方建议使用消息池来获取消息，那么在了解其内部机制之前，我们来看看Message中的消息池的设计。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final Object sPoolSync = new Object();//控制获取从消息池中获取消息。保证线程安全</span><br><span class="line">private static Message sPool;//消息池</span><br><span class="line">private static int sPoolSize = 0;//消息池中回收的消息数量</span><br><span class="line">private static final int MAX_POOL_SIZE = 50;//消息池最大容量</span><br></pre></td></tr></table></figure></p>
<p>从Message的消息池设计，我们大概能看出以下几点：</p>
<ol>
<li>该消息池在同一个消息循环中是共享的（sPool声明为static)，</li>
<li>消息池中的最大容量为50，</li>
<li>从消息池获取消息是线程安全的。</li>
</ol>
<h4 id="从消息池中获取消息"><a href="#从消息池中获取消息" class="headerlink" title="从消息池中获取消息"></a>从消息池中获取消息</h4><p>在上文中，我们已经知道了在使用消息池获得消息时，都会调用无参的obtain（）方法。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">       synchronized (sPoolSync) &#123;</span><br><span class="line">           if (sPool != null) &#123;</span><br><span class="line">               Message m = sPool;</span><br><span class="line">               sPool = m.next;</span><br><span class="line">               m.next = null;</span><br><span class="line">               m.flags = 0; //重新标识当前Message没有使用过</span><br><span class="line">               sPoolSize--;</span><br><span class="line">               return m;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return new Message();//如果为空直接返回</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述代码中，我们可以了解，也就是当前 消息池不为空（sPool !=null)的情况下，那么我们就可以从消息池中获取数据，相应的消息池中的消息数量会减少。<strong>消息池的内部实现是以链表的形式</strong>，其中spol指针指向当前链表的头结点，从消息池中获取消息是<strong>以移除链表中sPool所指向的节点的形式</strong>，具体原理如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-306faab2aad326ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取消息.png"></p>
<h4 id="回收消息到消息池"><a href="#回收消息到消息池" class="headerlink" title="回收消息到消息池"></a>回收消息到消息池</h4><p>在Meaage的消息回收中，消息的实际回收方法是recycleUnchecked（）方法，具体如下图所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> void recycleUnchecked() &#123;</span><br><span class="line">   //用于表示当前Message消息已经被使用过了</span><br><span class="line">      flags = FLAG_IN_USE;</span><br><span class="line">      //情况之前Message的数据</span><br><span class="line">      what = 0;</span><br><span class="line">      arg1 = 0;</span><br><span class="line">      arg2 = 0;</span><br><span class="line">      obj = null;</span><br><span class="line">      replyTo = null;</span><br><span class="line">      sendingUid = -1;</span><br><span class="line">      when = 0;</span><br><span class="line">      target = null;</span><br><span class="line">      callback = null;</span><br><span class="line">      data = null;</span><br><span class="line">//判断当前消息池中的数量是不是小于最大数量，其中 MAX_POOL_SIZE=50</span><br><span class="line">      synchronized (sPoolSync) &#123;</span><br><span class="line">          if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">              next = sPool;</span><br><span class="line">              sPool = this;</span><br><span class="line">              sPoolSize++;//记录当前消息池中的数量</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在recycleUnchecked（）方法中，大致分为三步，第一步将该条回收的消息状态设置为正在使用，第二步将Message所有的存储信息都变为初始值，第三步，如果当前消息池仍能够存储回收的消息，那么就将消息存储在消息池中。<strong>其中将回收消息加入消息池中是使用链表的形式</strong>，具体回收消息到消息池如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-95edc85c2fec9e30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加入消息.png"></p>
<h3 id="Message-消息回收时机"><a href="#Message-消息回收时机" class="headerlink" title="Message 消息回收时机"></a>Message 消息回收时机</h3><p>这里为了方便大家梳理逻辑，我提前将几种会调用消息进行回收的情况都描述出来了，具体的情况如下所示：</p>
<h4 id="当Handler指定删除单条消息，或所有消息的时候"><a href="#当Handler指定删除单条消息，或所有消息的时候" class="headerlink" title="当Handler指定删除单条消息，或所有消息的时候"></a>当Handler指定删除单条消息，或所有消息的时候</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void removeMessages(Handler h, int what, Object object)</span><br><span class="line">void removeMessages(Handler h, Runnable r, Object object)</span><br><span class="line">void removeCallbacksAndMessages(Handler h, Object object)</span><br></pre></td></tr></table></figure>
<p>当使用Handler删除某条消息的时候，会分别调用MessageQueue的 removeMessages(Handler h, int what, Object object)与removeCallbacksAndMessages(Handler h, Object object) ，removeMessages(Handler h, Runnable r, Object object) 三个方法。这三个个方法逻辑比较类似。这里直接选取removeCallbacksAndMessages（）方法来进行讲解。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void removeCallbacksAndMessages(Handler h, Object object) &#123;</span><br><span class="line">       if (h == null) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           Message p = mMessages;</span><br><span class="line"></span><br><span class="line">           // 回收满足条件的第一条消息  第一步</span><br><span class="line">           while (p != null &amp;&amp; p.target == h</span><br><span class="line">                   &amp;&amp; (object == null || p.obj == object)) &#123;</span><br><span class="line">                //下面操作会将满足回收条件的消息，从消息队列中移除</span><br><span class="line">               Message n = p.next;</span><br><span class="line">               mMessages = n;</span><br><span class="line">               p.recycleUnchecked();</span><br><span class="line">               p = n;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 回收该条消息后面的满足条件的消息 第二步</span><br><span class="line">           while (p != null) &#123;</span><br><span class="line">               Message n = p.next;</span><br><span class="line">               if (n != null) &#123;</span><br><span class="line">                   if (n.target == h &amp;&amp; (object == null || n.obj == object)) &#123;</span><br><span class="line">                    //下面操作会将满足回收条件的消息，从消息队列中移除</span><br><span class="line">                       Message nn = n.next;</span><br><span class="line">                       n.recycleUnchecked();</span><br><span class="line">                       p.next = nn;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               p = n;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在removeCallbacksAndMessages(Handler h, Object object)方法中，在该方法中分成了两步，</p>
<ul>
<li>第一步：回收满足条件的第一条消息。同时将该消息从消息队列中移除。<code>并且将mMessages指向消息队列中的头节点</code>。<br>在第一步中，我们可以看出会循环遍历消息队列中的消息找到p.target == h&amp;&amp;（(object == null || p.obj == object)，然后进行回收，也就是说在第一步中，会移除对应的Handler。(<strong>在Handler机制中，多个handler对应同一个MessageQueue,对应同一个Looper，Handler与MessageQueue与Looper之间的关系是N：1：1</strong>)</li>
<li>第二步：回收<strong>已经回收的第一条消息之后</strong>所有满足条件的消息。同时将这些消息从消息队列中移除。</li>
</ul>
<blockquote>
<p>思考：为什么不直接走第二步回收消息就行了。反正满足条件的消息都会移除，为毛要先移除第一条，在接着移除后面的消息（这里如果大家感到困惑，请仔细观看第一步操作中的  其中一条语句<code>mMessages = n;</code>,之所以会走两次循环，主要目的是让mMessages指向消息队列中的头节点）。</p>
</blockquote>
<p>这里要大家要注意的是，如果<code>object==null</code>，那么就会移除消息队列中所有对应Handler发送的消息所有mesaage.object==null的消息。默认情况下，我们都是不会对Message.obj进行赋值的。所以默认情况下，如果你传入object =null，<strong>有可能</strong>会移除消息队列中的所有的消息。</p>
<h4 id="当Loooper取出消息时"><a href="#当Loooper取出消息时" class="headerlink" title="当Loooper取出消息时"></a>当Loooper取出消息时</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> public static void loop() &#123;</span><br><span class="line">//省略部分代码</span><br><span class="line">     for (;;) &#123;</span><br><span class="line">         Message msg = queue.next(); // might block</span><br><span class="line">         if (msg == null) &#123;</span><br><span class="line">             // No message indicates that the message queue is quitting.</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">//省略部分代码</span><br><span class="line">         try &#123;</span><br><span class="line">             msg.target.dispatchMessage(msg);</span><br><span class="line">             end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">         &#125; finally &#123;</span><br><span class="line">             if (traceTag != 0) &#123;</span><br><span class="line">                 Trace.traceEnd(traceTag);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">   //省略部分代码</span><br><span class="line">   </span><br><span class="line">   //回收消息</span><br><span class="line">         msg.recycleUnchecked();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们都知道消息的取出是通过Looper类中的loop方法。从代码中我们可以看出，当消息取出并执行相应操作后。最后会将消息回收。</p>
<h4 id="当Looper取消循环消息队列的时候"><a href="#当Looper取消循环消息队列的时候" class="headerlink" title="当Looper取消循环消息队列的时候"></a>当Looper取消循环消息队列的时候</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void quitSafely() &#123; mQueue.quit(true);&#125;</span><br><span class="line">public void quit() &#123; mQueue.quit(false); &#125;</span><br></pre></td></tr></table></figure>
<p>当退出消息队列的时候，也就是调用Loooper的quitSafely（）或quit（）方法，从代码中我们可以看出，会调用其内部的MessageQueue的quit(boolean safe)方法。我们继续跟踪代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void quit(boolean safe) &#123;</span><br><span class="line">     if (!mQuitAllowed) &#123;//注意，主线程是不能退出消息循环的</span><br><span class="line">         throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     synchronized (this) &#123;</span><br><span class="line">         if (mQuitting) &#123;//如果当前循环消息已经退出了，直接返回</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         mQuitting = true;</span><br><span class="line"></span><br><span class="line">         if (safe) &#123;//如果是安全退出</span><br><span class="line">             removeAllFutureMessagesLocked();</span><br><span class="line">         &#125; else &#123;//如果不是安全退出</span><br><span class="line">             removeAllMessagesLocked();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // We can assume mPtr != 0 because mQuitting was previously false.</span><br><span class="line">         nativeWake(mPtr);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在MessageQueue的quit(boolean safe)方法中，会将mQuitting （用于判断当前消息队列是否已经退出）置为true，同时会根据当前是否安全退出的标志 (safe)来走不同的逻辑,如果安全则走removeAllFutureMessagesLocked（）方法，如果不是安全退出则走removeAllMessagesLocked（）方法。下面分别对这两个方法进行讨论。</p>
<h5 id="非安全退出"><a href="#非安全退出" class="headerlink" title="非安全退出"></a>非安全退出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void removeAllMessagesLocked() &#123;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">        Message n = p.next;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line">        p = n;</span><br><span class="line">    &#125;</span><br><span class="line">    mMessages = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非安全退出其实很简单，就是将所有消息队列中的消息全部回收。具体示意图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-012dc5d65a9d84b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收全部消息.png"></p>
<h5 id="安全退出"><a href="#安全退出" class="headerlink" title="安全退出"></a>安全退出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void removeAllFutureMessagesLocked() &#123;</span><br><span class="line">     final long now = SystemClock.uptimeMillis();</span><br><span class="line">     Message p = mMessages;//当前队列中的头消息</span><br><span class="line">     if (p != null) &#123;</span><br><span class="line">         if (p.when &gt; now) &#123;//判断时间，如果Message的取出时间比当前时间要大直接移除</span><br><span class="line">             removeAllMessagesLocked();</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             Message n;</span><br><span class="line">             for (;;) &#123;//继续判断，取队列中所有大于当前时间的消息</span><br><span class="line">                 n = p.next;</span><br><span class="line">                 if (n == null) &#123;</span><br><span class="line">                     return;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (n.when &gt; now) &#123;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">                 p = n;</span><br><span class="line">             &#125;</span><br><span class="line">             p.next = null;</span><br><span class="line">             do &#123;//将所有所有大于当前时间的消息的消息回收</span><br><span class="line">                 p = n;</span><br><span class="line">                 n = p.next;</span><br><span class="line">                 p.recycleUnchecked();</span><br><span class="line">             &#125; while (n != null);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>观察上诉代码，在该方法中，会判断当前消息队列中的头消息的时间是否大于当前时间，如果大于当前时间就会removeAllMessagesLocked（）方法（也就是回收全部消息），反之，则回收部分消息，同时没有被回收的消息任然可以被取出执行。具体示意图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-104a9f156f672df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收部分消息.png"></p>
<h4 id="当消息队列退出的，但是仍然发送消息过来的时候"><a href="#当消息队列退出的，但是仍然发送消息过来的时候" class="headerlink" title="当消息队列退出的，但是仍然发送消息过来的时候"></a>当消息队列退出的，但是仍然发送消息过来的时候</h4><p>在Looper调用quit()方法时，也就是Looper退出消息循环的时候，我们已经知道了其内部会调用MessageQueue的quit(boolean safe)方法。当MessageQueue退出的时候，会将mQuitting置为true。那么当对应的Handler发送消息时，我们都知道会调用MessageQueue的enqueueMessage（Message msg, long when）方法。那么现在我们观察下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">	   ...省略部分代码</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">          ...省略部分代码</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = new IllegalStateException(</span><br><span class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            ...省略部分代码</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>观察该代码我们得知，当循环消息退出的时候，如果这个时候Handler继续发送消息来。会将该消息回收。但是现在这里有个问题。既然我们的消息队列已经结束循环了。那么我们回收该消息又有什么用呢？我们又不能重新的开启消息循环。不知道Google这里为什么会这么设计。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>在使用Handler发消息时，建议使用Message.obtin()方法，从消息池中获取消息。</li>
<li>在Message中消息池是使用链表的形式来存储消息的。</li>
<li>在Message中消息池中最大允许存储50条的消息。</li>
<li>在使用Handler移除某条消息的时候，该消息有可能会被消息池回收。（会判断消息池是否仍然能存储消息）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Android-Handler机制之Message及Message回收机制/" data-id="cjsheb85x0009dsr732079h5f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/02/23/Android-Handler机制之总目录/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2019/02/23/Android-Handler机制之内存泄漏/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/23/RecyclerView-smoothScrollToPosition了解一下/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/RecyclerView滚动位置，滚动速度设置/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/从ButterKnife-kt-了解Kotlin-委托与扩展/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/Gradle系列-引导篇（一）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/哈希表初识(一)/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 AndyJennifer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
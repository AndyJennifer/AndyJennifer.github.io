<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>AndyJennifer‘Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言在前面的文章中，我曾提到过，整个Lock接口下实现的锁机制中AQS(AbstractQueuedSynchronizer，下文都称之为AQS)与Condition才是真正的实现者。也就说Condition在整个同步组件的基础框架中也起着非常重要的作用，既然它如此重要与犀利，那么现在我们就一起去了解其内部的实际原理与具体逻辑。  在阅读该文章之前，我由衷的建议先阅读《Java并发编程之锁机制之">
<meta name="keywords" content="AndyJennifer">
<meta property="og:type" content="article">
<meta property="og:title" content="AndyJennifer‘Blog">
<meta property="og:url" content="http://yoursite.com/2019/02/23/Java并发编程之锁机制之Condition接口/index.html">
<meta property="og:site_name" content="AndyJennifer‘Blog">
<meta property="og:description" content="前言在前面的文章中，我曾提到过，整个Lock接口下实现的锁机制中AQS(AbstractQueuedSynchronizer，下文都称之为AQS)与Condition才是真正的实现者。也就说Condition在整个同步组件的基础框架中也起着非常重要的作用，既然它如此重要与犀利，那么现在我们就一起去了解其内部的实际原理与具体逻辑。  在阅读该文章之前，我由衷的建议先阅读《Java并发编程之锁机制之">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-64a13d0c3114cdcb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-3de65963e92886ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-c2dbcb9a5df26c1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-306028fc076c6709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-fd08ef7d8f05fbe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-fbdd2f637ac198f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-416aebe1f25d17f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-694a82e957dce046.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-02-23T08:52:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AndyJennifer‘Blog">
<meta name="twitter:description" content="前言在前面的文章中，我曾提到过，整个Lock接口下实现的锁机制中AQS(AbstractQueuedSynchronizer，下文都称之为AQS)与Condition才是真正的实现者。也就说Condition在整个同步组件的基础框架中也起着非常重要的作用，既然它如此重要与犀利，那么现在我们就一起去了解其内部的实际原理与具体逻辑。  在阅读该文章之前，我由衷的建议先阅读《Java并发编程之锁机制之">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2824145-64a13d0c3114cdcb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="AndyJennifer‘Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AndyJennifer‘Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">What would life be if we had no courage to attempt anything?</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java并发编程之锁机制之Condition接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Java并发编程之锁机制之Condition接口/" class="article-date">
  <time datetime="2019-02-23T08:52:29.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-64a13d0c3114cdcb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="book.jpg"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前面的文章中，我曾提到过，整个Lock接口下实现的锁机制中<code>AQS(AbstractQueuedSynchronizer，下文都称之为AQS)</code>与<code>Condition</code>才是真正的实现者。也就说<code>Condition</code>在整个同步组件的基础框架中也起着非常重要的作用，既然它如此重要与犀利，那么现在我们就一起去了解其内部的实际原理与具体逻辑。</p>
<blockquote>
<p>在阅读该文章之前，我由衷的建议先阅读<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">《Java并发编程之锁机制之AQS》</a>与<a href="https://www.jianshu.com/p/d0e84096d108" target="_blank" rel="noopener">《Java并发编程之锁机制之LockSupport工具》</a>这两篇文章。因为整个Condtion的内部机制与逻辑都离不开以上两篇文章提到的知识点。</p>
</blockquote>
<h3 id="Condition接口方法介绍"><a href="#Condition接口方法介绍" class="headerlink" title="Condition接口方法介绍"></a>Condition接口方法介绍</h3><p>在正式介绍Condtion之前，我们可以先了解其中声明的方法。具体方法声明，如下表所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-3de65963e92886ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="condition方法.png"></p>
<p>从该表中，我们可以看出其内部定义了<code>等待（以await开头系列方法）</code>与<code>通知（以singal开头的系列方法)</code>两种类型的方法，类似于Object对象的<code>wait()</code>与<code>notify()/NotifyAll()</code>方法来对线程的阻塞与唤醒。</p>
<p>###ConditionObject介绍<br>在实际使用中，Condition接口实现类是<code>AQS</code>中的内部类<code>ConditionObject</code>。在其内部维护了一个<code>FIFO(first in first out)</code>的队列（这里我们称之为<code>等待队列</code>，你也可以叫做阻塞队列，看每个人的理解），通过与<code>AQS中的同步队列</code>配合使用，来控制获取共享资源的线程。</p>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>等待队列是<code>ConditionObjec</code>中内部的一个<code>FIFO(first in first out)</code>的队列，在队列中的每个节点都包含了一个线程引用，且该线程就是在ConditionObject对象上阻塞的线程。需要注意的是，在等待队列中的节点是复用了<code>AQS</code>中<code>Node类</code>的定义。换句话说，在<code>AQS</code>中维护的同步队列与<code>ConditionObjec</code>中维护的等待队列中的节点类型都是<code>AQS.Node</code>类型。（关于<code>AbstractQueuedSynchronizer.Node</code>类的介绍，大家可以参看<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">《Java并发编程之锁机制之AQS》</a>文章中的描述）。</p>
<p>在ConditionObject类中也分别定义了<code>firstWaiter</code>与<code>lastWaiter</code>两个指针，分别指向等待队列中头部与尾部。当实际线程调用其以<code>await开头</code>的系列方法后。会将该线程构造为Node节点。添加等待队列中的尾部。关于等待队列的基本结构如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-c2dbcb9a5df26c1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="condition内部结构.png"></p>
<p>对于等待队列中节点添加的方式也很简单，将<code>上一尾节点的nextWaiter指向新添加的节点</code>，同时使<code>lastWaiter</code>指向新添加的节点。</p>
<h4 id="同步队列与等待队列的对应关系"><a href="#同步队列与等待队列的对应关系" class="headerlink" title="同步队列与等待队列的对应关系"></a>同步队列与等待队列的对应关系</h4><p>上文提到了整个Lock锁机制需要<code>AQS中的同步队列</code>与<code>ConditionObject的等待队列</code>配合使用，其对应关系如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-306028fc076c6709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同步队列与等待队列的关系.png"></p>
<p>在Lock锁机制下，可以<code>拥有一个同步队列和多个等待队列</code>，与我们传统的Object监视器模型上，一个对象拥有一个同步队列和等待队列不同。lock中的锁可以伴有多个条件。</p>
<h4 id="Condition的基本使用"><a href="#Condition的基本使用" class="headerlink" title="Condition的基本使用"></a>Condition的基本使用</h4><p>为了大家能够更好的理解同步队列与等待队列的关系。下面通过一个有界队列<code>BoundedBuffer</code>来了解Condition的使用方式，该类是一个特殊的队列，当队列为空时，队列的获取操作将会阻塞当前”拿”线程，直到队列中有新增的元素，当队列已满时，队列的放入操作将会阻塞”放入”线程，直到队列中出现空位。具体代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer &#123;</span><br><span class="line"></span><br><span class="line">    final Lock lock = new ReentrantLock();</span><br><span class="line">    final Condition notFull = lock.newCondition();</span><br><span class="line">    final Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    final Object[] items = new Object[100];</span><br><span class="line">    </span><br><span class="line">    //依次为，放入的角标、拿的角标、数组中放入的对象总数</span><br><span class="line">    int putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加一个元素</span><br><span class="line">     * （1）如果当前数组已满，则把当前&quot;放入&quot;线程，加入到&quot;放入&quot;等待队列中，并阻塞当前线程</span><br><span class="line">     * （2）如果当前数组未满，则将x元素放入数组中，唤醒&quot;拿&quot;线程中的等待线程。</span><br><span class="line">     */</span><br><span class="line">    public void put(Object x) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)//如果已满，则阻塞当前&quot;放入&quot;线程</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            if (++putptr == items.length) putptr = 0;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();//唤醒&quot;拿&quot;线程</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 拿一个元素</span><br><span class="line">     * （1）如果当前数组已空，则把当前&quot;拿&quot;线程，加入到&quot;拿&quot;等待队列中，并阻塞当前线程</span><br><span class="line">     * （2）如果当前数组不为空，则把唤醒&quot;放入&quot;等待队列中的线程。</span><br><span class="line">     */</span><br><span class="line">    public Object take() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)//如果为空，则阻塞当前&quot;拿&quot;线程</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            if (++takeptr == items.length) takeptr = 0;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();//唤醒&quot;放入&quot;线程</span><br><span class="line">            return x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中我们可以看出，在该类中我们创建了两个等待队列<code>notFull</code>与<code>notEmpty</code>。这两个等待队列的作用分别是，当请数组已满时，<code>notFull</code>用于存储阻塞的”放入”线程，<code>notEmpty</code>用于存储阻塞的”拿”线程。需要注意的是<code>获取一个Condition必须通过Lock的newCondition()方法</code>。关于<code>ReentrantLock</code>，在后续的文章中，我们会进行介绍。</p>
<h3 id="阻塞实现-await"><a href="#阻塞实现-await" class="headerlink" title="阻塞实现 await()"></a>阻塞实现 await()</h3><p>在了解了ConditionObject的内部基本结构和与AQS中内部的同步队列的对应关系后，现在我们来看看其阻塞实现。调用ConditionObject的<code>await()</code>方法（或者以<code>await开头</code>的方法），会使当前线程进入等待队列，并释放同步状态，需要注意的是当该方法返回时，当前线程一定获取了同步状态（具体原因是当通过<code>signal()等系列方法</code>，线程才会从<code>await（）</code>方法返回，而唤醒该线程后会加入同步队列）。这里我们以<code>awati()</code>方法为例，具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">	//如果当前线程已经中断，直接抛出异常  </span><br><span class="line">          if (Thread.interrupted())</span><br><span class="line">              throw new InterruptedException();</span><br><span class="line">          //(1)将当前线程加入等待队列</span><br><span class="line">          Node node = addConditionWaiter();</span><br><span class="line">          //(2)释放同步状态（也就是释放锁），同时将线程节点从同步队列中移除，并唤醒同步队列中的下一节点</span><br><span class="line">          int savedState = fullyRelease(node);</span><br><span class="line">          int interruptMode = 0;</span><br><span class="line">          //(3)判断当前线程节点是否还在同步队列中，如果不在则阻塞线程</span><br><span class="line">          while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">              LockSupport.park(this);</span><br><span class="line">              if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">                  break;</span><br><span class="line">          &#125;</span><br><span class="line">          //(4)当线程被唤醒后，重新在同步队列中与其他线程竞争获取同步状态</span><br><span class="line">          if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">              interruptMode = REINTERRUPT;</span><br><span class="line">          if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">              unlinkCancelledWaiters();</span><br><span class="line">          if (interruptMode != 0)</span><br><span class="line">              reportInterruptAfterWait(interruptMode);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码整体来看，整个方法分为以下四个步骤：</p>
<ul>
<li>（1）通过 <code>addConditionWaiter()</code>方法将线程节点加入到等待队列中。</li>
<li>（2）通过<code>fullyRelease(Node node)</code>方法释放同步状态（也就是释放锁），同时将线程节点从<code>同步队列</code>中移除，并唤醒<code>同步队列中的下一节点</code>。</li>
<li>（3）通过<code>isOnSyncQueue(Node node)</code>方法判断当前线程节点是否在<code>同步队列</code>中，如果不在，则通过<code>LockSupport.park(this);</code>阻塞当前线程。</li>
<li>（4）当线程被唤醒后，调用<code>acquireQueued(node, savedState)</code>方法，重新在同步队列中与其他线程竞争获取同步状态</li>
</ul>
<p>因为每个步骤涉及到的逻辑都稍微有一点复杂，这里为了方便大家理解，分别对以上四个步骤涉及到的方法分别进行介绍。</p>
<h4 id="addConditionWaiter-方法"><a href="#addConditionWaiter-方法" class="headerlink" title="addConditionWaiter()方法"></a>addConditionWaiter()方法</h4><p>该方法主要将同步队列中的需要阻塞的线程节点加入到等待队列中，关于<code>addConditionWaiter()</code>方法具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> private Node addConditionWaiter() &#123;</span><br><span class="line">         Node t = lastWaiter;</span><br><span class="line">         // (1)如果当前尾节点中中对应的线程已经中断，</span><br><span class="line">         //则移除等待队列中所有的已经中断或已经释放同步状态的线程节点</span><br><span class="line">         if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">             unlinkCancelledWaiters();</span><br><span class="line">             t = lastWaiter;</span><br><span class="line">         &#125;</span><br><span class="line">   //(2)构建等待队列中的节点</span><br><span class="line">         Node node = new Node(Node.CONDITION);</span><br><span class="line"></span><br><span class="line">//(3)将该线程节点添加到队列中，同时构建firstWaiter与lastWaiter的指向</span><br><span class="line">         if (t == null)</span><br><span class="line">             firstWaiter = node;</span><br><span class="line">         else</span><br><span class="line">             t.nextWaiter = node;</span><br><span class="line">         lastWaiter = node;</span><br><span class="line">         return node;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的逻辑也比较简单，分为以下三个步骤：</p>
<ul>
<li>（1）获取等待队列中的尾节点，如果当前尾节点已经中断，那么则通过<code>unlinkCancelledWaiters()</code>方法移除等待队列中所有的<code>已经中断</code>或<code>已经释放同步状态（也就是释放锁）</code>的线程节点</li>
<li>（2）构建等待队列中的节点，注意，是通过<code>New</code>的形式，那么就说明与同步队列中的线程节点不是同一个。（对Node状态枚举不清楚的小伙伴，可以参看<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">Java并发编程之锁机制之AQS</a>文章下的Node状态枚举介绍）。</li>
<li>（3）将该线程节点添加到等待队列中去，同时构建firstWaiter与lastWaiter的指向，可以看出等待队列总是以<code>FIFO(first in first out )</code>的形式添加线程节点。</li>
</ul>
<h5 id="unlinkCancelledWaiters-方法"><a href="#unlinkCancelledWaiters-方法" class="headerlink" title="unlinkCancelledWaiters()方法"></a>unlinkCancelledWaiters()方法</h5><p>因为在<code>addConditionWaiter()</code>方法的步骤（1）中，调用了<code>unlinkCancelledWaiters</code>移除了所有的<code>已经中断</code>的线程节点，那我们看一个该方法的实现。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void unlinkCancelledWaiters() &#123;</span><br><span class="line">	//获取等待队列中的头节点</span><br><span class="line">          Node t = firstWaiter;</span><br><span class="line">          Node trail = null;</span><br><span class="line">          //遍历等待队列，将已经中断的线程节点从等待队列中移除。</span><br><span class="line">          while (t != null) &#123;</span><br><span class="line">              Node next = t.nextWaiter;</span><br><span class="line">              if (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                  t.nextWaiter = null;</span><br><span class="line">                  if (trail == null)</span><br><span class="line">                      firstWaiter = next;</span><br><span class="line">                  else</span><br><span class="line">                      trail.nextWaiter = next;</span><br><span class="line">                  if (next == null)//重新定义lastWaiter的指向</span><br><span class="line">                      lastWaiter = trail;</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">                  trail = t;</span><br><span class="line">              t = next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法具体流程如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-fd08ef7d8f05fbe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="condition.png"></p>
<h4 id="fullyRelease-Node-node"><a href="#fullyRelease-Node-node" class="headerlink" title="fullyRelease(Node node)"></a>fullyRelease(Node node)</h4><p>在将阻塞线程将入到等待队列后，会将该线程节点从同步队列中移除，释放同步状态（也就是释放锁），并唤醒同步队列中的下一节点。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final int fullyRelease(Node node) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          int savedState = getState();</span><br><span class="line">          if (release(savedState))</span><br><span class="line">              return savedState;</span><br><span class="line">          throw new IllegalMonitorStateException();</span><br><span class="line">      &#125; catch (Throwable t) &#123;</span><br><span class="line">          node.waitStatus = Node.CANCELLED;</span><br><span class="line">          throw t;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p> <code>release(int arg)</code>方法会释放当前线程的同步状态， 并唤醒<code>同步队列中</code>的下一线程节点，使其尝试获取同步状态，因为该方法已经在<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">Java并发编程之锁机制之AQS</a>文章下的<code>unparkSuccessorNode node)</code>方法的下分析过了，所以这里就不再进行分析了。希望大家参考上面提到的文章进行理解。</p>
<h4 id="isOnSyncQueue-Node-node"><a href="#isOnSyncQueue-Node-node" class="headerlink" title="isOnSyncQueue(Node node)"></a>isOnSyncQueue(Node node)</h4><p>该方法主要用于判断当前线程节点是否在同步队列中。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final boolean isOnSyncQueue(Node node) &#123;</span><br><span class="line">      //判断当前节点 waitStatus ==Node.CONDITION或者当前节点上一节点为空,则不在同步队列中</span><br><span class="line">      if (node.waitStatus == Node.CONDITION || node.prev == null)</span><br><span class="line">          return false;</span><br><span class="line">      //如果当前节点拥有下一个节点，则在同步队列中。</span><br><span class="line">      if (node.next != null) // If has successor, it must be on queue</span><br><span class="line">          return true;</span><br><span class="line">   //如果以上条件都不满足，则遍历同步队列。检查是否在同步队列中。</span><br><span class="line">      return findNodeFromTail(node);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你还记得AQS中的同步队列，那么你应该知道同步队列中的Node节点才会使用其内部的<code>pre</code>与<code>next</code>字段，那么在同步队列中因为只使用了<code>nextWaiter</code>字段，所以我们就能很简单的通过这两个字段是否为<code>==null</code>，来判断是否在同步队列中。当然也有可能有一种特殊情况。有可能需要阻塞的线程节点还没有加入到同步队列中，那么这个时候我们需要遍历同步队列来判断是否在该线程节点是否在线程中。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private boolean findNodeFromTail(Node node) &#123;</span><br><span class="line">       for (Node p = tail;;) &#123;</span><br><span class="line">           if (p == node)</span><br><span class="line">               return true;</span><br><span class="line">           if (p == null)</span><br><span class="line">               return false;</span><br><span class="line">           p = p.prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里之所以使用同步队列<code>tail（尾节点）</code>来遍历，如果<code>node.netx!=null</code>，那么就说明当前线程已经在同步队列中。那么我们需要处理的情况肯定是针对<code>node.next==null</code>的情况。所以需要从尾节点开始遍历。</p>
<h4 id="acquireQueued-final-Node-node-int-arg"><a href="#acquireQueued-final-Node-node-int-arg" class="headerlink" title="acquireQueued(final Node node, int arg)"></a>acquireQueued(final Node node, int arg)</h4><p>当线程被唤醒后（具体原因是当通过<code>signal()等系列方法</code>，线程才会从<code>await（）</code>方法返回）会调用该方法将该线程节点加入到同步队列中。该方法我在<a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">《Java并发编程之锁机制之AQS》</a>中具体描述过了。这里就不在进行过多的解析。</p>
<h4 id="阻塞流程"><a href="#阻塞流程" class="headerlink" title="阻塞流程"></a>阻塞流程</h4><p>在理解了整个阻塞的流程后，现在我们来归纳总结一下，整个阻塞的流程。具体流程如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-fbdd2f637ac198f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="阻塞流程.png"></p>
<ul>
<li>（1）将该线程节点从同步队列中移除，并释放其同步状态。</li>
<li>（2）构造新的阻塞节点，加入到等待队列中。</li>
</ul>
<h3 id="唤醒实现-signal"><a href="#唤醒实现-signal" class="headerlink" title="唤醒实现 signal()"></a>唤醒实现 signal()</h3><p>当需要唤醒线程时，会调用ConditionObject中的<code>singal开头的系列方法</code>，该系列方法会唤醒等待队列中的<code>首个</code>线程节点，在唤醒该节点之前，会先讲该节点移动到<code>同步队列</code>中。这里我们以<code>singal()</code>方法为例进行讲解，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    //（1）判断当前线程是否获取到了同步状态（也就是锁）</span><br><span class="line">          if (!isHeldExclusively())</span><br><span class="line">              throw new IllegalMonitorStateException();</span><br><span class="line">          Node first = firstWaiter;</span><br><span class="line">          //（2）获取等待队列中的首节点，然后将其移动到同步队列，然后再唤醒该线程节点</span><br><span class="line">          if (first != null)</span><br><span class="line">              doSignal(first);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法主要逻辑分为以下两个步骤：</p>
<ul>
<li>（1）通过<code>isHeldExclusively()</code>方法，判断当前线程是否获取到了同步状态（也就是锁）。</li>
<li>（2）通过<code>doSignal(Node first)</code>方法，获取等待队列中的首节点，然后将其移动到同步队列，然后再唤醒该线程节点。</li>
</ul>
<p>下面我们会分别对上面涉及到的两个方法进行描述。</p>
<h4 id="isHeldExclusively-方法"><a href="#isHeldExclusively-方法" class="headerlink" title="isHeldExclusively()方法"></a>isHeldExclusively()方法</h4><p><code>isHeldExclusively()</code>方法是AQS中的方法，默认交给其子类实现，主要用于判断当前调用<code>singal()</code>方法的线程，是否在同步队列中，且已经获取了同步状态。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean isHeldExclusively() &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="doSignal-Node-first-方法"><a href="#doSignal-Node-first-方法" class="headerlink" title="doSignal(Node first)方法"></a>doSignal(Node first)方法</h4><p>那我们继续跟踪<code>doSignal(Node first)</code>方法，具体方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">       do &#123;</span><br><span class="line">           //（1）将等待队列中的首节点从等待队列中移除，并重新制定firstWaiter的指向</span><br><span class="line">           if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">               lastWaiter = null;</span><br><span class="line">           first.nextWaiter = null;</span><br><span class="line">       &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">       //（2）将等待队列中的首节点，加入同步队列中，并重新唤醒该节点</span><br><span class="line">                (first = firstWaiter) != null);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该方法也很简单，分为两个步骤：</p>
<ul>
<li>（1）将等待队列中的首节点从等待队列中移除，并设置firstWaiter的指向为首节点的下一个节点。 为了方便大家理解该步骤所描述的逻辑，这里画了具体的图，具体情况如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-416aebe1f25d17f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="移除首节点.png"></li>
<li>（2）通过 <code>transferForSignal(Node node)</code>方法，将等待队列中的首节点，加入到同步队列中去，然后重新唤醒该线程节点。</li>
</ul>
<h5 id="transferForSignal-Node-node-方法"><a href="#transferForSignal-Node-node-方法" class="headerlink" title="transferForSignal(Node node)方法"></a>transferForSignal(Node node)方法</h5><p>因为步骤（2）中<code>transferForSignal(Node node)</code>方法较为复杂，所以会对该方法进行详细的讲解。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">   </span><br><span class="line">    //（1）将该线程节点的状态设置为初始状态，如果失败则表示当前线程已经中断了</span><br><span class="line">    if (!node.compareAndSetWaitStatus(Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line">    //（2）将该节点放入同步队列中，</span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    int ws = p.waitStatus;</span><br><span class="line">    //（3）获取当前节点的状态并判断，尝试将该线程节点状态设置为Singal，如果失败则唤醒线程</span><br><span class="line">    if (ws &gt; 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法分为三个步骤：</p>
<ul>
<li>（1）将该线程节点的状态设置为初始状态，如果失败则表示当前线程已经中断了，直接返回。</li>
<li>（2）通过<code>enq(Node node)</code>方法，将该线程节点放入<code>同步队列</code>中。</li>
<li>（3）当将该线程节点放入同步队列后，获取当前节点的状态并判断，如果该节点的<code>waitStatus&gt;0</code>或者通过<code>compareAndSetWaitStatus(ws, Node.SIGNAL)</code>将该节点的状态设置为Singal，如果失败则通过<code>LockSupport.unpark(node.thread)</code>唤醒线程。</li>
</ul>
<p>上述步骤中，着重讲<code>enq(Node node)</code>方法，关于<code>LockSupport.unPark(Thread thread)</code>方法的理解，大家可以阅读<a href="https://www.jianshu.com/p/d0e84096d108" target="_blank" rel="noopener">《Java并发编程之锁机制之LockSupport工具》</a>。下面我们就来分析<code>enq(Node node)</code>方法。具体代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(Node node) &#123;</span><br><span class="line">     for (;;) &#123;</span><br><span class="line">         //(1)获取同步队列的尾节点</span><br><span class="line">         Node oldTail = tail;</span><br><span class="line">         //(2)如果尾节点不为空，则将该线程节点加入到同步队列中</span><br><span class="line">         if (oldTail != null) &#123;</span><br><span class="line">          //将当前节点的prev指向尾节点</span><br><span class="line">             U.putObject(node, Node.PREV, oldTail);</span><br><span class="line">             //将同步队列中的tail指针，指向当前节点</span><br><span class="line">             if (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">                 oldTail.next = node;</span><br><span class="line">                 return oldTail;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">          //(3)如果当前同步队列为空，则构造同步队列</span><br><span class="line">             initializeSyncQueue();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>观察该方法，我们发现该方法通过<code>死循环(当然你也可以叫做自旋)</code>的方式来添加该节点到同步队列中去。该方法分为以下步骤：</p>
<ul>
<li>（1）获取同步队列的尾节点</li>
<li>（2）如果尾节点不为空，则将该线程节点加入到同步队列中</li>
<li>（3）如果当前同步队列为空，则通过<code>initializeSyncQueue();</code>构造同步队列。</li>
</ul>
<p>这里对<code>Node enq(Node node)</code>中的步骤（2）补充一个知识点。我们来看一下调用<code>U.putObject(node, Node.PREV, oldTail);</code>语句，内部是如何将当前的节点的prev指向尾节点的。在<code>AQS（AbstractQueuedSynchronizer）</code>中的Node类中有如下静态变量和语句。这里我省略了一下不重要的代码。具体代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">//省略部分代码</span><br><span class="line">static final long PREV;</span><br><span class="line">    static &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">		    //省略部分代码</span><br><span class="line">            PREV = U.objectFieldOffset</span><br><span class="line">               (Node.class.getDeclaredField(&quot;prev&quot;));</span><br><span class="line">              &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class="line">               throw new Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Node.class.getDeclaredField(&quot;prev&quot;)</code>语句很好理解，就是获取Node类中<code>pre</code>字段，如果有则返回相应Field字段，反之抛出NoSuchFieldException异常。关于Unfase中的<code>objectFieldOffset(Field f)</code>方法，我曾经在<a href="https://www.jianshu.com/p/d0e84096d108" target="_blank" rel="noopener">《Java并发编程之锁机制之LockSupport工具》</a>描述过类似的情况。这里我简单的再解释一遍。该方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也就是说每个字段在类对应的内存中存储是有<code>“角标”</code>的，那么也就是说我们现在的<code>PREV</code>静态变量就代表着Node中<code>prev</code>字段在内存中的“角标”。</p>
<p>当获取到”角标”后，我们再通过<code>U.putObject(node, Node.PREV, oldTail);</code>该方法第一个参数是操作对象，第二个参数是操作的内存“角标”，第三个参数是期望值。那么最后，也就完成了将当前节点的prev字段指向同步队列的尾节点。</p>
<p>当理解了该知识点后，剩下的<code>将同步队列中的tail指针，指向当前节点</code>与<code>如果当前同步队列为空，则构造同步队列</code>这两个操作就非常好理解了。由于篇幅的限制，在这里我就不在进行描述了。希望读者朋友们，能阅读源代码，举一反三。关于这两个方法的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line"> private static final long STATE;</span><br><span class="line"> private static final long HEAD;</span><br><span class="line"> private static final long TAIL;</span><br><span class="line"> static &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         STATE = U.objectFieldOffset</span><br><span class="line">             (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));</span><br><span class="line">         HEAD = U.objectFieldOffset</span><br><span class="line">             (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));</span><br><span class="line">         TAIL = U.objectFieldOffset</span><br><span class="line">             (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));</span><br><span class="line">     &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class="line">         throw new Error(e);</span><br><span class="line">     &#125;</span><br><span class="line">     Class&lt;?&gt; ensureLoaded = LockSupport.class;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private final void initializeSyncQueue() &#123;</span><br><span class="line">     Node h;</span><br><span class="line">     if (U.compareAndSwapObject(this, HEAD, null, (h = new Node())))</span><br><span class="line">         tail = h;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private final boolean compareAndSetTail(Node expect, Node update) &#123;</span><br><span class="line">     return U.compareAndSwapObject(this, TAIL, expect, update);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="唤醒流程"><a href="#唤醒流程" class="headerlink" title="唤醒流程"></a>唤醒流程</h4><p>在理解了唤醒的具体逻辑后，现在来总结一下，唤醒的具体流程。具体如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-694a82e957dce046.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="唤醒流程.png"></p>
<ul>
<li>将等待队列中的<code>头</code>节点线程，移动到同步队列中。</li>
<li>当移动到同步队列中后。唤醒该线程。是该线程参与同步状态的竞争。</li>
</ul>
<p>整体流程其实不算太复杂，大家只需要注意，<code>当我们将等待队列中的线程节点加入到同步队列之后，才会唤醒线程</code>。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>该文章参考以下图书，站在巨人的肩膀上。可以看得更远。</p>
<ul>
<li>《Java并发编程的艺术》<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3></li>
<li><a href="https://www.jianshu.com/p/4ead70bdab56" target="_blank" rel="noopener">Java并发编程之锁机制之引导篇</a></li>
<li><a href="https://www.jianshu.com/p/a372528f47a3" target="_blank" rel="noopener">《Java并发编程之锁机制之AQS》</a></li>
<li><a href="https://www.jianshu.com/p/d0e84096d108" target="_blank" rel="noopener">《Java并发编程之锁机制之LockSupport工具》</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Java并发编程之锁机制之Condition接口/" data-id="cjsheb872000tdsr7je1wdxii" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/02/23/Java并发编程之Java内存模型/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2019/02/23/「开眼Eyepetizer」SimpleEyes--学习Kotlin必备良器/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/23/RecyclerView-smoothScrollToPosition了解一下/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/RecyclerView滚动位置，滚动速度设置/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/从ButterKnife-kt-了解Kotlin-委托与扩展/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/Gradle系列-引导篇（一）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/哈希表初识(一)/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 AndyJennifer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
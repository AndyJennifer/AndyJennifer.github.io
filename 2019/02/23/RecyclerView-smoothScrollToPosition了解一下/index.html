<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>AndyJennifer‘Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言最近开发中遇到了一个需求，需要RecyclerView滚动到指定位置后置顶显示，当时遇到这个问题的时候，心里第一反应是直接使用RecyclerView的smoothScrollToPosition()方法，实现对应位置的平滑滚动。但是在实际使用中发现并没有到底自己想要的效果。本想着偷懒直接从网上Copy下，但是发现效果并不是很好。于是就自己去研究源码。 该系列文章分为两篇文章。  如果你想了">
<meta name="keywords" content="AndyJennifer">
<meta property="og:type" content="article">
<meta property="og:title" content="AndyJennifer‘Blog">
<meta property="og:url" content="http://yoursite.com/2019/02/23/RecyclerView-smoothScrollToPosition了解一下/index.html">
<meta property="og:site_name" content="AndyJennifer‘Blog">
<meta property="og:description" content="前言最近开发中遇到了一个需求，需要RecyclerView滚动到指定位置后置顶显示，当时遇到这个问题的时候，心里第一反应是直接使用RecyclerView的smoothScrollToPosition()方法，实现对应位置的平滑滚动。但是在实际使用中发现并没有到底自己想要的效果。本想着偷懒直接从网上Copy下，但是发现效果并不是很好。于是就自己去研究源码。 该系列文章分为两篇文章。  如果你想了">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-48cb9d674242f237.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-adfb99815ff0749c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-a93317f4d1132363.gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-dd8dbff1903166fd.gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-b382d5e31904f16a.gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2824145-26280c06b41544a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-02-23T11:20:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AndyJennifer‘Blog">
<meta name="twitter:description" content="前言最近开发中遇到了一个需求，需要RecyclerView滚动到指定位置后置顶显示，当时遇到这个问题的时候，心里第一反应是直接使用RecyclerView的smoothScrollToPosition()方法，实现对应位置的平滑滚动。但是在实际使用中发现并没有到底自己想要的效果。本想着偷懒直接从网上Copy下，但是发现效果并不是很好。于是就自己去研究源码。 该系列文章分为两篇文章。  如果你想了">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2824145-48cb9d674242f237.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="AndyJennifer‘Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AndyJennifer‘Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">What would life be if we had no courage to attempt anything?</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-RecyclerView-smoothScrollToPosition了解一下" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/RecyclerView-smoothScrollToPosition了解一下/" class="article-date">
  <time datetime="2019-02-23T11:20:02.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-48cb9d674242f237.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小狗狗.jpg"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近开发中遇到了一个需求，需要RecyclerView滚动到指定位置后置顶显示，当时遇到这个问题的时候，心里第一反应是直接使用RecyclerView的smoothScrollToPosition()方法，实现对应位置的平滑滚动。但是在实际使用中发现并没有到底自己想要的效果。本想着偷懒直接从网上Copy下，但是发现效果并不是很好。于是就自己去研究源码。</p>
<p>该系列文章分为两篇文章。</p>
<ul>
<li>如果你想了解其内部实现，请观看本篇文章，</li>
<li>如果你想解决通过smoothScrollToPosition滚动到顶部，或者修改滚动加速，请观看<a href="https://www.jianshu.com/p/7110bedfdb5e" target="_blank" rel="noopener">RecyclerView滚动位置，滚动速度设置</a></li>
</ul>
<h3 id="什么是可见范围？"><a href="#什么是可见范围？" class="headerlink" title="什么是可见范围？"></a>什么是可见范围？</h3><p>在了解RecyclerView的smoothScrollToPosition方法之前，有个知识点，我觉得有必要给大家说一下，因为使用smoothScrollToPosition中遇到的问题都与可见范围有关。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-adfb99815ff0749c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可见范围.png"></p>
<p><strong>这里所说的可见范围是，RecyclerView第一个可见item的位置与最后一个可见item的位置之间的范围。</strong></p>
<h3 id="一、实际使用中遇见的问题"><a href="#一、实际使用中遇见的问题" class="headerlink" title="一、实际使用中遇见的问题"></a>一、实际使用中遇见的问题</h3><h4 id="如果当前滚动位置在可见范围内，是不会发生滚动的"><a href="#如果当前滚动位置在可见范围内，是不会发生滚动的" class="headerlink" title="如果当前滚动位置在可见范围内，是不会发生滚动的"></a>如果当前滚动位置在可见范围内，是不会发生滚动的</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-a93317f4d1132363.gif?imageMogr2/auto-orient/strip" alt="不会滚动.gif"></p>
<p>当前RecyclerView的可见范围为0到9，当我们想要滚动到1位置时，发现当前RecyclerView并没有发生滚动。</p>
<h4 id="二、如果当前滚动位置在可见范围之后，会滚动到底部"><a href="#二、如果当前滚动位置在可见范围之后，会滚动到底部" class="headerlink" title="二、如果当前滚动位置在可见范围之后，会滚动到底部"></a>二、如果当前滚动位置在可见范围之后，会滚动到底部</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-dd8dbff1903166fd.gif?imageMogr2/auto-orient/strip" alt="滚动到底部.gif"></p>
<p>当前RecyclerView的可见范围为0到9，当我们想要滚动到10位置时，发现RecyclerView滚动了，且当前位置对应的视图在RecyclreView的底部。</p>
<h4 id="三、如果当前滚动位置在可见范围之前，会滚动到顶部"><a href="#三、如果当前滚动位置在可见范围之前，会滚动到顶部" class="headerlink" title="三、如果当前滚动位置在可见范围之前，会滚动到顶部"></a>三、如果当前滚动位置在可见范围之前，会滚动到顶部</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-b382d5e31904f16a.gif?imageMogr2/auto-orient/strip" alt="滚动到顶部.gif"></p>
<p>这里我们滚动RecyclerView,使其可见范围为10到19，当我们分别滚动到1、3位置时，RecyclerView滚动了。且当前位置对应的视图在RecyclerView的顶部。</p>
<h3 id="二、RecyclerView-smoothScrollToPosition源码解析"><a href="#二、RecyclerView-smoothScrollToPosition源码解析" class="headerlink" title="二、RecyclerView smoothScrollToPosition源码解析"></a>二、RecyclerView smoothScrollToPosition源码解析</h3><p>到了这里我们发现对于不同情况，RecyclerView内部处理是不一样的，所以为了解决实际问题，看源码是必不可少的，接下来我们就一起跟着源码走一遍。来看看RecyclerView具体的滚动实现。（这里需要提醒大家的是这里我采用的是<strong>LinearLayoutManager</strong>，本文章都是基于LinearLayoutManager进行分析的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void smoothScrollToPosition(int position) &#123;</span><br><span class="line">      if (mLayoutFrozen) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (mLayout == null) &#123;</span><br><span class="line">          Log.e(TAG, &quot;Cannot smooth scroll without a LayoutManager set. &quot;</span><br><span class="line">                  + &quot;Call setLayoutManager with a non-null argument.&quot;);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      mLayout.smoothScrollToPosition(this, mState, position);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>mRecycler.smoothScrollToPosition()方法时，内部调用了LayoutManager的smoothScrollToPosition方法,LayoutManager中smoothScrollToPosition没有实现，具体实现在其子类中，这里我们使用的是<strong>LinearLayoutManager</strong>，所以我们来看看内部是怎么实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state,</span><br><span class="line">         int position) &#123;</span><br><span class="line">     LinearSmoothScroller scroller = new LinearSmoothScroller(recyclerView.getContext());</span><br><span class="line">     scroller.setTargetPosition(position);//设定目标位置</span><br><span class="line">     startSmoothScroll(scroller);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到，这里导致RecyclerView滑动的是LinearSmoothScroller，而LinearSmoothScroller的父类是RecyclerView.SmoothScroller，看到这里我相信大家都会感到一丝熟悉，因为我们在对控件内内容进行移动的时候，我们都会使用到一个类，那就是Scroller。这里RecyclerView也自定了一个滑动Scroller。肯定是与滑动其内部视图相关的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void startSmoothScroll(SmoothScroller smoothScroller) &#123;</span><br><span class="line">           if (mSmoothScroller != null &amp;&amp; smoothScroller != mSmoothScroller</span><br><span class="line">                   &amp;&amp; mSmoothScroller.isRunning()) &#123;</span><br><span class="line">               mSmoothScroller.stop();</span><br><span class="line">           &#125;</span><br><span class="line">           mSmoothScroller = smoothScroller;</span><br><span class="line">           mSmoothScroller.start(mRecyclerView, this);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>继续走startSmoothScroll,方法内部判断了如果正在计算坐标值就停止，然后调用start()方法重新开始计算坐标值。接着开始看start()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void start(RecyclerView recyclerView, LayoutManager layoutManager) &#123;</span><br><span class="line">           mRecyclerView = recyclerView;</span><br><span class="line">           mLayoutManager = layoutManager;</span><br><span class="line">           if (mTargetPosition == RecyclerView.NO_POSITION) &#123;</span><br><span class="line">               throw new IllegalArgumentException(&quot;Invalid target position&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           mRecyclerView.mState.mTargetPosition = mTargetPosition;</span><br><span class="line">           mRunning = true;//设置当前scroller已经开始执行</span><br><span class="line">           mPendingInitialRun = true;</span><br><span class="line">           mTargetView = findViewByPosition(getTargetPosition());//根据目标位置查找相应View,</span><br><span class="line">           onStart();</span><br><span class="line">           mRecyclerView.mViewFlinger.postOnAnimation();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>在start方法中，会标识当前scroller的执行状态，同时会根据滚动的位置去寻找对应的目标视图。这里需要着重提示一下，findViewByPosition（）这个方法，该方法会在Recycler的可见范围内去查询是否有目标位置对应的视图，例如，现在RecyclerView的可见范围为1-9，目标位置为10，那么mTargetView =null,如果可见范围为9-20，目标位置为1，那么mTargetView =null。</p>
<p>最终调用RecyclerView的内部类 ViewFlinger的postOnAnimation()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ViewFlinger implements Runnable &#123;</span><br><span class="line"> ....省略部分代码</span><br><span class="line">  void postOnAnimation() &#123;</span><br><span class="line">         if (mEatRunOnAnimationRequest) &#123;</span><br><span class="line">             mReSchedulePostAnimationCallback = true;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             removeCallbacks(this);</span><br><span class="line">             ViewCompat.postOnAnimation(RecyclerView.this, this);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现，ViewFlinger其实一个Runnable,在postOnAnimation()内部又将该Runnable发送出去了。那下面我们只用关心ViewFlinger的run()方法就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">          ...省略部分代码</span><br><span class="line">         final OverScroller scroller = mScroller;</span><br><span class="line">         //获得layoutManger中的SmoothScroller</span><br><span class="line">         final SmoothScroller smoothScroller = mLayout.mSmoothScroller;</span><br><span class="line">         if (scroller.computeScrollOffset()) &#123;//如果是第一次走，会返回false</span><br><span class="line">             ...省略部分代码</span><br><span class="line">          &#125;</span><br><span class="line">         if (smoothScroller != null) &#123;</span><br><span class="line">             if (smoothScroller.isPendingInitialRun()) &#123;</span><br><span class="line">                 smoothScroller.onAnimation(0, 0);</span><br><span class="line">             &#125;</span><br><span class="line">             if (!mReSchedulePostAnimationCallback) &#123;</span><br><span class="line">                 smoothScroller.stop(); //stop if it does not trigger any scroll</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">           ...省略部分代码</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>ViewFlinger的run()方法内部实现比较复杂， 在该方法第一次执行的时候，会执行，if (scroller.computeScrollOffset()) ，其中scroller是ViewFlinger中的属性mScroller的引用，其中mScroller会在ViewFlinger创建对象的时候，就默认初始化了。那么第一次判断时候，因为还没有开始计算，所以不会进这个if语句块，那么接下来就会直接走下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (smoothScroller != null) &#123;</span><br><span class="line">              if (smoothScroller.isPendingInitialRun()) &#123;</span><br><span class="line">                  smoothScroller.onAnimation(0, 0);</span><br><span class="line">              &#125;</span><br><span class="line">              if (!mReSchedulePostAnimationCallback) &#123;</span><br><span class="line">                  smoothScroller.stop(); //stop if it does not trigger any scroll</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>最后发现，只是走了一个onAnimation（0，0），继续走该方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void onAnimation(int dx, int dy) &#123;</span><br><span class="line">           final RecyclerView recyclerView = mRecyclerView;</span><br><span class="line">           if (!mRunning || mTargetPosition == RecyclerView.NO_POSITION || recyclerView == null) &#123;</span><br><span class="line">               stop();</span><br><span class="line">           &#125;</span><br><span class="line">           mPendingInitialRun = false;</span><br><span class="line">           if (mTargetView != null) &#123;//判断目标视图是否存在，如果存在则计算移动到位置需要移动的距离</span><br><span class="line">               if (getChildPosition(mTargetView) == mTargetPosition) &#123;</span><br><span class="line">                   onTargetFound(mTargetView, recyclerView.mState, mRecyclingAction);</span><br><span class="line">                   mRecyclingAction.runIfNecessary(recyclerView);</span><br><span class="line">                   stop();</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   Log.e(TAG, &quot;Passed over target position while smooth scrolling.&quot;);</span><br><span class="line">                   mTargetView = null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (mRunning) &#123;//如果不存在，继续去找</span><br><span class="line">               onSeekTargetStep(dx, dy, recyclerView.mState, mRecyclingAction);</span><br><span class="line">               boolean hadJumpTarget = mRecyclingAction.hasJumpTarget();</span><br><span class="line">               mRecyclingAction.runIfNecessary(recyclerView);</span><br><span class="line">               if (hadJumpTarget) &#123;</span><br><span class="line">                   // It is not stopped so needs to be restarted</span><br><span class="line">                   if (mRunning) &#123;</span><br><span class="line">                       mPendingInitialRun = true;</span><br><span class="line">                       recyclerView.mViewFlinger.postOnAnimation();</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       stop(); // done</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>在onAnimation方法中，判断了目标视图是否为空，大家应该还记得上文中，我们对目标视图的查找。如果当前位置不在可见范围之内，那么mTargetView  =null,就不回走对应的判断语句。继续查看onSeekTargetStep()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void onSeekTargetStep(int dx, int dy, RecyclerView.State state, Action action) &#123;</span><br><span class="line">    if (getChildCount() == 0) &#123;</span><br><span class="line">        stop();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //noinspection PointlessBooleanExpression</span><br><span class="line">    if (DEBUG &amp;&amp; mTargetVector != null</span><br><span class="line">            &amp;&amp; ((mTargetVector.x * dx &lt; 0 || mTargetVector.y * dy &lt; 0))) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Scroll happened in the opposite direction&quot;</span><br><span class="line">                + &quot; of the target. Some calculations are wrong&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mInterimTargetDx = clampApplyScroll(mInterimTargetDx, dx);</span><br><span class="line">    mInterimTargetDy = clampApplyScroll(mInterimTargetDy, dy);</span><br><span class="line"></span><br><span class="line">    if (mInterimTargetDx == 0 &amp;&amp; mInterimTargetDy == 0) &#123;</span><br><span class="line">        updateActionForInterimTarget(action);</span><br><span class="line">    &#125; // everything is valid, keep going</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接通过代码，发现并不理解改函数要做什么样的工作，这里我们只知道第一次发生滚动时，mInterimTargetDx=0与mInterimTargetDy =0，那么会走updateActionForInterimTarget（）方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  protected void updateActionForInterimTarget(Action action) &#123;</span><br><span class="line">      // find an interim target position</span><br><span class="line">      PointF scrollVector = computeScrollVectorForPosition(getTargetPosition());</span><br><span class="line">...省略部分代码</span><br><span class="line">      normalize(scrollVector);</span><br><span class="line">      mTargetVector = scrollVector;</span><br><span class="line"></span><br><span class="line">      mInterimTargetDx = (int) (TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector.x);</span><br><span class="line">      mInterimTargetDy = (int) (TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector.y);</span><br><span class="line">      </span><br><span class="line">//计算需要滚动的时间，  默认滚动距离，TARGET_SEEK_SCROLL_DISTANCE_PX = 10000;</span><br><span class="line">      final int time = calculateTimeForScrolling(TARGET_SEEK_SCROLL_DISTANCE_PX);</span><br><span class="line">  </span><br><span class="line">//为了避免在滚动的时候出现停顿，我们会跟踪onSeekTargetStep中的回调距离，实际上不会滚动超出实际的距离</span><br><span class="line">      action.update((int) (mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO),</span><br><span class="line">              (int) (mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO),</span><br><span class="line">              //这里存入的时间要比实际花费的时间大一点。</span><br><span class="line">              (int) (time * TARGET_SEEK_EXTRA_SCROLL_RATIO), mLinearInterpolator);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>根据官方文档进行翻译：当目标滚动位置对应视图不在RecyclerView的可见范围内，该方法计算朝向该视图的方向向量并触发平滑滚动。默认滚动的距离为12000(单位：px)，<strong>（也就是说了为了滚动到目标位置，会让Recycler至多滚动12000个像素）</strong>。</p>
<p>既然该方法计算了时间，那么我们就看看calculateTimeForScrolling()方法，通过方法名我们就应该了解了该方法是计算给定距离在默认速度下需要滚动的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected int calculateTimeForScrolling(int dx) &#123;</span><br><span class="line"> //这里对时间进行了四舍五入操作。 </span><br><span class="line">    return (int) Math.ceil(Math.abs(dx) * MILLISECONDS_PER_PX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中MILLISECONDS_PER_PX 会在LinearSmoothScroller初始化的时候创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public LinearSmoothScroller(Context context) &#123;</span><br><span class="line">    MILLISECONDS_PER_PX = calculateSpeedPerPixel(context.getResources().getDisplayMetrics());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>查看calculateSpeedPerPixel()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final float MILLISECONDS_PER_INCH = 25f;// 默认为移动一英寸需要花费25ms</span><br><span class="line">protected float calculateSpeedPerPixel(DisplayMetrics displayMetrics) &#123;</span><br><span class="line">    return MILLISECONDS_PER_INCH / displayMetrics.densityDpi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，当前滚动的速度是与屏幕的像素密度相关， 通过获取当前手机屏幕每英寸的像素密度，与每英寸移动所需要花费的时间，用每英寸移动所需要花费的时间除以像素密度就能计算出移动一个像素密度需要花费的时间。OK,既然我们已经算出了移动一个像素密度需要花费的时间，那么直接乘以像素，就能算出移动该像素所需要花费的时间了。</p>
<p>既然现在我们算出了时间，我们现在只用关心Action的update()方法到底是干什么的就好了，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//保存关于SmoothScroller滑动距离信息</span><br><span class="line">      public static class Action &#123;</span><br><span class="line">       ...省略代码</span><br><span class="line">        public void update(int dx, int dy, int duration, Interpolator interpolator) &#123;</span><br><span class="line">              mDx = dx;</span><br><span class="line">              mDy = dy;</span><br><span class="line">              mDuration = duration;</span><br><span class="line">              mInterpolator = interpolator;</span><br><span class="line">              mChanged = true;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现Action,只是存储关于SmoothScroller滑动信息的一个类，那么初始时保存了横向与竖直滑动的距离（12000px）、滑动时间，插值器。同时记录当前数据改变的状态。</p>
<p>现在我们已经把Action的onSeekTargetStep方法走完了，那接下来，我们继续看Action的runIfNecessary()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void runIfNecessary(RecyclerView recyclerView) &#123;</span><br><span class="line">        ....省略代码</span><br><span class="line">             if (mChanged) &#123;</span><br><span class="line">                 validate();</span><br><span class="line">                 if (mInterpolator == null) &#123;</span><br><span class="line">                     if (mDuration == UNDEFINED_DURATION) &#123;</span><br><span class="line">                         recyclerView.mViewFlinger.smoothScrollBy(mDx, mDy);</span><br><span class="line">                     &#125; else &#123;</span><br><span class="line">                      //这里传入的mDx,mDy,mDuration.是Action之前update()方法。保存的信息</span><br><span class="line">                         recyclerView.mViewFlinger.smoothScrollBy(mDx, mDy, mDuration);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     recyclerView.mViewFlinger.smoothScrollBy(</span><br><span class="line">                             mDx, mDy, mDuration, mInterpolator);</span><br><span class="line">                 &#125;</span><br><span class="line">           mChanged = false;</span><br><span class="line">             ....省略代码</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>TNND,调来调去最后又把Action存储的信息传给了ViewFlinger的smoothScrollBy()方法。这里需要注意:<strong>一旦调用该方法会将mChanged置为false,下次再次进入该方法时，那么就不会调用ViewFlinger的滑动方法了。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void smoothScrollBy(int dx, int dy, int duration, Interpolator interpolator) &#123;</span><br><span class="line">		 //判断是否是同一插值器，如果不是，重新创建mScroller</span><br><span class="line">           if (mInterpolator != interpolator) &#123;</span><br><span class="line">               mInterpolator = interpolator;</span><br><span class="line">               mScroller = new OverScroller(getContext(), interpolator);</span><br><span class="line">           &#125;</span><br><span class="line">           setScrollState(SCROLL_STATE_SETTLING);</span><br><span class="line">           mLastFlingX = mLastFlingY = 0;</span><br><span class="line">           mScroller.startScroll(0, 0, dx, dy, duration);</span><br><span class="line">           if (Build.VERSION.SDK_INT &lt; 23) &#123;</span><br><span class="line">               mScroller.computeScrollOffset();</span><br><span class="line">           &#125;</span><br><span class="line">           postOnAnimation();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>这里mScroller接受到Acttion传入的滑动信息开始滑动后。最后会调用postOnAnimation()，又将ViewFiinger的run()法发送出去。那么最终我们又回到了ViewFiinger的run()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> public void run() &#123;</span><br><span class="line">      ...省略部分代码</span><br><span class="line">if (scroller.computeScrollOffset()) &#123;</span><br><span class="line">             final int[] scrollConsumed = mScrollConsumed;</span><br><span class="line">             final int x = scroller.getCurrX();</span><br><span class="line">             final int y = scroller.getCurrY();</span><br><span class="line">             int dx = x - mLastFlingX;</span><br><span class="line">             int dy = y - mLastFlingY;</span><br><span class="line">             int hresult = 0;</span><br><span class="line">             int vresult = 0;</span><br><span class="line">             mLastFlingX = x;</span><br><span class="line">             mLastFlingY = y;</span><br><span class="line">             int overscrollX = 0, overscrollY = 0;</span><br><span class="line">       ...省略部分代码</span><br><span class="line">             if (mAdapter != null) &#123;</span><br><span class="line">                 startInterceptRequestLayout();</span><br><span class="line">                 onEnterLayoutOrScroll();</span><br><span class="line">                 TraceCompat.beginSection(TRACE_SCROLL_TAG);</span><br><span class="line">                 fillRemainingScrollValues(mState);</span><br><span class="line">                 if (dx != 0) &#123;//如果横向方向大于0，开始让RecyclerView滚动</span><br><span class="line">                     hresult = mLayout.scrollHorizontallyBy(dx, mRecycler, mState);</span><br><span class="line">                     overscrollX = dx - hresult;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (dy != 0) &#123;//如果竖直方向大于0，开始让RecyclerView滚动，获得当前滚动的距离</span><br><span class="line">                     vresult = mLayout.scrollVerticallyBy(dy, mRecycler, mState);</span><br><span class="line">                     overscrollY = dy - vresult;</span><br><span class="line">                 &#125;</span><br><span class="line">                 TraceCompat.endSection();</span><br><span class="line">                 repositionShadowingViews();</span><br><span class="line"></span><br><span class="line">                 onExitLayoutOrScroll();</span><br><span class="line">                 stopInterceptRequestLayout(false);</span><br><span class="line">                 if (smoothScroller != null &amp;&amp; !smoothScroller.isPendingInitialRun()</span><br><span class="line">                         &amp;&amp; smoothScroller.isRunning()) &#123;</span><br><span class="line">                     final int adapterSize = mState.getItemCount();</span><br><span class="line">                     if (adapterSize == 0) &#123;</span><br><span class="line">                         smoothScroller.stop();</span><br><span class="line">                     &#125; else if (smoothScroller.getTargetPosition() &gt;= adapterSize) &#123;</span><br><span class="line">                         smoothScroller.setTargetPosition(adapterSize - 1);</span><br><span class="line">                         //传入当前RecylerView滚动的距离 dx dy</span><br><span class="line">                         smoothScroller.onAnimation(dx - overscrollX, dy - overscrollY);</span><br><span class="line">                     &#125; else &#123;</span><br><span class="line">                         //传入当前RecylerView滚动的距离 dx dy</span><br><span class="line">                         smoothScroller.onAnimation(dx - overscrollX, dy - overscrollY);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             enableRunOnAnimationRequests();</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里scroller（拿到之前Action传入的滑动距离信息）已经开始滑动了，故 if (scroller.computeScrollOffset()) 条件为true, 那么scroller拿到当前竖直方向的值就开始让RecyclerView滚动了,也就是代码 mLayout.scrollVerticallyBy(dy, mRecycler, mState);接着又让smoothScroller执行onAnimation()方法。其中传入的参数是RecyclerView已经滚动的距离。那我们现在继续看onAnimation方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void onAnimation(int dx, int dy) &#123;</span><br><span class="line">        final RecyclerView recyclerView = mRecyclerView;</span><br><span class="line">        if (!mRunning || mTargetPosition == RecyclerView.NO_POSITION || recyclerView == null) &#123;</span><br><span class="line">            stop();</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingInitialRun = false;</span><br><span class="line">        if (mTargetView != null) &#123;</span><br><span class="line">            // verify target position</span><br><span class="line">            if (getChildPosition(mTargetView) == mTargetPosition) &#123;</span><br><span class="line">                onTargetFound(mTargetView, recyclerView.mState, mRecyclingAction);</span><br><span class="line">                mRecyclingAction.runIfNecessary(recyclerView);</span><br><span class="line">                stop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.e(TAG, &quot;Passed over target position while smooth scrolling.&quot;);</span><br><span class="line">                mTargetView = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mRunning) &#123;//获得当前Recycler需要滚动的距离</span><br><span class="line">            onSeekTargetStep(dx, dy, recyclerView.mState, mRecyclingAction);</span><br><span class="line">            boolean hadJumpTarget = mRecyclingAction.hasJumpTarget();</span><br><span class="line">            mRecyclingAction.runIfNecessary(recyclerView);</span><br><span class="line">            if (hadJumpTarget) &#123;</span><br><span class="line">                // It is not stopped so needs to be restarted</span><br><span class="line">                if (mRunning) &#123;</span><br><span class="line">                    mPendingInitialRun = true;</span><br><span class="line">                    recyclerView.mViewFlinger.postOnAnimation();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    stop(); // done</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么现在代码就明了了，RecylerView会判断在滚动的时候，目标视图是否已经出现，如果没有出现，会调用onSeekTargetStep保存当前RecylerView滚动距离，然后判断RecyclerView是否需要滑动，然后又通过postOnAnimation()将ViewFlinger 发送出去了。那么直到找到目标视图才会停止。</p>
<p>那什么情况下，目标视图不为空呢，其实在RecylerView内部滚动的时候。会判断目标视图是否存在，如果存在会对mTargetView进行赋值操作。由于篇幅限制，这里就不对目标视图的查找进行介绍了，有兴趣的小伙伴可以自己看一下源码。</p>
<p>那接下来，我们就假如当前已经找到了目标视图，那么接下来程序会走onTargetFound()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void onTargetFound(View targetView, RecyclerView.State state, Action action) &#123;</span><br><span class="line">      //计算让目标视图可见的，需要滚动的横向距离</span><br><span class="line">      final int dx = calculateDxToMakeVisible(targetView, getHorizontalSnapPreference());</span><br><span class="line">     //计算让目标视图可见的，需要滚动的横向距离</span><br><span class="line">      final int dy = calculateDyToMakeVisible(targetView, getVerticalSnapPreference());</span><br><span class="line">      final int distance = (int) Math.sqrt(dx * dx + dy * dy);</span><br><span class="line">      final int time = calculateTimeForDeceleration(distance);</span><br><span class="line">      if (time &gt; 0) &#123;</span><br><span class="line">          //更新需要滚动的距离。</span><br><span class="line">          action.update(-dx, -dy, time, mDecelerateInterpolator);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当目标视图被找到以后，会计算让目标视图出现在可见范围内，需要移动的横向与纵向距离。并计算所需要花费的时间。然后重新让RecyclerView滚动一段距离。  </p>
<p>这里我们着重看calculateDyToMakeVisible。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int calculateDyToMakeVisible(View view, int snapPreference) &#123;</span><br><span class="line">    final RecyclerView.LayoutManager layoutManager = getLayoutManager();</span><br><span class="line">    if (layoutManager == null || !layoutManager.canScrollVertically()) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)</span><br><span class="line">            view.getLayoutParams();</span><br><span class="line">    //获取当前view在其父布局的开始位置</span><br><span class="line">    final int top = layoutManager.getDecoratedTop(view) - params.topMargin;</span><br><span class="line">    //获取当前View在其父布局结束位置</span><br><span class="line">    final int bottom = layoutManager.getDecoratedBottom(view) + params.bottomMargin;</span><br><span class="line">    //获取当前布局的开始位置 </span><br><span class="line">    final int start = layoutManager.getPaddingTop();</span><br><span class="line">    //获取当前布局的结束位置</span><br><span class="line">    final int end = layoutManager.getHeight() - layoutManager.getPaddingBottom();</span><br><span class="line">    return calculateDtToFit(top, bottom, start, end, snapPreference);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们会根据当前view的top、bottom及当前布局的start、end等坐标信息，<strong>然后调用了calculateDtToFit（）方法。现在最重要的出现了，也是我们那三个问题出现的原因！！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int calculateDtToFit(int viewStart, int viewEnd, int boxStart, int boxEnd, int</span><br><span class="line">        snapPreference) &#123;</span><br><span class="line">    switch (snapPreference) &#123;</span><br><span class="line">        case SNAP_TO_START:</span><br><span class="line">            return boxStart - viewStart;</span><br><span class="line">        case SNAP_TO_END:</span><br><span class="line">            return boxEnd - viewEnd;</span><br><span class="line">        case SNAP_TO_ANY:</span><br><span class="line">            final int dtStart = boxStart - viewStart;</span><br><span class="line">            if (dtStart &gt; 0) &#123;//滚动位置在可见范围之前</span><br><span class="line">                return dtStart;</span><br><span class="line">            &#125;</span><br><span class="line">            final int dtEnd = boxEnd - viewEnd;</span><br><span class="line">            if (dtEnd &lt; 0) &#123;//滚动位置在可见范围之后</span><br><span class="line">                return dtEnd;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalArgumentException(&quot;snap preference should be one of the&quot;</span><br><span class="line">                    + &quot; constants defined in SmoothScroller, starting with SNAP_&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;//在可见范围之内，直接返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会根据snapPreference对应的值来计算相应的距离，同时snapPreference的具体值与getVerticalSnapPreference（这里我们是竖直方向)所以我们看该方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected int getVerticalSnapPreference() &#123;</span><br><span class="line">       return mTargetVector == null || mTargetVector.y == 0 ? SNAP_TO_ANY :</span><br><span class="line">               mTargetVector.y &gt; 0 ? SNAP_TO_END : SNAP_TO_START;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中mTargetVector与layoutManager.computeScrollVectorForPosition有关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public PointF computeScrollVectorForPosition(int targetPosition) &#123;</span><br><span class="line">      if (getChildCount() == 0) &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      final int firstChildPos = getPosition(getChildAt(0));</span><br><span class="line">      final int direction = targetPosition &lt; firstChildPos != mShouldReverseLayout ? -1 : 1;</span><br><span class="line">      if (mOrientation == HORIZONTAL) &#123;</span><br><span class="line">          return new PointF(direction, 0);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          return new PointF(0, direction);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说在LinerlayoutManager为竖直的情况下，snapPreference默认为SNAP_ANY,那么我们就可以得到，下面三种情况。</p>
<ul>
<li>当滚动位置在可见范围之内时<br>boxStart - viewStart&lt;=0<br>boxEnd - viewEnd&gt;0<br><strong>滚动距离为0，故不会滚动</strong></li>
<li>当滚动位置在可见范围之前时<br>boxStart - viewStart&gt; 0<br><strong>那么实际滚动距离为正值，内容向上滚动，故只能滚动到顶部</strong></li>
<li>当滚动位置在可见范围距离之外时<br>boxEnd - viewEnd&lt;0<br><strong>那么实际滚动距离为其差值，内容向下滚动，故只能滚动到底部</strong></li>
</ul>
<p>有可能大家现在看代码已经看晕了，下面我就用一张图来总结整个流程，结合流程图再去看代码，我相信大家能有更好的理解。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-26280c06b41544a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本流程图.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/RecyclerView-smoothScrollToPosition了解一下/" data-id="cjsheb872000udsr74g5e47v3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/02/23/RecyclerView滚动位置，滚动速度设置/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/23/RecyclerView-smoothScrollToPosition了解一下/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/RecyclerView滚动位置，滚动速度设置/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/从ButterKnife-kt-了解Kotlin-委托与扩展/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/Gradle系列-引导篇（一）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/哈希表初识(一)/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 AndyJennifer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/bangbangtang-32*32.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/bangbangtang-16*16.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="前言上篇文章我们讲了volatile关键字，我们大致了解了其为轻量级的同步机制，现在我们来讲讲我们关于同步的另一个兄弟synchronized。synchronized作为开发中常用的同步机制，也是我们处理线程安全的常用方法。相信大家对其都比较熟悉。但是对于其内部原理与底层代码实现大家有可能不是很了解，下面我就和大家一起彻底了解synchronized的使用方式与底层原理。 线程安全的问题 线程">
<meta name="keywords" content="并发">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程之Synchronized(三)">
<meta property="og:url" content="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/index.html">
<meta property="og:site_name" content="AndyJennifer&#39;Blog">
<meta property="og:description" content="前言上篇文章我们讲了volatile关键字，我们大致了解了其为轻量级的同步机制，现在我们来讲讲我们关于同步的另一个兄弟synchronized。synchronized作为开发中常用的同步机制，也是我们处理线程安全的常用方法。相信大家对其都比较熟悉。但是对于其内部原理与底层代码实现大家有可能不是很了解，下面我就和大家一起彻底了解synchronized的使用方式与底层原理。 线程安全的问题 线程">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/学习.jpeg">
<meta property="og:image" content="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/输出结果.png">
<meta property="og:image" content="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/输出结果.png">
<meta property="og:image" content="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/TIM截图20180821140901.png">
<meta property="og:image" content="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/对象存储结构.png">
<meta property="og:image" content="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/无锁状态.png">
<meta property="og:image" content="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/有锁状态.png">
<meta property="og:image" content="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/轻量级锁获取示意图.png">
<meta property="og:image" content="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/偏向锁获得和撤销示意图.png">
<meta property="og:image" content="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/轻量级锁膨胀示意图.png">
<meta property="og:updated_time" content="2019-07-27T09:57:26.444Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发编程之Synchronized(三)">
<meta name="twitter:description" content="前言上篇文章我们讲了volatile关键字，我们大致了解了其为轻量级的同步机制，现在我们来讲讲我们关于同步的另一个兄弟synchronized。synchronized作为开发中常用的同步机制，也是我们处理线程安全的常用方法。相信大家对其都比较熟悉。但是对于其内部原理与底层代码实现大家有可能不是很了解，下面我就和大家一起彻底了解synchronized的使用方式与底层原理。 线程安全的问题 线程">
<meta name="twitter:image" content="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/学习.jpeg">






  <link rel="canonical" href="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java并发编程之Synchronized(三) | AndyJennifer'Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AndyJennifer'Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">What would life be if we had no courage to attempt anything?</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

  <a href="https://github.com/AndyJennifer" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/23/Java并发编程之Synchronized(三)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AndyJennifer">
      <meta itemprop="description" content="AndyJennifer 个人站，主要涉及Android、Java、Kotlin等相关知识，愿与大家共同学习，共同进步">
      <meta itemprop="image" content="http://upload-images.jianshu.io/upload_images/2824145-e320240ea6ec767d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AndyJennifer'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java并发编程之Synchronized(三)

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-23 21:35:03" itemprop="dateCreated datePublished" datetime="2019-02-23T21:35:03+08:00">2019-02-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-27 17:57:26" itemprop="dateModified" datetime="2019-07-27T17:57:26+08:00">2019-07-27</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java并发相关/" itemprop="url" rel="index"><span itemprop="name">Java并发相关</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <img src="/2019/02/23/Java并发编程之Synchronized(三)/学习.jpeg" title="学习">
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上篇文章我们讲了<strong>volatile</strong>关键字，我们大致了解了其为轻量级的同步机制，现在我们来讲讲我们关于同步的另一个兄弟<strong>synchronized</strong>。synchronized作为开发中常用的同步机制，也是我们处理线程安全的常用方法。相信大家对其都比较熟悉。但是对于其内部原理与底层代码实现大家有可能不是很了解，下面我就和大家一起彻底了解synchronized的使用方式与底层原理。</p>
<h3 id="线程安全的问题"><a href="#线程安全的问题" class="headerlink" title="线程安全的问题"></a>线程安全的问题</h3><blockquote>
<p>线程安全的定义：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么这个类就是线程安全的。</p>
</blockquote>
<p>在具体讲解synchronized之前，我们需要了解一下什么是线程安全，为什么会出现线程线程不安全的问题。请看下列代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadNotSafeDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                num += i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"-"</span> + num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            Count count = <span class="keyword">new</span> Count();</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                count.count();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建10个线程，</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，我们创建Count类，在该类中有一个count()方法，计算从1一直加到10的和，在计算完后输出当前线程的名称与计算的结果，我们期望线程输出的结果是首项为55且等差为55的等差数列。但是结果并不是我们期望的。具体结果如下图所示：</p>
<img src="/2019/02/23/Java并发编程之Synchronized(三)/输出结果.png" title="输出结果">
<p>我们可以看见，线程并没有按照我们之间想的那样，线程按照从Thread-0到Thread-9依次排列，并且Thread-0与Thread-1线程输出的结果是错误的。</p>
<p>之所以会出现这样的情况，是CPU在调度的时候线程是可以交替执行的，具体来讲是因为当前线程Thread-0求和后，（求和后num值为55），在即将执行打印语句时，突然CPU开始调度执行Thread-1去执行count()方法，那么Thread-0就会停留在即将打印语句的位置，当Thread-1执行计算和后（求和后num值为100），这个时候CPU又开始调度Thread-0执行打印语句。则Thread-1开始暂停，而这个时候num值已经为110了，所以Thread-0打印输出的结果为110。</p>
<h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><p>上面我们了解了之所以会出现线程安全的问题，主要原因就是因为存在多条线程共同操作共享数据，同时CPU的调度的时候线程是可以交替执行的。导致了程序的语义发生改变，所以会出现与我们预期的结果违背的情况。因此为了解决这个问题，在Java中提供了两种方式来处理这种情况。</p>
<h4 id="互斥同步-悲观锁"><a href="#互斥同步-悲观锁" class="headerlink" title="互斥同步(悲观锁)"></a>互斥同步(悲观锁)</h4><p>互斥同步是指当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行。</p>
<p>在Java中最基本的互斥同步就是<strong>synchronized</strong>(这里我们讨论的是jdk1.6之前，在jdk1.6之后Java团队对锁进行了优化，后面文章会具体描述)，也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。</p>
<p>除了synchronized之外，我们还可以使用java.util.concurrent包下的<strong>ReentrantLock</strong>来实现同步。</p>
<h4 id="非阻塞式同步（乐观锁）"><a href="#非阻塞式同步（乐观锁）" class="headerlink" title="非阻塞式同步（乐观锁）"></a>非阻塞式同步（乐观锁）</h4><p>互斥同步主要的问题就是进行线程阻塞和唤醒锁带来的性能问题，为了解决这性能问题，我们有另一种解决方案，当多个线程竞争某个共享数据时，没有获得锁的线程不会阻塞，而是不断的尝试去获取锁，直到成功为止。这种方案的原理就是使用<strong>循环CAS操作</strong>来实现。</p>
<h3 id="synchronized的三种使用方式"><a href="#synchronized的三种使用方式" class="headerlink" title="synchronized的三种使用方式"></a>synchronized的三种使用方式</h3><p>了解了synchronized的解决的问题，那么我们继续来看看在Java中在Java中synchronized的使用情况。</p>
<p>在Java中synchronized主要有三种使用的情况。下面分别列出了这几种情况</p>
<ul>
<li>修饰普通的实例方法，对于普通的同步方法，锁式当前实例对象</li>
<li>修饰静态方法，对于静态同步方法，锁式当前类的Class对象</li>
<li>修饰代码块，对于同步方法块，锁是Synchronized配置的对象</li>
</ul>
<h4 id="证明当前普通的同步方法，锁式当前实例对象"><a href="#证明当前普通的同步方法，锁式当前实例对象" class="headerlink" title="证明当前普通的同步方法，锁式当前实例对象"></a>证明当前普通的同步方法，锁式当前实例对象</h4><p>为了证明普通的同步方法中，锁是当前对象。请观察以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">normalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doPrint(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockMethod</span><span class="params">()</span> </span>&#123;<span class="comment">//注意,同步块方法块中，配置的是当前类的对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            doPrint(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印当前线程信息与角标值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + index);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedDemo demo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.normalMethod(), <span class="string">"testNormalMethod"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.normalMethod(), <span class="string">"testBlockMethod"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在上诉代码中，分别创建了两个方法，normalMethod（）与blockMethod（）方法，其中normalMethod()方法为普通的同步方法，blockMethod（）方法中，是一个同步块且配置的对象是当前类的对象。在Main()方法中，分别创建两个线程执行两个不同的方法。</p>
<h5 id="程序输出结果"><a href="#程序输出结果" class="headerlink" title="程序输出结果"></a>程序输出结果</h5><img src="/2019/02/23/Java并发编程之Synchronized(三)/输出结果.png" title="输出结果">
<p>观察程序输出结果，我们可以看到normalMethod方法是由于blockMethod方法执行的，且blockMethod方法是在normalMethod方法执行完成之后在执行的。也就证明了我们的对于普通的同步方法锁式当前实例对象的结论。</p>
<h4 id="证明对于静态同步方法，锁式当前类的Class对象"><a href="#证明对于静态同步方法，锁式当前类的Class对象" class="headerlink" title="证明对于静态同步方法，锁式当前类的Class对象"></a>证明对于静态同步方法，锁式当前类的Class对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class) &#123;<span class="comment">//注意,同步块方法块中，配置的是当前类的Class对象</span></span><br><span class="line">            doPrint(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doPrint(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印当前线程信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + index);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedDemo demo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.blockMethod(), <span class="string">"testBlockMethod"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.staticMethod(), <span class="string">"testStaticMethod"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在有了第一个结论的证明后，对于静态同步方法的锁对象就不再进行描述了（但是大家要注意一下，同步方法块中配置的对象是当前类的Class对象）。下面直接给出输出结果：<br><img src="/2019/02/23/Java并发编程之Synchronized(三)/TIM截图20180821140901.png" title="TIM截图20180821140901"></p>
<p>观察结果，也很明显的证明了对于静态同步方法，锁式当前类的Class对象的结论</p>
<h3 id="Synchronized的原理"><a href="#Synchronized的原理" class="headerlink" title="Synchronized的原理"></a>Synchronized的原理</h3><blockquote>
<p>下面文章主要是讲解jdk1.6之后Java团队对锁进行了优化之后的原理，优化之后涉及到偏向锁、轻量级锁、重量级锁。其中该文章都涉及jdk源码，这里把最新的jdk源码分享给大家—–&gt;<a href="https://pan.baidu.com/s/1Lk9yp8cEpSAnLvw5NJdqZg" target="_blank" rel="noopener">jdk源码</a>）</p>
</blockquote>
<p>在了解Synchronized的原理的原理之前，我们需要知道三个知识点<strong>第一个是CAS操作</strong>、<strong>第二个是Java对象头（其中Synchronized使用的锁就在对象头中）</strong>、<strong>第三个是jdk1.6对锁的优化</strong>。在了解以上三个知识点后，再去理解其原理就相对轻松一点。关于CAS操作会在下篇文章<a href="/2019/02/23/Java并发编程之Java的CAS操作(四)/" title="Java并发编程之Java的CAS操作(四)">Java并发编程之Java的CAS操作(四)</a>进行过讲解，下面我们来讲解关于Java对象头与锁优化的知识点。</p>
<h4 id="Java对象的内存布局"><a href="#Java对象的内存布局" class="headerlink" title="Java对象的内存布局"></a>Java对象的内存布局</h4><p>在Java虚拟机中，对象在内存的存储的布局可以分为3块区域：对象头（Header)、实例数据（Instance Data)、对其填充（Padding)。其中虚拟机中的对象头包括三部分信息，分别为”Mark Word”、类型指针、记录数组长度的数据（可选），具体情况如下图所示：</p>
<img src="/2019/02/23/Java并发编程之Synchronized(三)/对象存储结构.png" title="对象存储结构">
<h4 id="Java对象头的组成"><a href="#Java对象头的组成" class="headerlink" title="Java对象头的组成"></a>Java对象头的组成</h4><ul>
<li>“Mark Word“：第一部分用于存储对象自身的运行时数据。如哈希码（HashCode）、GC分代年龄、<strong>锁状态标志</strong>、线<strong>程持有的锁</strong>、偏向锁ID、偏向锁时间戳等，这部分的数据在长度32位与64位的虚拟机中分别为32bit和64bit，官方称为“Mark Word”。</li>
<li>类型指针：对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。（<strong>Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁</strong>)</li>
<li>记录数组长度数据：对象头剩下的一部分是用于记录数组长度的数据（如果当前对象不是数组，就没有这一部分数据），如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。因为虚拟机可以通过普通Java对象的元数据信息来确定Java对象的大小，但是从数组中的元数据中无法确定数组的大小。</li>
</ul>
<h4 id="“Mark-Word“数据结构"><a href="#“Mark-Word“数据结构" class="headerlink" title="“Mark Word“数据结构"></a>“Mark Word“数据结构</h4><p>其中关于”Mark Word”，因为存储对象头信息是与对象身定义的数据无关的额外的存储成本，考虑到虚拟机的空间效率，”Mark Word”被设计成一个被设计成一个非固定的数据结构以便在极小的空间存储尽量多的信息。它会根据对象的状态复用自己的存储区域。在JVM中，“Mark Word”的实现是在markOop.hpp文件中的markOopDesc类。通过注释我们大致了解”Mark Word”的结构，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hash:保存对象的哈希码</span><br><span class="line">age:GC分代年龄</span><br><span class="line">biased_lock:偏向锁标志</span><br><span class="line">lock:锁状态标志</span><br><span class="line">JavaThread*  当前线程</span><br><span class="line">epoch:保存偏向时间戳</span><br><span class="line"></span><br><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，分成了2种不同位数的操作系统，32位与64位。其中关于当前锁的状态标志markOopDesc类中也进行了详细的说明，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; locked_value             = <span class="number">0</span>,<span class="comment">//轻量级锁 对应[00]</span></span><br><span class="line">       unlocked_value           = <span class="number">1</span>,<span class="comment">//无锁状态  对应[01]</span></span><br><span class="line">       monitor_value            = <span class="number">2</span>,<span class="comment">//重量级锁 对应[10]</span></span><br><span class="line">       marked_value             = <span class="number">3</span>,<span class="comment">//GC标记  对应[11]</span></span><br><span class="line">       biased_lock_pattern      = <span class="number">5</span><span class="comment">//是否是偏向锁  对应[101] 其中biased_lock一个bit位，lock两个bit位</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么根据上述代码，我们以32位操作系统为例，可以生成如下两张表：</p>
<h5 id="在无锁状态下，32位JVM的“Mark-Word”的默认存储结构"><a href="#在无锁状态下，32位JVM的“Mark-Word”的默认存储结构" class="headerlink" title="在无锁状态下，32位JVM的“Mark Word”的默认存储结构"></a>在无锁状态下，32位JVM的“Mark Word”的默认存储结构</h5><img src="/2019/02/23/Java并发编程之Synchronized(三)/无锁状态.png" title="无锁状态">
<p>在无锁状态下，“Mark Word“的32bit空间中，25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志<strong>（其中01标识当前线程为无锁状态）</strong>，1bit固定为0。</p>
<h5 id="在有锁状态态下，32位JVM的“Mark-Word”的默认存储结构"><a href="#在有锁状态态下，32位JVM的“Mark-Word”的默认存储结构" class="headerlink" title="在有锁状态态下，32位JVM的“Mark Word”的默认存储结构"></a>在有锁状态态下，32位JVM的“Mark Word”的默认存储结构</h5><img src="/2019/02/23/Java并发编程之Synchronized(三)/有锁状态.png" title="有锁状态">
<p>在有锁的状态下，23个bit位用于存储当前线程id,2个bit位用于存储偏向锁时间戳，4个bit为用于存储分代年龄（用于GC),1个bit位存储当前是否是偏向锁，最后的2bit用于当前锁的不同状态。其中00标识当前锁为轻量级锁，10标识为重量级锁，01标识当前锁为偏向锁。</p>
<h3 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h3><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。下面会对各种锁进行介绍。</p>
<ul>
<li><strong>偏向锁</strong><br>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，当一个线程访问同步块，并获取锁是，会在对象头中的“Mark word”和栈帧中的锁记录里存储锁偏向的线程ID。以后该线程在进入和退出同步块时，不需要进行CAS操作来加锁和解锁。只需简单地测试一下对象头的”Mark Word“里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下“Mark Word”中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>
<li><strong>轻量级锁</strong><br>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为<strong>Displaced Mark Word</strong>。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>
<li><strong>重量级锁</strong></li>
</ul>
<p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁，重量级锁会导致竞争的线程<strong>互斥同步。</strong></p>
<h3 id="synchronized底层代码实现"><a href="#synchronized底层代码实现" class="headerlink" title="synchronized底层代码实现"></a>synchronized底层代码实现</h3><p>在了解了上述知识点后，我们来了解一下synchronized底层代码实现。从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。<strong>代码块同步是使用monitorenter和monitorexit指令实现的</strong>，而<strong>方法同步是使用字节码同步指令ACC_SYNCHRONIZED来实现</strong>的，细节在JVM规范里并没有详细说明。但是方法的同步同样可以使用这两个指令来实现。那我们这里我们就以synchronized代码块底层原理来进行讲解。</p>
<blockquote>
<p><strong>字节码同步指令ACC_SYNCHRONIZED原理</strong>：JVM通过使用管程（Monitor)来支持同步，JVM可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志来得知一个方法是否声明为同步方法，当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程（Monitor)，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程，在方法执行期间，执行线程持有了管程，其他任何线程都无法在获取到同一个管程。</p>
</blockquote>
<h3 id="synchronized代码块底层原理"><a href="#synchronized代码块底层原理" class="headerlink" title="synchronized代码块底层原理"></a>synchronized代码块底层原理</h3><p>在了解 synchronized代码块底层原理之前，我们先了解我们常用的synchronized代码块使用方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncCodeBlock</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//同步代码库</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们通过javap指令反编译得到字节码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//===========主要看看syncTask方法实现================</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter  <span class="comment">//注意此处，进入同步方法</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: dup</span><br><span class="line">         6: getfield      #2             // Field i:I</span><br><span class="line">         <span class="number">9</span>: iconst_1</span><br><span class="line">        <span class="number">10</span>: iadd</span><br><span class="line">        11: putfield      #2            // Field i:I</span><br><span class="line">        <span class="number">14</span>: aload_1</span><br><span class="line">        <span class="number">15</span>: monitorexit   <span class="comment">//注意此处，退出同步方法</span></span><br><span class="line">        <span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line">        <span class="number">19</span>: astore_2</span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: monitorexit <span class="comment">//注意此处，退出同步方法</span></span><br><span class="line">        <span class="number">22</span>: aload_2</span><br><span class="line">        <span class="number">23</span>: athrow</span><br><span class="line">        <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">      <span class="comment">//省略其他字节码.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上诉代码中，我们可以明白当我们声明synchronized代码块的时候，编译器会我们生产相应的monitorenter  与monitorexit 指令。当我们的JVM把字节码加载到内存的时候，会对这两个指令进行解析。其中关于monitorenter 与monitorenter的指令解析是通过InterpreterRuntime.cpp文件中的<strong>InterpreterRuntime::monitorenter</strong>与<strong>InterpreterRuntime::monitorexit</strong>两个函数分别实现的。</p>
<ul>
<li>InterpreterRuntime::monitorenter(JavaThread<em> thread, BasicObjectLock</em> elem)</li>
<li>InterpreterRuntime::monitorexit(JavaThread<em> thread, BasicObjectLock</em> elem)</li>
</ul>
<p>在了解具体的方法实现之间，我们需要了解两个参数信息，第一个参数猜都都猜出来，当前线程的指针，第二个参数为BasicObjectLock类型的指针，那我们来看看BasicObjectLock到底是什么东西。</p>
<h4 id="BasicObjectLock"><a href="#BasicObjectLock" class="headerlink" title="BasicObjectLock"></a>BasicObjectLock</h4><p>关于BasicObjectLock的类具体声明是在basicLock.hpp文件下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicLock</span> </span>&#123;</span><br><span class="line">  friend <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span></span>;</span><br><span class="line">  friend <span class="class"><span class="keyword">class</span> <span class="title">JVMCIVMStructs</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//指向"Mark Word“也就是我们提到过的markOopDesc的指针。这里markOop是markOopDesc的别名</span></span><br><span class="line">  <span class="keyword">volatile</span> markOop _displaced_header;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//获取"Mark Word“也就是我们提到过的markOopDesc，这里markOop是markOopDesc的别名</span></span><br><span class="line">  <span class="function">markOop      <span class="title">displaced_header</span><span class="params">()</span> <span class="keyword">const</span>               </span>&#123; <span class="keyword">return</span> _displaced_header; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>         <span class="title">set_displaced_header</span><span class="params">(markOop header)</span>   </span>&#123; _displaced_header = header; &#125;</span><br><span class="line">  <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicObjectLock</span> </span>&#123;</span><br><span class="line">  friend <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  BasicLock _lock; <span class="comment">//拥有BasicLock对象</span></span><br><span class="line">  oop       _obj;</span><br><span class="line">  <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从该文件中，我们知道在BasicLock类中指向”Mark Word“的指针，同时BasicObjectLock 也拥有BasicLock对象，那么BasicObjectLock 就能访问”Mark Word“中的内容了。那现在我们再来看上面提到的两个对应的方法。</p>
<h4 id="InterpreterRuntime-monitorenter方法"><a href="#InterpreterRuntime-monitorenter方法" class="headerlink" title="InterpreterRuntime::monitorenter方法"></a>InterpreterRuntime::monitorenter方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">  <span class="comment">//省略部分代码</span></span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;<span class="comment">//判断是否使用偏向锁</span></span><br><span class="line">    <span class="comment">//如果是使用偏向锁，则进入快速获取，避免不必要的膨胀。</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="keyword">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则直接走轻量级锁的获取</span></span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//省略部分代码</span></span><br></pre></td></tr></table></figure>
<p>当monitorenter方法执行时，会先判断当前是否开启偏向锁（偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态），如果没有开启会直接走轻量级锁的获取，也就是slow_enter（）方法。</p>
<h5 id="偏向锁的获取"><a href="#偏向锁的获取" class="headerlink" title="偏向锁的获取"></a>偏向锁的获取</h5><p>ObjectSynchronizer::fast_enter（）方法是在sychronizer.cpp文件进行声明的，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock,</span><br><span class="line">                                    bool attempt_rebias, TRAPS) &#123;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;<span class="comment">//如果使用偏向锁</span></span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;<span class="comment">//如果不在安全点，获取当前偏向锁的状态（可能撤销与重偏向）</span></span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;<span class="comment">//如果是撤销与重偏向直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果在安全点，有可能会撤销偏向锁</span></span><br><span class="line">      <span class="keyword">assert</span>(!attempt_rebias, <span class="string">"can not rebias toward VM thread"</span>);</span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//省略部分代码</span></span><br><span class="line">  &#125;</span><br><span class="line">  slow_enter(obj, lock, THREAD);<span class="comment">//如果不使用偏向锁，则走轻量级锁的获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该方法中如果当前JVM支持偏向锁，会需要等待全局安全点（在这个时间点上没有正在执行的字节码），如果当前不在安全点中，会调用revoke_and_rebias（）方法来获取当前偏向锁的状态（可能为撤销或撤销后重偏向）。如果在安全点，会根据当前偏向锁的状态来判断是否需要撤销偏向锁。<strong>其中revoke_and_rebias（）方法是在biasedLocking.cpp中进行声明的。</strong></p>
<h4 id="BiasedLocking-revoke-and-rebias（）方法"><a href="#BiasedLocking-revoke-and-rebias（）方法" class="headerlink" title="BiasedLocking::revoke_and_rebias（）方法"></a>BiasedLocking::revoke_and_rebias（）方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">BiasedLocking::Condition BiasedLocking::revoke_and_rebias(Handle obj, bool attempt_rebias, TRAPS) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(!SafepointSynchronize::is_at_safepoint(), <span class="string">"must not be called while at safepoint"</span>);</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第一步，如果没有其他线程占用该对象（mark word中线程id为0，后三位为101，且不尝试重偏向)</span></span><br><span class="line">  <span class="comment">//这里“fast enter（）方法"传入的attempt_rebias为true</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;is_biased_anonymously() &amp;&amp; !attempt_rebias) &#123;</span><br><span class="line">    <span class="comment">//一般来讲，只有在重新计算对象hashCode的时候才会进入该分支，</span></span><br><span class="line">    <span class="comment">//所以直接用用CAS操作将对象设置为无锁状态</span></span><br><span class="line">    markOop biased_value       = mark;</span><br><span class="line">    markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(mark-&gt;age());</span><br><span class="line">    markOop res_mark = obj-&gt;cas_set_mark(unbiased_prototype, mark);<span class="comment">//cas 操作从新设置偏向锁的状态</span></span><br><span class="line">    <span class="keyword">if</span> (res_mark == biased_value) &#123;<span class="comment">//如果CAS操作失败，说明存在竞争，偏向锁为撤销状态</span></span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">    <span class="comment">//第二步，判断当前偏向锁是否已经锁定(不管mark word中线程id是否为null),尝试重偏向</span></span><br><span class="line">    Klass* k = obj-&gt;klass();</span><br><span class="line">    markOop prototype_header = k-&gt;prototype_header();</span><br><span class="line">    <span class="keyword">if</span> (!prototype_header-&gt;has_bias_pattern()) &#123;</span><br><span class="line">     <span class="comment">//第三步如果有线程对该对象进行了全局锁定（即同步了静态方法/属性），则取消偏向操作</span></span><br><span class="line">      markOop biased_value       = mark;</span><br><span class="line">      markOop res_mark = obj-&gt;cas_set_mark(prototype_header, mark);</span><br><span class="line">      <span class="keyword">assert</span>(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">"even if we raced, should still be revoked"</span>);</span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;<span class="comment">//偏向锁为撤销状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prototype_header-&gt;bias_epoch() != mark-&gt;bias_epoch()) &#123;  <span class="comment">//第四步，如果偏向锁时间过期，（这个时候有另一个线程通过偏向锁获取到了这个对象的锁）</span></span><br><span class="line">      <span class="keyword">if</span> (attempt_rebias) &#123;<span class="comment">//第五步，如果偏向锁开启，重新通过cas操作更新时间戳与分代年龄。</span></span><br><span class="line">        <span class="keyword">assert</span>(THREAD-&gt;is_Java_thread(), <span class="string">""</span>);</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop rebiased_prototype = markOopDesc::encode((JavaThread*) THREAD, mark-&gt;age(), prototype_header-&gt;bias_epoch());</span><br><span class="line">        markOop res_mark = obj-&gt;cas_set_mark(rebiased_prototype, mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED_AND_REBIASED;<span class="comment">//撤销偏移后重偏向。</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//第六步，如果偏向锁关闭，通过CAS操作更新分代年龄</span></span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(mark-&gt;age());</span><br><span class="line">        markOop res_mark = obj-&gt;cas_set_mark(unbiased_prototype, mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED;<span class="comment">////如果CAS操作失败，说明存在竞争，偏向锁为撤销状态</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//省略部分代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>偏向锁的获取由BiasedLocking::revoke_and_rebias方法实现，主要分为五个步骤</p>
<ol>
<li>第一步，判断当前偏向锁中”Mark word”中线程id是否为null，且attempt_rebias =false。如果满足条件，尝试通过CAS操作将当前对象设置为无锁状态。如果CAS操作失败，说明存在竞争，偏向锁为撤销状态。</li>
<li>第二步，判断当前偏向锁是否已经锁定（不管mark word中线程id是否为null）,会根据当前条件走第三、第四、第五步。</li>
<li>第三步，如果有线程对该对象进行了全局锁定（即同步了静态方法/属性），偏向锁为撤销状态。</li>
<li>第四步，判断偏向锁时间是否过期（这个时候有另一个线程通过偏向锁获取到了这个对象的锁），接着走第五步、第六步的条件判断</li>
<li>第五步，在偏向锁时间过期的条件下，如果偏向锁开启，那么通过CAS操作更新时间戳与分代年龄、线程ID，如果失败,表明该对象的锁状态已经从撤销偏向到了另一线程。当前偏向锁的状态为撤销后重偏向。</li>
<li>第六步，在偏向锁时间过期的条件下，如果偏向锁默认关闭，那么通过CAS操作更新分代年龄，如果失败，说明存在线程的竞争，偏向锁为撤销状态。</li>
</ol>
<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p>在上文中我们提到了在调用fast_enter（）方法时，如果在安全点，这时会根据偏向锁的状态来判断是否需要撤销偏向锁，也就是调用revoke_at_safepoint（）方法。其中该方法也是在biasedLocking.cpp中进行声明的，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BiasedLocking::revoke_at_safepoint(Handle h_obj) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(SafepointSynchronize::is_at_safepoint(), <span class="string">"must only be called while at safepoint"</span>);</span><br><span class="line">  oop obj = h_obj();</span><br><span class="line">  HeuristicsResult heuristics = update_heuristics(obj, <span class="keyword">false</span>);<span class="comment">//获得偏向锁偏向与撤销的次数</span></span><br><span class="line">  <span class="keyword">if</span> (heuristics == HR_SINGLE_REVOKE) &#123;<span class="comment">//如果是一次撤销</span></span><br><span class="line">    revoke_bias(obj, <span class="keyword">false</span>, <span class="keyword">false</span>, NULL, NULL);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((heuristics == HR_BULK_REBIAS) ||<span class="comment">//如果是多次撤销或多次偏向</span></span><br><span class="line">             (heuristics == HR_BULK_REVOKE)) &#123;</span><br><span class="line">    bulk_revoke_or_rebias_at_safepoint(obj, (heuristics == HR_BULK_REBIAS), <span class="keyword">false</span>, NULL);</span><br><span class="line">  &#125;</span><br><span class="line">  clean_up_cached_monitor_info();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察代码我们可以发现，会根据当前偏向锁偏向与撤销的次数走不同的方法。这里我们以revoke_bias()方法为例，来进行讲解。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BiasedLocking::<span class="function">Condition <span class="title">revoke_bias</span><span class="params">(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread, JavaThread** biased_locker)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//省略部分代码...</span></span><br><span class="line">  uint age = mark-&gt;age();</span><br><span class="line">  markOop   biased_prototype = markOopDesc::biased_locking_prototype()-&gt;set_age(age);</span><br><span class="line">  markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(age);</span><br><span class="line">  </span><br><span class="line">  JavaThread* biased_thread = mark-&gt;biased_locker();</span><br><span class="line">  <span class="keyword">if</span> (biased_thread == NULL) &#123;<span class="comment">//判断当前偏向锁中，偏向线程id是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (!allow_rebias) &#123;<span class="comment">//如果不允许重偏向，则使其偏向锁不可用。</span></span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略部分代码...</span></span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//判断当前偏向锁偏向的线程是否存在</span></span><br><span class="line">  bool thread_is_alive = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (requesting_thread == biased_thread) &#123;</span><br><span class="line">    thread_is_alive = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ThreadsListHandle tlh;</span><br><span class="line">    thread_is_alive = tlh.includes(biased_thread);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!thread_is_alive) &#123;<span class="comment">//如果当前偏向锁偏向的线程不存活</span></span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">      obj-&gt;set_mark(biased_prototype);<span class="comment">//如果允许偏向，则将偏向锁中的 线程id置为null</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);<span class="comment">//否则，将偏向锁设置为无锁状态 也就是01</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历当前锁记录，找到拥有锁的线程，将需要的displaced headers 写到线程堆栈中。</span></span><br><span class="line">  GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_thread);</span><br><span class="line">  BasicLock* highest_lock = NULL;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cached_monitor_info-&gt;length(); i++) &#123;</span><br><span class="line">    MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);</span><br><span class="line">    <span class="keyword">if</span> (oopDesc::equals(mon_info-&gt;owner(), obj)) &#123;</span><br><span class="line">      markOop mark = markOopDesc::encode((BasicLock*) NULL);</span><br><span class="line">      highest_lock = mon_info-&gt;lock();</span><br><span class="line">      highest_lock-&gt;set_displaced_header(mark);<span class="comment">//将dispalece headers 写入堆栈中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略部分代码...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (highest_lock != NULL) &#123;<span class="comment">//将需要的displaced headers 写到线程堆栈</span></span><br><span class="line">   <span class="comment">//省略部分代码...</span></span><br><span class="line">    highest_lock-&gt;set_displaced_header(unbiased_prototype);</span><br><span class="line">   <span class="comment">//省略部分代码...</span></span><br><span class="line">    obj-&gt;release_set_mark(markOopDesc::encode(highest_lock));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//省略部分代码...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//将对象的头恢复到未锁定或无偏状态</span></span><br><span class="line">     <span class="comment">//省略部分代码...</span></span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">      obj-&gt;set_mark(biased_prototype);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Store the unlocked value into the object's header.</span></span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取偏向锁指向的线程</span></span><br><span class="line">  <span class="keyword">if</span> (biased_locker != NULL) &#123;</span><br><span class="line">    *biased_locker = biased_thread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在偏向锁的撤销，需要等待全局全局点（这个时间点没有在执行的字节码），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态。会更将偏向锁设置为无锁状态，如果线程仍然活着，拥有偏向锁的栈<br>会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<h4 id="轻量级锁的获取"><a href="#轻量级锁的获取" class="headerlink" title="轻量级锁的获取"></a>轻量级锁的获取</h4><p>在上文中我们说过当monitorenter指令执行时，如果当前偏向锁没有开启或多个线程竞争偏向锁导致偏向锁升级为轻量级锁时，那么会直接走轻量级的锁的获取。在讲解轻量级锁的获取之前，需要讲解一个知识点”Displaced Mark Word”。</p>
<h5 id="轻量级锁获与“Displaced-Mark-Word”"><a href="#轻量级锁获与“Displaced-Mark-Word”" class="headerlink" title="轻量级锁获与“Displaced Mark Word”"></a>轻量级锁获与“Displaced Mark Word”</h5><p>在代码进入同步块，执行轻量级锁获取之前，如果此同步对象没有被锁定（锁标志为01状态），JVM会在当前线程的帧栈中建立一个名为锁记录（Lock Record)的空间，用于存储对象目前的”Mark Word”的拷贝（官方把这份拷贝加了一个Displaced前缀，及Displaced Mark Word）。虚拟机将使用CAS操作尝试将对象的“Mark word”更新为指向Lock Record的指针，如果这个更新动作成功了，那么这个现场就拥有了该对象的锁，及该对象处于轻量级锁定状态。关于轻量级锁的获取，具体示意图如下：</p>
<img src="/2019/02/23/Java并发编程之Synchronized(三)/轻量级锁获取示意图.png" title="轻量级锁获取示意图">
<h5 id="ObjectSynchronizer-slow-enter（）方法"><a href="#ObjectSynchronizer-slow-enter（）方法" class="headerlink" title="ObjectSynchronizer::slow_enter（）方法"></a>ObjectSynchronizer::slow_enter（）方法</h5><p>在了解了具体的轻量级锁获取流程后，我们来查看具体的实现slow_enter()方法。该方法是在sychronizer.cpp文件进行声明的。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) &#123;</span><br><span class="line"></span><br><span class="line">  markOop mark = obj-&gt;mark();<span class="comment">//第一步 获取锁对象的“mark word"</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;<span class="comment">//第二步，判断当前锁是否是无锁状态 后两位标志位为01</span></span><br><span class="line">    <span class="comment">//第三步，如果是无锁状态，存储对象目前的“mark word"拷贝，</span></span><br><span class="line">    <span class="comment">//通过CAS尝试将锁对象Mark Word更新为指向lock Record对象的指针，</span></span><br><span class="line">    lock-&gt;set_displaced_header(mark);</span><br><span class="line">    <span class="keyword">if</span> (mark == obj()-&gt;cas_set_mark((markOop) lock, mark)) &#123;</span><br><span class="line">      TEVENT(slow_enter: release stacklock); <span class="comment">//如果更新成功，表示获得锁，则执行同步代码，</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第四步，如果当前mark处于加锁状态，且线程帧栈中的owner指向当前锁，则执行同步代码，</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp;</span><br><span class="line">             THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">    lock-&gt;set_displaced_header(NULL);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第五步，否则说明有多个线程竞争轻量级锁，轻量级锁需要膨胀升级为重量级锁；</span></span><br><span class="line">  lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">  ObjectSynchronizer::inflate(THREAD,</span><br><span class="line">                              obj(),</span><br><span class="line">                              inflate_cause_monitor_enter)-&gt;enter(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在轻量级锁的获取中，主要分为五个步骤，主要步骤如下：</p>
<ol>
<li>第一步：markOop mark = obj-&gt;mark()方法获取锁对象的markOop数据mark。</li>
<li>第二步：mark-&gt;is_neutral()方法判断mark是否为无锁状态：mark的偏向锁标志位为 0，锁标志位为 01。</li>
<li>第三步：如果处于无锁状态，存储对象目前的“Mark Word”拷贝,通过CAS尝试将锁对象的“Mark Word”更新为指向lock Record对象的指针，如果更新成功，表示竞争到锁，则执行同步代码。</li>
<li>第四步：如果处于有锁状态，且线程帧栈中的owner指向当前锁，则执行同步代码，</li>
<li>第五步：如果都不满足，否则说明有多个线程竞争轻量级锁，轻量级锁需要膨胀升级为重量级锁。</li>
</ol>
<p>适用情形：假设线程A和B同时执行到临界区if (mark-&gt;is_neutral())：</p>
<ol>
<li>线程AB都把Mark Word复制到各自的lock Record空间中，该数据保存在线程的栈帧上，是线程私有的；</li>
<li>通过CAS操作保证只有一个线程可以把指向栈帧的指针复制到Mark Word，假设此时线程A执行成功，并返回继续执行同步代码块。</li>
<li>线程B执行失败，退出临界区，通过ObjectSynchronizer::inflate方法开始膨胀锁（将轻量级锁膨胀为重量级锁）</li>
</ol>
<h4 id="轻量级锁的撤销"><a href="#轻量级锁的撤销" class="headerlink" title="轻量级锁的撤销"></a>轻量级锁的撤销</h4><p>在上文中，我们讲过当走完同步块的时候，会执行monitorexit指令，而轻量级锁的释放这正是在monitorexit执行的时候，也就是InterpreterRuntime::monitorexit（）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">#ifdef ASSERT</span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line">#endif</span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj()</span>)</span>;</span><br><span class="line">  <span class="keyword">assert</span>(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span> (elem == NULL || h_obj()-&gt;is_unlocked()) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_IllegalMonitorStateException());</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::slow_exit(h_obj(), elem-&gt;lock(), thread);</span><br><span class="line">  <span class="comment">// Free entry. This must be done here, since a pending exception might be installed on</span></span><br><span class="line">  <span class="comment">// exit. If it is not cleared, the exception handling code will try to unlock the monitor again.</span></span><br><span class="line">  elem-&gt;set_obj(NULL);</span><br><span class="line">#ifdef ASSERT</span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line">#endif</span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>
<p>在monitorexit（）方法中内部会调用slow_exit（）方法而slow_exit()方法内部会调用fast_exit（）方法，我们查看fast_exit（）方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::fast_exit(oop object, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">  markOop mark = object-&gt;mark();</span><br><span class="line">  <span class="comment">//省略部分代码...</span></span><br><span class="line">  markOop dhw = lock-&gt;displaced_header();<span class="comment">//获取线程堆栈中的Displaced Mark Word</span></span><br><span class="line">  <span class="keyword">if</span> (dhw == NULL) &#123;<span class="comment">//如果线程堆栈中的Displaced Mark Word为null</span></span><br><span class="line">    #ifndef PRODUCT</span><br><span class="line">    <span class="keyword">if</span> (mark != markOopDesc::INFLATING()) &#123;<span class="comment">//如果当前轻量级锁不是在膨胀为重量级锁</span></span><br><span class="line">      <span class="comment">//省略部分代码...</span></span><br><span class="line">      <span class="keyword">if</span> (mark-&gt;has_monitor()) &#123;<span class="comment">//如果已经为重量级锁，直接返回</span></span><br><span class="line">        ObjectMonitor * m = mark-&gt;monitor();</span><br><span class="line">        <span class="keyword">assert</span>(((oop)(m-&gt;object()))-&gt;mark() == mark, <span class="string">"invariant"</span>);</span><br><span class="line">        <span class="keyword">assert</span>(m-&gt;is_entered(THREAD), <span class="string">"invariant"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果当前线程拥有轻量级锁，那么通过CAS尝试把Displaced Mark Word替换到当前锁对象的Mark Word，</span></span><br><span class="line">  <span class="comment">//如果CAS成功，说明成功的释放了锁</span></span><br><span class="line">  <span class="keyword">if</span> (mark == (markOop) lock) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(dhw-&gt;is_neutral(), <span class="string">"invariant"</span>);</span><br><span class="line">    <span class="keyword">if</span> (object-&gt;cas_set_mark(dhw, mark) == mark) &#123;</span><br><span class="line">      TEVENT(fast_exit: release stack-lock);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果CAS操作失败，说明其他线程在尝试获取轻量级锁，这个时候需要将轻量级锁升级为重量级锁</span></span><br><span class="line">  ObjectSynchronizer::inflate(THREAD,</span><br><span class="line">                              object,</span><br><span class="line">                              inflate_cause_vm_internal)-&gt;exit(<span class="keyword">true</span>, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在偏向锁的释放中，会经历一下几个步骤。</p>
<ol>
<li>获取线程堆栈中的Displaced Mark Word</li>
<li>如果线程堆栈中的Displaced Mark Word为null，如果已经为重量级锁，直接返回。</li>
<li>如果当前线程拥有轻量级锁，那么通过CAS尝试把Displaced Mark Word替换到当前锁对象的Mark Word，如果CAS成功，说明成功的释放了锁</li>
<li>如果CAS操作失败，说明其他线程在尝试获取轻量级锁，这个时候需要将轻量级锁升级为重量级锁。</li>
</ol>
<h4 id="重量级锁的获取"><a href="#重量级锁的获取" class="headerlink" title="重量级锁的获取"></a>重量级锁的获取</h4><p>在上文中我们提到过，在多个线程进行轻量级锁的获取时或在轻量级锁撤销时，有肯能会膨胀为重量级锁，那现在我们就来看看膨胀的具体过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor* ObjectSynchronizer::inflate(Thread * Self,</span><br><span class="line">                                           oop object,</span><br><span class="line">                                           <span class="keyword">const</span> InflateCause cause) &#123;</span><br><span class="line">  EventJavaMonitorInflate event;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;<span class="comment">//开始自旋</span></span><br><span class="line">    <span class="keyword">const</span> markOop mark = object-&gt;mark();</span><br><span class="line">    <span class="comment">// The mark can be in one of the following states:</span></span><br><span class="line">    <span class="comment">// *  Inflated     - just return</span></span><br><span class="line">    <span class="comment">// *  Stack-locked - coerce it to inflated</span></span><br><span class="line">    <span class="comment">// *  INFLATING    - busy wait for conversion to complete</span></span><br><span class="line">    <span class="comment">// *  Neutral      - aggressively inflate the object.</span></span><br><span class="line">    <span class="comment">// *  BIASED       - Illegal.  We should never see this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.如果当前锁已经为重量级锁了，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;has_monitor()) &#123;</span><br><span class="line">      ObjectMonitor * inf = mark-&gt;monitor();</span><br><span class="line">      <span class="keyword">return</span> inf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.如果正在膨胀的过程中，在完成膨胀过程中，其他线程必须等待。</span></span><br><span class="line">    <span class="keyword">if</span> (mark == markOopDesc::INFLATING()) &#123;</span><br><span class="line">      TEVENT(Inflate: spin <span class="keyword">while</span> INFLATING);</span><br><span class="line">      ReadStableMark(object);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.如果当前为轻量级锁，迫使其膨胀为重量级锁</span></span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;has_locker()) &#123;</span><br><span class="line">      ObjectMonitor * m = omAlloc(Self);</span><br><span class="line">      m-&gt;Recycle();</span><br><span class="line">      m-&gt;_Responsible  = NULL;</span><br><span class="line">      m-&gt;_recursions   = <span class="number">0</span>;</span><br><span class="line">      m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;   <span class="comment">// Consider: maintain by type/class</span></span><br><span class="line"></span><br><span class="line">      markOop cmp = object-&gt;cas_set_mark(markOopDesc::INFLATING(), mark);</span><br><span class="line">      <span class="keyword">if</span> (cmp != mark) &#123;</span><br><span class="line">        omRelease(Self, m, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">continue</span>;       <span class="comment">// Interference -- just retry</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      markOop dmw = mark-&gt;displaced_mark_helper();</span><br><span class="line">      <span class="keyword">assert</span>(dmw-&gt;is_neutral(), <span class="string">"invariant"</span>);</span><br><span class="line"></span><br><span class="line">      m-&gt;set_header(dmw);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      m-&gt;set_owner(mark-&gt;locker());</span><br><span class="line">      m-&gt;set_object(object);</span><br><span class="line">      <span class="comment">// TODO-<span class="doctag">FIXME:</span> assert BasicLock-&gt;dhw != 0.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Must preserve store ordering. The monitor state must</span></span><br><span class="line">      <span class="comment">// be stable at the time of publishing the monitor address.</span></span><br><span class="line">      guarantee(object-&gt;mark() == markOopDesc::INFLATING(), <span class="string">"invariant"</span>);</span><br><span class="line">      object-&gt;release_set_mark(markOopDesc::encode(m));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Hopefully the performance counters are allocated on distinct cache lines</span></span><br><span class="line">      <span class="comment">// to avoid false sharing on MP systems ...</span></span><br><span class="line">      OM_PERFDATA_OP(Inflations, inc());</span><br><span class="line">      TEVENT(Inflate: overwrite stacklock);</span><br><span class="line">      <span class="keyword">if</span> (log_is_enabled(Debug, monitorinflation)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object-&gt;is_instance()) &#123;</span><br><span class="line">          ResourceMark rm;</span><br><span class="line">          log_debug(monitorinflation)(<span class="string">"Inflating object "</span> INTPTR_FORMAT <span class="string">" , mark "</span> INTPTR_FORMAT <span class="string">" , type %s"</span>,</span><br><span class="line">                                      p2i(object), p2i(object-&gt;mark()),</span><br><span class="line">                                      object-&gt;klass()-&gt;external_name());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (event.should_commit()) &#123;</span><br><span class="line">        post_monitor_inflate_event(&amp;event, object, cause);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.如果为无锁状态，重置监视器状态</span></span><br><span class="line">    <span class="keyword">assert</span>(mark-&gt;is_neutral(), <span class="string">"invariant"</span>);</span><br><span class="line">    ObjectMonitor * m = omAlloc(Self);</span><br><span class="line">    <span class="comment">// prepare m for installation - set monitor to initial state</span></span><br><span class="line">    m-&gt;Recycle();</span><br><span class="line">    m-&gt;set_header(mark);</span><br><span class="line">    m-&gt;set_owner(NULL);</span><br><span class="line">    m-&gt;set_object(object);</span><br><span class="line">    m-&gt;_recursions   = <span class="number">0</span>;</span><br><span class="line">    m-&gt;_Responsible  = NULL;</span><br><span class="line">    m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;       <span class="comment">// consider: keep metastats by type/class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object-&gt;cas_set_mark(markOopDesc::encode(m), mark) != mark) &#123;</span><br><span class="line">      m-&gt;set_object(NULL);</span><br><span class="line">      m-&gt;set_owner(NULL);</span><br><span class="line">      m-&gt;Recycle();</span><br><span class="line">      omRelease(Self, m, <span class="keyword">true</span>);</span><br><span class="line">      m = NULL;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//省略部分代码...</span></span><br><span class="line">   <span class="keyword">return</span> m ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在轻量级锁膨胀为重量级锁大致可以分为以下几个过程</p>
<ol>
<li>如果当前锁已经为重量级锁了，直接返回ObjectMonitor 对象。</li>
<li>如果正在膨胀的过程中，在完成膨胀过程中，其他线程自旋等待。这里需要注意一点，虽然是自旋操作，但不会一直占用cpu资源，会通过spin/yield/park方式挂起线程。</li>
<li>如果当前为轻量级锁，迫使其膨胀为重量级锁</li>
<li>如果是无锁，重置ObjectMonitor 中的状态。</li>
</ol>
<h3 id="锁升级示意图"><a href="#锁升级示意图" class="headerlink" title="锁升级示意图"></a>锁升级示意图</h3><p>在了解了偏向锁、轻量级锁，与重量级锁的原理后，现在我们来总结一下整个锁升级的流程。具体如下图所示：</p>
<h4 id="偏向锁获得和撤销"><a href="#偏向锁获得和撤销" class="headerlink" title="偏向锁获得和撤销"></a>偏向锁获得和撤销</h4><img src="/2019/02/23/Java并发编程之Synchronized(三)/偏向锁获得和撤销示意图.png" title="偏向锁获得和撤销示意图">
<h4 id="轻量级锁膨胀流程图"><a href="#轻量级锁膨胀流程图" class="headerlink" title="轻量级锁膨胀流程图"></a>轻量级锁膨胀流程图</h4><img src="/2019/02/23/Java并发编程之Synchronized(三)/轻量级锁膨胀示意图.png" title="轻量级锁膨胀示意图">
<h3 id="重量级锁的竞争"><a href="#重量级锁的竞争" class="headerlink" title="重量级锁的竞争"></a>重量级锁的竞争</h3><p>在上文中，我们主要介绍了整个锁升级的流程与源代码实现。而真正线程的等待与竞争我们还没有详细描述。下面我们就来讲讲当锁膨胀为重量级锁的时候，整个线程的竞争与等待过程。重量级锁的竞争是在objectMonitor.cpp中ObjectMonitor::enter()方法中实现的。</p>
<h4 id="ObjectMonitor结构"><a href="#ObjectMonitor结构" class="headerlink" title="ObjectMonitor结构"></a>ObjectMonitor结构</h4><p>在讲解具体的锁获取之前，我们需要了解<strong>每个锁对象（这里指已经升级为重量级锁的对象）都有一个ObjectMonitor（对象监视器）</strong>。也就是说每个线程获取锁对象都会通过ObjectMonitor。代码如下所示：（这里我省略了一些不必要的属性。大家只需要看一些关键的结构）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectMonitor</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    OM_OK,                    <span class="comment">// 没有错误</span></span><br><span class="line">    OM_SYSTEM_ERROR,          <span class="comment">// 系统错误</span></span><br><span class="line">    OM_ILLEGAL_MONITOR_STATE, <span class="comment">// 监视器状态异常</span></span><br><span class="line">    OM_INTERRUPTED,           <span class="comment">// 当前线程已经中断</span></span><br><span class="line">    OM_TIMED_OUT              <span class="comment">// 线程等待超时</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">volatile</span> markOop   _header;       <span class="comment">// 线程帧栈中存储的 锁对象的mark word拷贝</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:                         <span class="comment">// protected for JvmtiRawMonitor</span></span><br><span class="line">  <span class="keyword">void</span> *  <span class="keyword">volatile</span> _owner;          <span class="comment">// 指向获得objectMonitor的线程或者 BasicLock对象</span></span><br><span class="line">  <span class="keyword">volatile</span> jlong _previous_owner_tid;  <span class="comment">// 上一个获得objectMonitor的线程id</span></span><br><span class="line">  <span class="keyword">volatile</span> intptr_t  _recursions;   <span class="comment">// 同一线程重入锁的次数，如果是0，表示第一次进入</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _EntryList; <span class="comment">// 在进入或者重进入阻塞状态下的线程链表</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _WaitSet; <span class="comment">// 处于等待状态下的线程链表</span></span><br><span class="line">  <span class="keyword">volatile</span> jint  _waiters;          <span class="comment">//处于等待状态下的线程个数</span></span><br></pre></td></tr></table></figure>
<h4 id="重量级锁的获取详解"><a href="#重量级锁的获取详解" class="headerlink" title="重量级锁的获取详解"></a>重量级锁的获取详解</h4><p>在了解了ObjectMonitor 类中具体结构后，来看看具体的锁获取方法ObjectMonitor::enter（），具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectMonitor::enter(TRAPS) &#123;</span><br><span class="line"></span><br><span class="line">  Thread * <span class="keyword">const</span> Self = THREAD;<span class="comment">//当前进入enter方法的线程</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//通过CAS操作尝试吧monitor的_owner（ 指向获得objectMonitor的线程或者 BasicLock对象）设置为当前线程</span></span><br><span class="line">  <span class="keyword">void</span> * cur = Atomic::cmpxchg(Self, &amp;_owner, (<span class="keyword">void</span>*)NULL);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (cur == NULL) &#123;<span class="comment">//如果成功，当前线程获取锁成功，直接执行同步代码块</span></span><br><span class="line">    <span class="keyword">assert</span>(_recursions == <span class="number">0</span>, <span class="string">"invariant"</span>);</span><br><span class="line">    <span class="keyword">assert</span>(_owner == Self, <span class="string">"invariant"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果是同一线程，则记录当前重入的次数（上一步CAS操作不管成功还是失败，都会返回_owner指向的地址)</span></span><br><span class="line">  <span class="keyword">if</span> (cur == Self) &#123;</span><br><span class="line">    _recursions++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果之前_owner指向的BasicLock在当前线程栈上，说明当前线程是第一次进入该monitor，</span></span><br><span class="line">  <span class="comment">//设置_recursions为1，_owner为当前线程，该线程成功获得锁并返回；</span></span><br><span class="line">  <span class="keyword">if</span> (Self-&gt;is_lock_owned ((address)cur)) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_recursions == <span class="number">0</span>, <span class="string">"internal state error"</span>);</span><br><span class="line">    _recursions = <span class="number">1</span>;</span><br><span class="line">    _owner = Self;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//省略部</span></span><br><span class="line">  分代码...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//开始竞争锁</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      jt-&gt;set_suspend_equivalent();</span><br><span class="line">      EnterI(THREAD);</span><br><span class="line">      <span class="keyword">if</span> (!ExitSuspendEquivalent(jt)) <span class="keyword">break</span>;</span><br><span class="line">      _recursions = <span class="number">0</span>;</span><br><span class="line">      _succ = NULL;</span><br><span class="line">      exit(<span class="keyword">false</span>, Self);</span><br><span class="line">      jt-&gt;java_suspend_self();</span><br><span class="line">    &#125;</span><br><span class="line">    Self-&gt;set_current_pending_monitor(NULL);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//省略部分代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在重量级级锁的竞争步骤，主要分为以下几个步骤：</p>
<ol>
<li>通过CAS操作尝试吧monitor的_owner（ 指向获得objectMonitor的线程或者 BasicLock对象）设置为当前线程，如果CAS操作成功，表示线程获取锁成功，直接执行同步代码块。</li>
<li>如果是同一线程重入锁，则记录当前重入的次数。</li>
<li>如果2,3步骤都不满足，则开始竞争锁，走EnterI()方法。</li>
</ol>
<h5 id="EnterI-方法实现"><a href="#EnterI-方法实现" class="headerlink" title="EnterI()方法实现"></a>EnterI()方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectMonitor::EnterI(TRAPS) &#123;</span><br><span class="line">  Thread * <span class="keyword">const</span> Self = THREAD;</span><br><span class="line">  <span class="comment">//省略部分代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//把当前线程被封装成ObjectWaiter的node对象，状态设置成ObjectWaiter::TS_CXQ；</span></span><br><span class="line">  <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span></span>;</span><br><span class="line">  Self-&gt;_ParkEvent-&gt;reset();</span><br><span class="line">  node._prev   = (ObjectWaiter *) <span class="number">0xBAD</span>;</span><br><span class="line">  node.TState  = ObjectWaiter::TS_CXQ;<span class="comment">//TS_CXQ：为竞争锁状态</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//在for循环中，通过CAS把node节点push到_cxq链表中；</span></span><br><span class="line">  ObjectWaiter * nxt;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    node._next = nxt = _cxq;</span><br><span class="line">    <span class="comment">//如果CAS操作失败，继续尝试，是因为当期_cxq链表已经发生改变了</span></span><br><span class="line">    <span class="keyword">if</span> (Atomic::cmpxchg(&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//有可能在放入_cxq链表中时，已经获取到锁了，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">assert</span>(_succ != Self, <span class="string">"invariant"</span>);</span><br><span class="line">      <span class="keyword">assert</span>(_owner == Self, <span class="string">"invariant"</span>);</span><br><span class="line">      <span class="keyword">assert</span>(_Responsible != Self, <span class="string">"invariant"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//将node节点push到_cxq链表之后，通过自旋尝试获取锁</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//尝试获取锁</span></span><br><span class="line">    <span class="keyword">assert</span>(_owner != Self, <span class="string">"invariant"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">2</span>) &amp;&amp; _Responsible == NULL) &#123;</span><br><span class="line">      Atomic::replace_if_null(Self, &amp;_Responsible);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断执行循环的次数，如果执行相应循环后，如果还是没有获取到锁，则通过park函数将当前线程挂起，等待被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">      TEVENT(Inflated enter - park TIMED);</span><br><span class="line">      Self-&gt;_ParkEvent-&gt;park((jlong) recheckInterval);</span><br><span class="line">      <span class="comment">// Increase the recheckInterval, but clamp the value.</span></span><br><span class="line">      recheckInterval *= <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">if</span> (recheckInterval &gt; MAX_RECHECK_INTERVAL) &#123; 其中MAX_RECHECK_INTERVAL为<span class="number">1000</span></span><br><span class="line">        recheckInterval = MAX_RECHECK_INTERVAL;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TEVENT(Inflated enter - park UNTIMED);</span><br><span class="line">      Self-&gt;_ParkEvent-&gt;park();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略部分代码...</span></span><br><span class="line">    OrderAccess::fence();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//省略部分代码...</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于EnterI()方法，可以分为以下步骤：</p>
<ol>
<li>把当前线程被封装成ObjectWaiter的node对象，同时将该线程状态设置为TS_CXQ（竞争状态）</li>
<li>在for循环中，通过CAS把node节点push到_cxq链表中，如果CAS操作失败，继续尝试，是因为当期_cxq链表已经发生改变了继续for循环，如果成功直接返回。</li>
<li>将node节点push到_cxq链表之后，通过自旋尝试获取锁（TryLock方法获取锁)，如果循环一定次数后，还获取不到锁，则通过park函数挂起。（并不会消耗CPU资源）</li>
</ol>
<p>关于获取锁的TryLock方法如下所示：</p>
<h5 id="TryLock方法"><a href="#TryLock方法" class="headerlink" title="TryLock方法"></a>TryLock方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ObjectMonitor::TryLock(Thread * Self) &#123;</span><br><span class="line">  <span class="keyword">void</span> * own = _owner;</span><br><span class="line">  <span class="keyword">if</span> (own != NULL) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (Atomic::replace_if_null(Self, &amp;_owner)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数其实很简单，就是将锁中的_owner指针指向当前线程，如果成功返回1，反之返回-1。</p>
<h4 id="重量级锁的释放"><a href="#重量级锁的释放" class="headerlink" title="重量级锁的释放"></a>重量级锁的释放</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectMonitor::exit(bool not_suspended, TRAPS) &#123;</span><br><span class="line">  Thread * <span class="keyword">const</span> Self = THREAD;</span><br><span class="line">  <span class="keyword">if</span> (THREAD != _owner) &#123;<span class="comment">//如果当前锁对象中的_owner没有指向当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (THREAD-&gt;is_lock_owned((address) _owner)) &#123;</span><br><span class="line">      <span class="comment">//但是_owner指向的BasicLock在当前线程栈上,那么将_owner指向当前线程</span></span><br><span class="line">      <span class="keyword">assert</span>(_recursions == <span class="number">0</span>, <span class="string">"invariant"</span>);</span><br><span class="line">      _owner = THREAD;</span><br><span class="line">      _recursions = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//省略部分代码...</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果当前，线程重入锁的次数，不为0，那么就重新走ObjectMonitor::exit，直到重入锁次数为0为止</span></span><br><span class="line">  <span class="keyword">if</span> (_recursions != <span class="number">0</span>) &#123;</span><br><span class="line">    _recursions--;        <span class="comment">// this is simple recursive enter</span></span><br><span class="line">    TEVENT(Inflated exit - recursive);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//省略部分代码...</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Knob_ExitPolicy == <span class="number">0</span>) &#123;</span><br><span class="line">      OrderAccess::release_store(&amp;_owner, (<span class="keyword">void</span>*)NULL);   <span class="comment">//释放锁</span></span><br><span class="line">      OrderAccess::storeload();                        <span class="comment">// See if we need to wake a successor</span></span><br><span class="line">      <span class="keyword">if</span> ((intptr_t(_EntryList)|intptr_t(_cxq)) == <span class="number">0</span> || _succ != NULL) &#123;</span><br><span class="line">        TEVENT(Inflated exit - simple egress);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      TEVENT(Inflated exit - complex egress);</span><br><span class="line">    <span class="comment">//省略部分代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略部分代码...</span></span><br><span class="line">    ObjectWaiter * w = NULL;</span><br><span class="line">    <span class="keyword">int</span> QMode = Knob_QMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据QMode的模式判断，</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果QMode == 2则直接从_cxq挂起的线程中唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (QMode == <span class="number">2</span> &amp;&amp; _cxq != NULL) &#123;</span><br><span class="line">      w = _cxq;</span><br><span class="line">      ExitEpilog(Self, w);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//省略部分代码... 省略的代码为根据QMode的不同，不同的唤醒机制</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//省略部分代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重量级锁的释放可以分为以下步骤：</p>
<ol>
<li>判断当前锁对象中的_owner没有指向当前线程，如果_owner指向的BasicLock在当前线程栈上,那么将_owner指向当前线程。</li>
<li>如果当前锁对象中的_owner指向当前线程，则判断当前线程重入锁的次数，如果不为0，那么就重新走ObjectMonitor::exit（），直到重入锁次数为0为止。</li>
<li>释放当前锁，并根据QMode的模式判断，是否将_cxq中挂起的线程唤醒。还是其他操作。</li>
</ol>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>写了这么久，终于写完了。 掌声在哪里？</p>
<p>该篇文章主要是根据先关博客与自己对源码的理解，发现其实有很多东西自己还是描述的不是很清楚。主要原因是C++代码看的我头大。个人感觉Java的整个锁的机制其实涉及到蛮多的东西，自己理解的只是冰山一角，如果大家对代码或者文章不理解，请轻喷。我也是看的半懂半懂的。原谅我啦。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>站在巨人的肩膀上能看的更远。</p>
<ul>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》</li>
<li>《Java并发编程的艺术》</li>
<li><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a></li>
<li><a href="https://www.cnblogs.com/dennyzhangdd/p/6734638.html" target="_blank" rel="noopener">jdk源码剖析二: 对象内存布局、synchronized终极原理</a></li>
<li><a href="https://pan.baidu.com/s/1Lk9yp8cEpSAnLvw5NJdqZg" target="_blank" rel="noopener">jdk源码</a></li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/并发/" rel="tag"># 并发</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/23/Java并发编程之Volatile(二)/" rel="next" title="Java并发编程之Volatile(二)">
                <i class="fa fa-chevron-left"></i> Java并发编程之Volatile(二)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/23/Java并发编程之原子类(五)/" rel="prev" title="Java并发编程之原子类(五)">
                Java并发编程之原子类(五) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://upload-images.jianshu.io/upload_images/2824145-e320240ea6ec767d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AndyJennifer">
            
              <p class="site-author-name" itemprop="name">AndyJennifer</p>
              <p class="site-description motion-element" itemprop="description">AndyJennifer 个人站，主要涉及Android、Java、Kotlin等相关知识，愿与大家共同学习，共同进步</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">37</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/AndyJennifer" title="GitHub &rarr; https://github.com/AndyJennifer" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/andyjennifer@126.com" title="E-Mail &rarr; andyjennifer@126.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全的问题"><span class="nav-number">2.</span> <span class="nav-text">线程安全的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全的实现方法"><span class="nav-number">3.</span> <span class="nav-text">线程安全的实现方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#互斥同步-悲观锁"><span class="nav-number">3.1.</span> <span class="nav-text">互斥同步(悲观锁)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非阻塞式同步（乐观锁）"><span class="nav-number">3.2.</span> <span class="nav-text">非阻塞式同步（乐观锁）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized的三种使用方式"><span class="nav-number">4.</span> <span class="nav-text">synchronized的三种使用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#证明当前普通的同步方法，锁式当前实例对象"><span class="nav-number">4.1.</span> <span class="nav-text">证明当前普通的同步方法，锁式当前实例对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#程序输出结果"><span class="nav-number">4.1.1.</span> <span class="nav-text">程序输出结果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#证明对于静态同步方法，锁式当前类的Class对象"><span class="nav-number">4.2.</span> <span class="nav-text">证明对于静态同步方法，锁式当前类的Class对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized的原理"><span class="nav-number">5.</span> <span class="nav-text">Synchronized的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java对象的内存布局"><span class="nav-number">5.1.</span> <span class="nav-text">Java对象的内存布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java对象头的组成"><span class="nav-number">5.2.</span> <span class="nav-text">Java对象头的组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#“Mark-Word“数据结构"><span class="nav-number">5.3.</span> <span class="nav-text">“Mark Word“数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在无锁状态下，32位JVM的“Mark-Word”的默认存储结构"><span class="nav-number">5.3.1.</span> <span class="nav-text">在无锁状态下，32位JVM的“Mark Word”的默认存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在有锁状态态下，32位JVM的“Mark-Word”的默认存储结构"><span class="nav-number">5.3.2.</span> <span class="nav-text">在有锁状态态下，32位JVM的“Mark Word”的默认存储结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized锁优化"><span class="nav-number">6.</span> <span class="nav-text">synchronized锁优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized底层代码实现"><span class="nav-number">7.</span> <span class="nav-text">synchronized底层代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized代码块底层原理"><span class="nav-number">8.</span> <span class="nav-text">synchronized代码块底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BasicObjectLock"><span class="nav-number">8.1.</span> <span class="nav-text">BasicObjectLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InterpreterRuntime-monitorenter方法"><span class="nav-number">8.2.</span> <span class="nav-text">InterpreterRuntime::monitorenter方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#偏向锁的获取"><span class="nav-number">8.2.1.</span> <span class="nav-text">偏向锁的获取</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BiasedLocking-revoke-and-rebias（）方法"><span class="nav-number">8.3.</span> <span class="nav-text">BiasedLocking::revoke_and_rebias（）方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#偏向锁的撤销"><span class="nav-number">8.4.</span> <span class="nav-text">偏向锁的撤销</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量级锁的获取"><span class="nav-number">8.5.</span> <span class="nav-text">轻量级锁的获取</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#轻量级锁获与“Displaced-Mark-Word”"><span class="nav-number">8.5.1.</span> <span class="nav-text">轻量级锁获与“Displaced Mark Word”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ObjectSynchronizer-slow-enter（）方法"><span class="nav-number">8.5.2.</span> <span class="nav-text">ObjectSynchronizer::slow_enter（）方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量级锁的撤销"><span class="nav-number">8.6.</span> <span class="nav-text">轻量级锁的撤销</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重量级锁的获取"><span class="nav-number">8.7.</span> <span class="nav-text">重量级锁的获取</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁升级示意图"><span class="nav-number">9.</span> <span class="nav-text">锁升级示意图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#偏向锁获得和撤销"><span class="nav-number">9.1.</span> <span class="nav-text">偏向锁获得和撤销</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量级锁膨胀流程图"><span class="nav-number">9.2.</span> <span class="nav-text">轻量级锁膨胀流程图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重量级锁的竞争"><span class="nav-number">10.</span> <span class="nav-text">重量级锁的竞争</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ObjectMonitor结构"><span class="nav-number">10.1.</span> <span class="nav-text">ObjectMonitor结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重量级锁的获取详解"><span class="nav-number">10.2.</span> <span class="nav-text">重量级锁的获取详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#EnterI-方法实现"><span class="nav-number">10.2.1.</span> <span class="nav-text">EnterI()方法实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TryLock方法"><span class="nav-number">10.2.2.</span> <span class="nav-text">TryLock方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重量级锁的释放"><span class="nav-number">10.3.</span> <span class="nav-text">重量级锁的释放</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#感想"><span class="nav-number">11.</span> <span class="nav-text">感想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">12.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AndyJennifer</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>

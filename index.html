<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>AndyJennifer‘Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="AndyJennifer">
<meta property="og:type" content="website">
<meta property="og:title" content="AndyJennifer‘Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="AndyJennifer‘Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AndyJennifer‘Blog">
  
    <link rel="alternate" href="/atom.xml" title="AndyJennifer‘Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AndyJennifer‘Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">What would life be if we had no courage to attempt anything?</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-RecyclerView-smoothScrollToPosition了解一下" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/RecyclerView-smoothScrollToPosition了解一下/" class="article-date">
  <time datetime="2019-02-23T11:20:02.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-48cb9d674242f237.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小狗狗.jpg"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近开发中遇到了一个需求，需要RecyclerView滚动到指定位置后置顶显示，当时遇到这个问题的时候，心里第一反应是直接使用RecyclerView的smoothScrollToPosition()方法，实现对应位置的平滑滚动。但是在实际使用中发现并没有到底自己想要的效果。本想着偷懒直接从网上Copy下，但是发现效果并不是很好。于是就自己去研究源码。</p>
<p>该系列文章分为两篇文章。</p>
<ul>
<li>如果你想了解其内部实现，请观看本篇文章，</li>
<li>如果你想解决通过smoothScrollToPosition滚动到顶部，或者修改滚动加速，请观看<a href="https://www.jianshu.com/p/7110bedfdb5e" target="_blank" rel="noopener">RecyclerView滚动位置，滚动速度设置</a></li>
</ul>
<h3 id="什么是可见范围？"><a href="#什么是可见范围？" class="headerlink" title="什么是可见范围？"></a>什么是可见范围？</h3><p>在了解RecyclerView的smoothScrollToPosition方法之前，有个知识点，我觉得有必要给大家说一下，因为使用smoothScrollToPosition中遇到的问题都与可见范围有关。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-adfb99815ff0749c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可见范围.png"></p>
<p><strong>这里所说的可见范围是，RecyclerView第一个可见item的位置与最后一个可见item的位置之间的范围。</strong></p>
<h3 id="一、实际使用中遇见的问题"><a href="#一、实际使用中遇见的问题" class="headerlink" title="一、实际使用中遇见的问题"></a>一、实际使用中遇见的问题</h3><h4 id="如果当前滚动位置在可见范围内，是不会发生滚动的"><a href="#如果当前滚动位置在可见范围内，是不会发生滚动的" class="headerlink" title="如果当前滚动位置在可见范围内，是不会发生滚动的"></a>如果当前滚动位置在可见范围内，是不会发生滚动的</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-a93317f4d1132363.gif?imageMogr2/auto-orient/strip" alt="不会滚动.gif"></p>
<p>当前RecyclerView的可见范围为0到9，当我们想要滚动到1位置时，发现当前RecyclerView并没有发生滚动。</p>
<h4 id="二、如果当前滚动位置在可见范围之后，会滚动到底部"><a href="#二、如果当前滚动位置在可见范围之后，会滚动到底部" class="headerlink" title="二、如果当前滚动位置在可见范围之后，会滚动到底部"></a>二、如果当前滚动位置在可见范围之后，会滚动到底部</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-dd8dbff1903166fd.gif?imageMogr2/auto-orient/strip" alt="滚动到底部.gif"></p>
<p>当前RecyclerView的可见范围为0到9，当我们想要滚动到10位置时，发现RecyclerView滚动了，且当前位置对应的视图在RecyclreView的底部。</p>
<h4 id="三、如果当前滚动位置在可见范围之前，会滚动到顶部"><a href="#三、如果当前滚动位置在可见范围之前，会滚动到顶部" class="headerlink" title="三、如果当前滚动位置在可见范围之前，会滚动到顶部"></a>三、如果当前滚动位置在可见范围之前，会滚动到顶部</h4><p><img src="https://upload-images.jianshu.io/upload_images/2824145-b382d5e31904f16a.gif?imageMogr2/auto-orient/strip" alt="滚动到顶部.gif"></p>
<p>这里我们滚动RecyclerView,使其可见范围为10到19，当我们分别滚动到1、3位置时，RecyclerView滚动了。且当前位置对应的视图在RecyclerView的顶部。</p>
<h3 id="二、RecyclerView-smoothScrollToPosition源码解析"><a href="#二、RecyclerView-smoothScrollToPosition源码解析" class="headerlink" title="二、RecyclerView smoothScrollToPosition源码解析"></a>二、RecyclerView smoothScrollToPosition源码解析</h3><p>到了这里我们发现对于不同情况，RecyclerView内部处理是不一样的，所以为了解决实际问题，看源码是必不可少的，接下来我们就一起跟着源码走一遍。来看看RecyclerView具体的滚动实现。（这里需要提醒大家的是这里我采用的是<strong>LinearLayoutManager</strong>，本文章都是基于LinearLayoutManager进行分析的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void smoothScrollToPosition(int position) &#123;</span><br><span class="line">      if (mLayoutFrozen) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (mLayout == null) &#123;</span><br><span class="line">          Log.e(TAG, &quot;Cannot smooth scroll without a LayoutManager set. &quot;</span><br><span class="line">                  + &quot;Call setLayoutManager with a non-null argument.&quot;);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      mLayout.smoothScrollToPosition(this, mState, position);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>mRecycler.smoothScrollToPosition()方法时，内部调用了LayoutManager的smoothScrollToPosition方法,LayoutManager中smoothScrollToPosition没有实现，具体实现在其子类中，这里我们使用的是<strong>LinearLayoutManager</strong>，所以我们来看看内部是怎么实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state,</span><br><span class="line">         int position) &#123;</span><br><span class="line">     LinearSmoothScroller scroller = new LinearSmoothScroller(recyclerView.getContext());</span><br><span class="line">     scroller.setTargetPosition(position);//设定目标位置</span><br><span class="line">     startSmoothScroll(scroller);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到，这里导致RecyclerView滑动的是LinearSmoothScroller，而LinearSmoothScroller的父类是RecyclerView.SmoothScroller，看到这里我相信大家都会感到一丝熟悉，因为我们在对控件内内容进行移动的时候，我们都会使用到一个类，那就是Scroller。这里RecyclerView也自定了一个滑动Scroller。肯定是与滑动其内部视图相关的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void startSmoothScroll(SmoothScroller smoothScroller) &#123;</span><br><span class="line">           if (mSmoothScroller != null &amp;&amp; smoothScroller != mSmoothScroller</span><br><span class="line">                   &amp;&amp; mSmoothScroller.isRunning()) &#123;</span><br><span class="line">               mSmoothScroller.stop();</span><br><span class="line">           &#125;</span><br><span class="line">           mSmoothScroller = smoothScroller;</span><br><span class="line">           mSmoothScroller.start(mRecyclerView, this);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>继续走startSmoothScroll,方法内部判断了如果正在计算坐标值就停止，然后调用start()方法重新开始计算坐标值。接着开始看start()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void start(RecyclerView recyclerView, LayoutManager layoutManager) &#123;</span><br><span class="line">           mRecyclerView = recyclerView;</span><br><span class="line">           mLayoutManager = layoutManager;</span><br><span class="line">           if (mTargetPosition == RecyclerView.NO_POSITION) &#123;</span><br><span class="line">               throw new IllegalArgumentException(&quot;Invalid target position&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           mRecyclerView.mState.mTargetPosition = mTargetPosition;</span><br><span class="line">           mRunning = true;//设置当前scroller已经开始执行</span><br><span class="line">           mPendingInitialRun = true;</span><br><span class="line">           mTargetView = findViewByPosition(getTargetPosition());//根据目标位置查找相应View,</span><br><span class="line">           onStart();</span><br><span class="line">           mRecyclerView.mViewFlinger.postOnAnimation();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>在start方法中，会标识当前scroller的执行状态，同时会根据滚动的位置去寻找对应的目标视图。这里需要着重提示一下，findViewByPosition（）这个方法，该方法会在Recycler的可见范围内去查询是否有目标位置对应的视图，例如，现在RecyclerView的可见范围为1-9，目标位置为10，那么mTargetView =null,如果可见范围为9-20，目标位置为1，那么mTargetView =null。</p>
<p>最终调用RecyclerView的内部类 ViewFlinger的postOnAnimation()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ViewFlinger implements Runnable &#123;</span><br><span class="line"> ....省略部分代码</span><br><span class="line">  void postOnAnimation() &#123;</span><br><span class="line">         if (mEatRunOnAnimationRequest) &#123;</span><br><span class="line">             mReSchedulePostAnimationCallback = true;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             removeCallbacks(this);</span><br><span class="line">             ViewCompat.postOnAnimation(RecyclerView.this, this);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现，ViewFlinger其实一个Runnable,在postOnAnimation()内部又将该Runnable发送出去了。那下面我们只用关心ViewFlinger的run()方法就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">          ...省略部分代码</span><br><span class="line">         final OverScroller scroller = mScroller;</span><br><span class="line">         //获得layoutManger中的SmoothScroller</span><br><span class="line">         final SmoothScroller smoothScroller = mLayout.mSmoothScroller;</span><br><span class="line">         if (scroller.computeScrollOffset()) &#123;//如果是第一次走，会返回false</span><br><span class="line">             ...省略部分代码</span><br><span class="line">          &#125;</span><br><span class="line">         if (smoothScroller != null) &#123;</span><br><span class="line">             if (smoothScroller.isPendingInitialRun()) &#123;</span><br><span class="line">                 smoothScroller.onAnimation(0, 0);</span><br><span class="line">             &#125;</span><br><span class="line">             if (!mReSchedulePostAnimationCallback) &#123;</span><br><span class="line">                 smoothScroller.stop(); //stop if it does not trigger any scroll</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">           ...省略部分代码</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>ViewFlinger的run()方法内部实现比较复杂， 在该方法第一次执行的时候，会执行，if (scroller.computeScrollOffset()) ，其中scroller是ViewFlinger中的属性mScroller的引用，其中mScroller会在ViewFlinger创建对象的时候，就默认初始化了。那么第一次判断时候，因为还没有开始计算，所以不会进这个if语句块，那么接下来就会直接走下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (smoothScroller != null) &#123;</span><br><span class="line">              if (smoothScroller.isPendingInitialRun()) &#123;</span><br><span class="line">                  smoothScroller.onAnimation(0, 0);</span><br><span class="line">              &#125;</span><br><span class="line">              if (!mReSchedulePostAnimationCallback) &#123;</span><br><span class="line">                  smoothScroller.stop(); //stop if it does not trigger any scroll</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>最后发现，只是走了一个onAnimation（0，0），继续走该方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void onAnimation(int dx, int dy) &#123;</span><br><span class="line">           final RecyclerView recyclerView = mRecyclerView;</span><br><span class="line">           if (!mRunning || mTargetPosition == RecyclerView.NO_POSITION || recyclerView == null) &#123;</span><br><span class="line">               stop();</span><br><span class="line">           &#125;</span><br><span class="line">           mPendingInitialRun = false;</span><br><span class="line">           if (mTargetView != null) &#123;//判断目标视图是否存在，如果存在则计算移动到位置需要移动的距离</span><br><span class="line">               if (getChildPosition(mTargetView) == mTargetPosition) &#123;</span><br><span class="line">                   onTargetFound(mTargetView, recyclerView.mState, mRecyclingAction);</span><br><span class="line">                   mRecyclingAction.runIfNecessary(recyclerView);</span><br><span class="line">                   stop();</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   Log.e(TAG, &quot;Passed over target position while smooth scrolling.&quot;);</span><br><span class="line">                   mTargetView = null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (mRunning) &#123;//如果不存在，继续去找</span><br><span class="line">               onSeekTargetStep(dx, dy, recyclerView.mState, mRecyclingAction);</span><br><span class="line">               boolean hadJumpTarget = mRecyclingAction.hasJumpTarget();</span><br><span class="line">               mRecyclingAction.runIfNecessary(recyclerView);</span><br><span class="line">               if (hadJumpTarget) &#123;</span><br><span class="line">                   // It is not stopped so needs to be restarted</span><br><span class="line">                   if (mRunning) &#123;</span><br><span class="line">                       mPendingInitialRun = true;</span><br><span class="line">                       recyclerView.mViewFlinger.postOnAnimation();</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       stop(); // done</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>在onAnimation方法中，判断了目标视图是否为空，大家应该还记得上文中，我们对目标视图的查找。如果当前位置不在可见范围之内，那么mTargetView  =null,就不回走对应的判断语句。继续查看onSeekTargetStep()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void onSeekTargetStep(int dx, int dy, RecyclerView.State state, Action action) &#123;</span><br><span class="line">    if (getChildCount() == 0) &#123;</span><br><span class="line">        stop();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //noinspection PointlessBooleanExpression</span><br><span class="line">    if (DEBUG &amp;&amp; mTargetVector != null</span><br><span class="line">            &amp;&amp; ((mTargetVector.x * dx &lt; 0 || mTargetVector.y * dy &lt; 0))) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Scroll happened in the opposite direction&quot;</span><br><span class="line">                + &quot; of the target. Some calculations are wrong&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mInterimTargetDx = clampApplyScroll(mInterimTargetDx, dx);</span><br><span class="line">    mInterimTargetDy = clampApplyScroll(mInterimTargetDy, dy);</span><br><span class="line"></span><br><span class="line">    if (mInterimTargetDx == 0 &amp;&amp; mInterimTargetDy == 0) &#123;</span><br><span class="line">        updateActionForInterimTarget(action);</span><br><span class="line">    &#125; // everything is valid, keep going</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接通过代码，发现并不理解改函数要做什么样的工作，这里我们只知道第一次发生滚动时，mInterimTargetDx=0与mInterimTargetDy =0，那么会走updateActionForInterimTarget（）方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  protected void updateActionForInterimTarget(Action action) &#123;</span><br><span class="line">      // find an interim target position</span><br><span class="line">      PointF scrollVector = computeScrollVectorForPosition(getTargetPosition());</span><br><span class="line">...省略部分代码</span><br><span class="line">      normalize(scrollVector);</span><br><span class="line">      mTargetVector = scrollVector;</span><br><span class="line"></span><br><span class="line">      mInterimTargetDx = (int) (TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector.x);</span><br><span class="line">      mInterimTargetDy = (int) (TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector.y);</span><br><span class="line">      </span><br><span class="line">//计算需要滚动的时间，  默认滚动距离，TARGET_SEEK_SCROLL_DISTANCE_PX = 10000;</span><br><span class="line">      final int time = calculateTimeForScrolling(TARGET_SEEK_SCROLL_DISTANCE_PX);</span><br><span class="line">  </span><br><span class="line">//为了避免在滚动的时候出现停顿，我们会跟踪onSeekTargetStep中的回调距离，实际上不会滚动超出实际的距离</span><br><span class="line">      action.update((int) (mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO),</span><br><span class="line">              (int) (mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO),</span><br><span class="line">              //这里存入的时间要比实际花费的时间大一点。</span><br><span class="line">              (int) (time * TARGET_SEEK_EXTRA_SCROLL_RATIO), mLinearInterpolator);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>根据官方文档进行翻译：当目标滚动位置对应视图不在RecyclerView的可见范围内，该方法计算朝向该视图的方向向量并触发平滑滚动。默认滚动的距离为12000(单位：px)，<strong>（也就是说了为了滚动到目标位置，会让Recycler至多滚动12000个像素）</strong>。</p>
<p>既然该方法计算了时间，那么我们就看看calculateTimeForScrolling()方法，通过方法名我们就应该了解了该方法是计算给定距离在默认速度下需要滚动的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected int calculateTimeForScrolling(int dx) &#123;</span><br><span class="line"> //这里对时间进行了四舍五入操作。 </span><br><span class="line">    return (int) Math.ceil(Math.abs(dx) * MILLISECONDS_PER_PX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中MILLISECONDS_PER_PX 会在LinearSmoothScroller初始化的时候创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public LinearSmoothScroller(Context context) &#123;</span><br><span class="line">    MILLISECONDS_PER_PX = calculateSpeedPerPixel(context.getResources().getDisplayMetrics());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>查看calculateSpeedPerPixel()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final float MILLISECONDS_PER_INCH = 25f;// 默认为移动一英寸需要花费25ms</span><br><span class="line">protected float calculateSpeedPerPixel(DisplayMetrics displayMetrics) &#123;</span><br><span class="line">    return MILLISECONDS_PER_INCH / displayMetrics.densityDpi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，当前滚动的速度是与屏幕的像素密度相关， 通过获取当前手机屏幕每英寸的像素密度，与每英寸移动所需要花费的时间，用每英寸移动所需要花费的时间除以像素密度就能计算出移动一个像素密度需要花费的时间。OK,既然我们已经算出了移动一个像素密度需要花费的时间，那么直接乘以像素，就能算出移动该像素所需要花费的时间了。</p>
<p>既然现在我们算出了时间，我们现在只用关心Action的update()方法到底是干什么的就好了，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//保存关于SmoothScroller滑动距离信息</span><br><span class="line">      public static class Action &#123;</span><br><span class="line">       ...省略代码</span><br><span class="line">        public void update(int dx, int dy, int duration, Interpolator interpolator) &#123;</span><br><span class="line">              mDx = dx;</span><br><span class="line">              mDy = dy;</span><br><span class="line">              mDuration = duration;</span><br><span class="line">              mInterpolator = interpolator;</span><br><span class="line">              mChanged = true;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现Action,只是存储关于SmoothScroller滑动信息的一个类，那么初始时保存了横向与竖直滑动的距离（12000px）、滑动时间，插值器。同时记录当前数据改变的状态。</p>
<p>现在我们已经把Action的onSeekTargetStep方法走完了，那接下来，我们继续看Action的runIfNecessary()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void runIfNecessary(RecyclerView recyclerView) &#123;</span><br><span class="line">        ....省略代码</span><br><span class="line">             if (mChanged) &#123;</span><br><span class="line">                 validate();</span><br><span class="line">                 if (mInterpolator == null) &#123;</span><br><span class="line">                     if (mDuration == UNDEFINED_DURATION) &#123;</span><br><span class="line">                         recyclerView.mViewFlinger.smoothScrollBy(mDx, mDy);</span><br><span class="line">                     &#125; else &#123;</span><br><span class="line">                      //这里传入的mDx,mDy,mDuration.是Action之前update()方法。保存的信息</span><br><span class="line">                         recyclerView.mViewFlinger.smoothScrollBy(mDx, mDy, mDuration);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     recyclerView.mViewFlinger.smoothScrollBy(</span><br><span class="line">                             mDx, mDy, mDuration, mInterpolator);</span><br><span class="line">                 &#125;</span><br><span class="line">           mChanged = false;</span><br><span class="line">             ....省略代码</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>TNND,调来调去最后又把Action存储的信息传给了ViewFlinger的smoothScrollBy()方法。这里需要注意:<strong>一旦调用该方法会将mChanged置为false,下次再次进入该方法时，那么就不会调用ViewFlinger的滑动方法了。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void smoothScrollBy(int dx, int dy, int duration, Interpolator interpolator) &#123;</span><br><span class="line">		 //判断是否是同一插值器，如果不是，重新创建mScroller</span><br><span class="line">           if (mInterpolator != interpolator) &#123;</span><br><span class="line">               mInterpolator = interpolator;</span><br><span class="line">               mScroller = new OverScroller(getContext(), interpolator);</span><br><span class="line">           &#125;</span><br><span class="line">           setScrollState(SCROLL_STATE_SETTLING);</span><br><span class="line">           mLastFlingX = mLastFlingY = 0;</span><br><span class="line">           mScroller.startScroll(0, 0, dx, dy, duration);</span><br><span class="line">           if (Build.VERSION.SDK_INT &lt; 23) &#123;</span><br><span class="line">               mScroller.computeScrollOffset();</span><br><span class="line">           &#125;</span><br><span class="line">           postOnAnimation();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>这里mScroller接受到Acttion传入的滑动信息开始滑动后。最后会调用postOnAnimation()，又将ViewFiinger的run()法发送出去。那么最终我们又回到了ViewFiinger的run()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> public void run() &#123;</span><br><span class="line">      ...省略部分代码</span><br><span class="line">if (scroller.computeScrollOffset()) &#123;</span><br><span class="line">             final int[] scrollConsumed = mScrollConsumed;</span><br><span class="line">             final int x = scroller.getCurrX();</span><br><span class="line">             final int y = scroller.getCurrY();</span><br><span class="line">             int dx = x - mLastFlingX;</span><br><span class="line">             int dy = y - mLastFlingY;</span><br><span class="line">             int hresult = 0;</span><br><span class="line">             int vresult = 0;</span><br><span class="line">             mLastFlingX = x;</span><br><span class="line">             mLastFlingY = y;</span><br><span class="line">             int overscrollX = 0, overscrollY = 0;</span><br><span class="line">       ...省略部分代码</span><br><span class="line">             if (mAdapter != null) &#123;</span><br><span class="line">                 startInterceptRequestLayout();</span><br><span class="line">                 onEnterLayoutOrScroll();</span><br><span class="line">                 TraceCompat.beginSection(TRACE_SCROLL_TAG);</span><br><span class="line">                 fillRemainingScrollValues(mState);</span><br><span class="line">                 if (dx != 0) &#123;//如果横向方向大于0，开始让RecyclerView滚动</span><br><span class="line">                     hresult = mLayout.scrollHorizontallyBy(dx, mRecycler, mState);</span><br><span class="line">                     overscrollX = dx - hresult;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (dy != 0) &#123;//如果竖直方向大于0，开始让RecyclerView滚动，获得当前滚动的距离</span><br><span class="line">                     vresult = mLayout.scrollVerticallyBy(dy, mRecycler, mState);</span><br><span class="line">                     overscrollY = dy - vresult;</span><br><span class="line">                 &#125;</span><br><span class="line">                 TraceCompat.endSection();</span><br><span class="line">                 repositionShadowingViews();</span><br><span class="line"></span><br><span class="line">                 onExitLayoutOrScroll();</span><br><span class="line">                 stopInterceptRequestLayout(false);</span><br><span class="line">                 if (smoothScroller != null &amp;&amp; !smoothScroller.isPendingInitialRun()</span><br><span class="line">                         &amp;&amp; smoothScroller.isRunning()) &#123;</span><br><span class="line">                     final int adapterSize = mState.getItemCount();</span><br><span class="line">                     if (adapterSize == 0) &#123;</span><br><span class="line">                         smoothScroller.stop();</span><br><span class="line">                     &#125; else if (smoothScroller.getTargetPosition() &gt;= adapterSize) &#123;</span><br><span class="line">                         smoothScroller.setTargetPosition(adapterSize - 1);</span><br><span class="line">                         //传入当前RecylerView滚动的距离 dx dy</span><br><span class="line">                         smoothScroller.onAnimation(dx - overscrollX, dy - overscrollY);</span><br><span class="line">                     &#125; else &#123;</span><br><span class="line">                         //传入当前RecylerView滚动的距离 dx dy</span><br><span class="line">                         smoothScroller.onAnimation(dx - overscrollX, dy - overscrollY);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             enableRunOnAnimationRequests();</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里scroller（拿到之前Action传入的滑动距离信息）已经开始滑动了，故 if (scroller.computeScrollOffset()) 条件为true, 那么scroller拿到当前竖直方向的值就开始让RecyclerView滚动了,也就是代码 mLayout.scrollVerticallyBy(dy, mRecycler, mState);接着又让smoothScroller执行onAnimation()方法。其中传入的参数是RecyclerView已经滚动的距离。那我们现在继续看onAnimation方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void onAnimation(int dx, int dy) &#123;</span><br><span class="line">        final RecyclerView recyclerView = mRecyclerView;</span><br><span class="line">        if (!mRunning || mTargetPosition == RecyclerView.NO_POSITION || recyclerView == null) &#123;</span><br><span class="line">            stop();</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingInitialRun = false;</span><br><span class="line">        if (mTargetView != null) &#123;</span><br><span class="line">            // verify target position</span><br><span class="line">            if (getChildPosition(mTargetView) == mTargetPosition) &#123;</span><br><span class="line">                onTargetFound(mTargetView, recyclerView.mState, mRecyclingAction);</span><br><span class="line">                mRecyclingAction.runIfNecessary(recyclerView);</span><br><span class="line">                stop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.e(TAG, &quot;Passed over target position while smooth scrolling.&quot;);</span><br><span class="line">                mTargetView = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mRunning) &#123;//获得当前Recycler需要滚动的距离</span><br><span class="line">            onSeekTargetStep(dx, dy, recyclerView.mState, mRecyclingAction);</span><br><span class="line">            boolean hadJumpTarget = mRecyclingAction.hasJumpTarget();</span><br><span class="line">            mRecyclingAction.runIfNecessary(recyclerView);</span><br><span class="line">            if (hadJumpTarget) &#123;</span><br><span class="line">                // It is not stopped so needs to be restarted</span><br><span class="line">                if (mRunning) &#123;</span><br><span class="line">                    mPendingInitialRun = true;</span><br><span class="line">                    recyclerView.mViewFlinger.postOnAnimation();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    stop(); // done</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么现在代码就明了了，RecylerView会判断在滚动的时候，目标视图是否已经出现，如果没有出现，会调用onSeekTargetStep保存当前RecylerView滚动距离，然后判断RecyclerView是否需要滑动，然后又通过postOnAnimation()将ViewFlinger 发送出去了。那么直到找到目标视图才会停止。</p>
<p>那什么情况下，目标视图不为空呢，其实在RecylerView内部滚动的时候。会判断目标视图是否存在，如果存在会对mTargetView进行赋值操作。由于篇幅限制，这里就不对目标视图的查找进行介绍了，有兴趣的小伙伴可以自己看一下源码。</p>
<p>那接下来，我们就假如当前已经找到了目标视图，那么接下来程序会走onTargetFound()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void onTargetFound(View targetView, RecyclerView.State state, Action action) &#123;</span><br><span class="line">      //计算让目标视图可见的，需要滚动的横向距离</span><br><span class="line">      final int dx = calculateDxToMakeVisible(targetView, getHorizontalSnapPreference());</span><br><span class="line">     //计算让目标视图可见的，需要滚动的横向距离</span><br><span class="line">      final int dy = calculateDyToMakeVisible(targetView, getVerticalSnapPreference());</span><br><span class="line">      final int distance = (int) Math.sqrt(dx * dx + dy * dy);</span><br><span class="line">      final int time = calculateTimeForDeceleration(distance);</span><br><span class="line">      if (time &gt; 0) &#123;</span><br><span class="line">          //更新需要滚动的距离。</span><br><span class="line">          action.update(-dx, -dy, time, mDecelerateInterpolator);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当目标视图被找到以后，会计算让目标视图出现在可见范围内，需要移动的横向与纵向距离。并计算所需要花费的时间。然后重新让RecyclerView滚动一段距离。  </p>
<p>这里我们着重看calculateDyToMakeVisible。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int calculateDyToMakeVisible(View view, int snapPreference) &#123;</span><br><span class="line">    final RecyclerView.LayoutManager layoutManager = getLayoutManager();</span><br><span class="line">    if (layoutManager == null || !layoutManager.canScrollVertically()) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)</span><br><span class="line">            view.getLayoutParams();</span><br><span class="line">    //获取当前view在其父布局的开始位置</span><br><span class="line">    final int top = layoutManager.getDecoratedTop(view) - params.topMargin;</span><br><span class="line">    //获取当前View在其父布局结束位置</span><br><span class="line">    final int bottom = layoutManager.getDecoratedBottom(view) + params.bottomMargin;</span><br><span class="line">    //获取当前布局的开始位置 </span><br><span class="line">    final int start = layoutManager.getPaddingTop();</span><br><span class="line">    //获取当前布局的结束位置</span><br><span class="line">    final int end = layoutManager.getHeight() - layoutManager.getPaddingBottom();</span><br><span class="line">    return calculateDtToFit(top, bottom, start, end, snapPreference);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们会根据当前view的top、bottom及当前布局的start、end等坐标信息，<strong>然后调用了calculateDtToFit（）方法。现在最重要的出现了，也是我们那三个问题出现的原因！！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int calculateDtToFit(int viewStart, int viewEnd, int boxStart, int boxEnd, int</span><br><span class="line">        snapPreference) &#123;</span><br><span class="line">    switch (snapPreference) &#123;</span><br><span class="line">        case SNAP_TO_START:</span><br><span class="line">            return boxStart - viewStart;</span><br><span class="line">        case SNAP_TO_END:</span><br><span class="line">            return boxEnd - viewEnd;</span><br><span class="line">        case SNAP_TO_ANY:</span><br><span class="line">            final int dtStart = boxStart - viewStart;</span><br><span class="line">            if (dtStart &gt; 0) &#123;//滚动位置在可见范围之前</span><br><span class="line">                return dtStart;</span><br><span class="line">            &#125;</span><br><span class="line">            final int dtEnd = boxEnd - viewEnd;</span><br><span class="line">            if (dtEnd &lt; 0) &#123;//滚动位置在可见范围之后</span><br><span class="line">                return dtEnd;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalArgumentException(&quot;snap preference should be one of the&quot;</span><br><span class="line">                    + &quot; constants defined in SmoothScroller, starting with SNAP_&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;//在可见范围之内，直接返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会根据snapPreference对应的值来计算相应的距离，同时snapPreference的具体值与getVerticalSnapPreference（这里我们是竖直方向)所以我们看该方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected int getVerticalSnapPreference() &#123;</span><br><span class="line">       return mTargetVector == null || mTargetVector.y == 0 ? SNAP_TO_ANY :</span><br><span class="line">               mTargetVector.y &gt; 0 ? SNAP_TO_END : SNAP_TO_START;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中mTargetVector与layoutManager.computeScrollVectorForPosition有关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public PointF computeScrollVectorForPosition(int targetPosition) &#123;</span><br><span class="line">      if (getChildCount() == 0) &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      final int firstChildPos = getPosition(getChildAt(0));</span><br><span class="line">      final int direction = targetPosition &lt; firstChildPos != mShouldReverseLayout ? -1 : 1;</span><br><span class="line">      if (mOrientation == HORIZONTAL) &#123;</span><br><span class="line">          return new PointF(direction, 0);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          return new PointF(0, direction);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说在LinerlayoutManager为竖直的情况下，snapPreference默认为SNAP_ANY,那么我们就可以得到，下面三种情况。</p>
<ul>
<li>当滚动位置在可见范围之内时<br>boxStart - viewStart&lt;=0<br>boxEnd - viewEnd&gt;0<br><strong>滚动距离为0，故不会滚动</strong></li>
<li>当滚动位置在可见范围之前时<br>boxStart - viewStart&gt; 0<br><strong>那么实际滚动距离为正值，内容向上滚动，故只能滚动到顶部</strong></li>
<li>当滚动位置在可见范围距离之外时<br>boxEnd - viewEnd&lt;0<br><strong>那么实际滚动距离为其差值，内容向下滚动，故只能滚动到底部</strong></li>
</ul>
<p>有可能大家现在看代码已经看晕了，下面我就用一张图来总结整个流程，结合流程图再去看代码，我相信大家能有更好的理解。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-26280c06b41544a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本流程图.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/RecyclerView-smoothScrollToPosition了解一下/" data-id="cjsheb872000udsr74g5e47v3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RecyclerView滚动位置，滚动速度设置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/RecyclerView滚动位置，滚动速度设置/" class="article-date">
  <time datetime="2019-02-23T11:20:02.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-7ae7631be0e746f0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自行车Boy.jpg"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近开发中遇到了一个需求，需要RecyclerView滚动到指定位置后置顶显示，当时遇到这个问题的时候，心里第一反应是直接使用RecyclerView的smoothScrollToPosition()方法，实现对应位置的平滑滚动。但是在实际使用中发现并没有到底自己想要的效果。本想着偷懒直接从网上Copy下，但是发现效果并不是很好。于是就自己去研究源码。</p>
<p>该系列文章分为两篇文章。</p>
<ul>
<li>如果你想解决通过smoothScrollToPosition滚动到顶部，或者滚动加速，请观看本篇文章，</li>
<li>如果你想了解其内部实现，请看<a href="https://www.jianshu.com/p/a5cd3cff2f1b" target="_blank" rel="noopener">RecyclerView.smoothScrollToPosition了解一下</a></li>
</ul>
<blockquote>
<p>注意！！！注意！！！注意！！！<br>这是使用的LinearLayoutManager且是竖直方向上的，横向的思路是一样的，只是修改的方法不一样，大家一定要注意前提条件。</p>
</blockquote>
<p>###如何使用smoothScrollToPosition滚动到顶部？<br>如果你看了我的另一篇文章<a href="https://www.jianshu.com/p/a5cd3cff2f1b" target="_blank" rel="noopener">RecyclerView.smoothScrollToPosition了解一下</a>,大家应该会清楚，其实在你设定目标位置后，当找到目标视图后，最后让RecyclerView进行滚动的方法是其对应LinearLayoutManager中的LinearSmoothScroller的calculateDtToFit()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int calculateDtToFit(int viewStart, int viewEnd, int boxStart, int boxEnd, int</span><br><span class="line">           snapPreference) &#123;</span><br><span class="line">       switch (snapPreference) &#123;</span><br><span class="line">           case SNAP_TO_START:</span><br><span class="line">               return boxStart - viewStart;</span><br><span class="line">           case SNAP_TO_END:</span><br><span class="line">               return boxEnd - viewEnd;</span><br><span class="line">           case SNAP_TO_ANY:</span><br><span class="line">               final int dtStart = boxStart - viewStart;</span><br><span class="line">               if (dtStart &gt; 0) &#123;</span><br><span class="line">                   return dtStart;</span><br><span class="line">               &#125;</span><br><span class="line">               final int dtEnd = boxEnd - viewEnd;</span><br><span class="line">               if (dtEnd &lt; 0) &#123;</span><br><span class="line">                   return dtEnd;</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">           default:</span><br><span class="line">               throw new IllegalArgumentException(&quot;snap preference should be one of the&quot;</span><br><span class="line">                       + &quot; constants defined in SmoothScroller, starting with SNAP_&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说在LinerlayoutManager为竖直的情况下，snapPreference默认为SNAP_ANY,那么我们就可以得到，下面三种情况。</p>
<ul>
<li>当滚动位置在可见范围之内时<br>滚动距离为0，故不会滚动。</li>
<li>当滚动位置在可见范围之前时<br>内容向上滚动且只能滚动到顶部。</li>
<li>当滚动位置在可见范围距离之外时<br>内容向下滚动，且只能滚动到底部。</li>
</ul>
<p>同时snapPreference的值是通过LinearSmoothScroller中的getVerticalSnapPreference（）与getHorizontalSnapPreference() 来设定的。</p>
<p>所以为了使滚动位置对应的目标视图在顶部显示，那么我们创建一个新类并继承LinearLayoutManager。同时创建TopSnappedSmoothScroller继承LinearSmoothScroller，并重写它的getVerticalSnapPreference（）方法就行了。（如果你是横向的，请修改getHorizontalSnapPreference方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LinearLayoutManagerWithScrollTop extends LinearLayoutManager &#123;</span><br><span class="line"></span><br><span class="line">    public LinearLayoutManagerWithScrollTop(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LinearLayoutManagerWithScrollTop(Context context, int orientation, boolean reverseLayout) &#123;</span><br><span class="line">        super(context, orientation, reverseLayout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LinearLayoutManagerWithScrollTop(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position) &#123;</span><br><span class="line">        TopSnappedSmoothScroller topSnappedSmoothScroller = new TopSnappedSmoothScroller(recyclerView.getContext());</span><br><span class="line">        topSnappedSmoothScroller.setTargetPosition(position);</span><br><span class="line">        startSmoothScroll(topSnappedSmoothScroller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class TopSnappedSmoothScroller extends LinearSmoothScroller &#123;</span><br><span class="line"></span><br><span class="line">        public TopSnappedSmoothScroller(Context context) &#123;</span><br><span class="line">            super(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Nullable</span><br><span class="line">        @Override</span><br><span class="line">        public PointF computeScrollVectorForPosition(int targetPosition) &#123;</span><br><span class="line">            return LinearLayoutManagerWithScrollTop.this.computeScrollVectorForPosition(targetPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected int getVerticalSnapPreference() &#123;</span><br><span class="line">            return SNAP_TO_START;//设置滚动位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建该类后，我们接下来就只用给RecyclerView设置对应的新的布局管理器，并调用smoothScrollToPosition()方法就行了。</p>
<h3 id="如何设置smoothScrollToPosition滚动的速度？"><a href="#如何设置smoothScrollToPosition滚动的速度？" class="headerlink" title="如何设置smoothScrollToPosition滚动的速度？"></a>如何设置smoothScrollToPosition滚动的速度？</h3><p>其实在RecyclerView中，滚动到指定位置是分为了两个部分，第一个是没有找到目标位置对应的视图之前的速度，一种是找到目标位置对应的视图之后滚动的速度。</p>
<h4 id="没有找到目标位置之前"><a href="#没有找到目标位置之前" class="headerlink" title="没有找到目标位置之前"></a>没有找到目标位置之前</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">action.update((int) (mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO),</span><br><span class="line">               (int) (mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO),</span><br><span class="line">               (int) (time * TARGET_SEEK_EXTRA_SCROLL_RATIO), mLinearInterpolator);</span><br></pre></td></tr></table></figure>
<p>在开始寻找目标位置时，默认的开始距离是12000（单位:px),且这里大家注意，我们使用了LinearInterpolator，也就是说在没有找到目标位置之前，我们的RecyclerView速度是恒定的。</p>
<h4 id="找到目标位置之后"><a href="#找到目标位置之后" class="headerlink" title="找到目标位置之后"></a>找到目标位置之后</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action.update(-dx, -dy, time, mDecelerateInterpolator);</span><br></pre></td></tr></table></figure>
<p>这里我们使用了DecelerateInterpolator。也就是说，找到目标位置之后，RecyclerView是速度是慢慢减小。</p>
<p>所以现在就提供了一个思路，我们可以去修改两个部分的插值器，来改变RecyclerView的滚动速度，当然我这里并没有给实例代码，因为我发现Google并没有想让我们去修改插值器的想法，因为在其LinearSmoothScroller中，他直接把两个插值器用protected修饰。（所以我觉得这样改，感觉不优雅）如果有兴趣的小伙伴，可以去修改。</p>
<h4 id="那现在怎么修改速度呢？"><a href="#那现在怎么修改速度呢？" class="headerlink" title="那现在怎么修改速度呢？"></a>那现在怎么修改速度呢？</h4><p>既然以修改插值器的方式比较麻烦，那么我们可以修改滚动时间啊!!!!!!希望大家还记得，我们在调用Action的update方法时，我们不仅保存了RecyclerView需要滚动的距离，我们还保存了滑动总共需要的时间。</p>
<p>滑动所需要的时间是通过calculateTimeForScrolling（）这个方法来进行计算的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected int calculateTimeForScrolling(int dx) &#123;</span><br><span class="line">    //这里对时间进行了四舍五入操作。 </span><br><span class="line">    return (int) Math.ceil(Math.abs(dx) * MILLISECONDS_PER_PX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中MILLISECONDS_PER_PX 会在LinearSmoothScroller初始化的时候创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public LinearSmoothScroller(Context context) &#123;</span><br><span class="line">      MILLISECONDS_PER_PX = calculateSpeedPerPixel(context.getResources().getDisplayMetrics());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>查看calculateSpeedPerPixel()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final float MILLISECONDS_PER_INCH = 25f;// 默认为移动一英寸需要花费25ms</span><br><span class="line">//</span><br><span class="line">protected float calculateSpeedPerPixel(DisplayMetrics displayMetrics) &#123;</span><br><span class="line">    return MILLISECONDS_PER_INCH / displayMetrics.densityDpi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，当前滚动的速度是与屏幕的像素密度相关， 通过获取当前手机屏幕每英寸的像素密度，与每英寸移动所需要花费的时间，用每英寸移动所需要花费的时间除以像素密度就能计算出移动一个像素密度需要花费的时间。</p>
<p>那么现在，就可以通过两个方法来修改RecyclerView的滚动速度，要么我们修改calculateSpeedPerPixel方法修改移动一个像素需要花费的时间。要么我们修改calculateTimeForScrolling方法。</p>
<p>这里我采用修改calculateSpeedPerPixel方法来改变速度。这里我修改移动一英寸需要花费为10ms，那代表着滚动速度加快了。那么对应的滚动时间就变小了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected float calculateSpeedPerPixel(DisplayMetrics displayMetrics) &#123;   </span><br><span class="line">    return 10f / displayMetrics.densityDpi;                                                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了这里我相信大家已经明白了，怎么去修改速度与滚动位置了。好啦好啦，先睡了太困了。</p>
<p>对了对了，<a href="https://github.com/AndyJennifer/RecyclerScrollToPosition" target="_blank" rel="noopener">源码在这里</a>。大家如果有兴趣，可以去研究一下。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后，附上我写的一个基于Kotlin 仿开眼的项目<a href="https://github.com/AndyJennifer/SimpleEyes" target="_blank" rel="noopener">SimpleEyes</a>(ps: 其实在我之前，已经有很多小朋友开始仿这款应用了，但是我觉得要做就做好。所以我的项目和其他的人应该不同，不仅仅是简单的一个应用。但是，但是。但是。重要的话说三遍。还在开发阶段，不要打我)，欢迎大家follow和start.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/RecyclerView滚动位置，滚动速度设置/" data-id="cjsheb86a000gdsr75558b68o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-从ButterKnife-kt-了解Kotlin-委托与扩展" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/从ButterKnife-kt-了解Kotlin-委托与扩展/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="了解了这个，Kotlin协程再也不怕了！"><a href="#了解了这个，Kotlin协程再也不怕了！" class="headerlink" title="了解了这个，Kotlin协程再也不怕了！"></a>了解了这个，Kotlin协程再也不怕了！</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一个使用kotlin的开发者，当我第一次听到协程这个概念的时候，我相信大家和我一样，是一脸懵逼的。但是好奇心又驱使自己去了解。没有办法只有去百度，去Google。结果发现还是一脸懵逼。网上的文章大多数都将kotlin中的协程的概念介绍的很专业，很抽象。所以为了程序员的求知欲（<code>zhuang bi</code>）。呕心沥血，翻江倒海的查阅了很多文章。总结了一下整个从进程，线程到协程的一个过渡历史，以及协程的使用场景与协程的优点。希望这篇文章能帮助到更多使用Kotlin开发，并有心使用Kotlin中协程的小伙伴们。文章总体来说会相对长一点。但是我相信大家阅读完后，会有一种豁然开朗的感觉。</p>
<h3 id="计算机中的进程线程发展历史"><a href="#计算机中的进程线程发展历史" class="headerlink" title="计算机中的进程线程发展历史"></a>计算机中的进程线程发展历史</h3><h4 id="最初的计算机"><a href="#最初的计算机" class="headerlink" title="最初的计算机"></a>最初的计算机</h4><p>最初的计算机的出现，是为了解决数学计算的问题，因为很多大量的计算通过人力去完成，是需要花费大量人力成本与时间成本的。在最初的时候，计算机只能接受一些特定的指令，用户输入一个指令，计算机就做一个操作，当用户在思考或者输入数据时，计算机就在等待，显然这样效率很低下，因为很多时候，计算机处于等待用户输入的状态。</p>
<h4 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h4><p>为了解决最初计算机效率低下的问题，人们想了一种办法，将一系列的操作指令预先存储到计算机中，计算机通过不断的去读取指令来进行相应的逻辑操作，也就是批处理操作系统。人们将需要执行的多个程序指令写入计算机中，然后交由计算机去逐个执行程序指令。</p>
<h4 id="进程的诞生"><a href="#进程的诞生" class="headerlink" title="进程的诞生"></a>进程的诞生</h4><p>虽然批处理操作系统的诞生极大的调高了任务处理的便捷性，但是任然存在一个很大的问题。对于两个程序A和B，因为整个计算设计的是并行操作的。那么当程序A执行时，如果A需要大量的数据输入，那么此时CPU只能等待程序A执行输入操作后才能继续执行。于是人们就思考，是否可以在程序A在等待输入的时候，让程序B先去执行，当程序A读取完之后，让程序B暂停，接着重新让程序A执行呢？</p>
<p>但是这样就会有个问题，在初代计算机中都是一个程序在计算机里面运行，也就是说内存中始终只有一个程序的运行数据，而如果想要程序A执行I/O操作的时候，让任务B去执行，必然内存中要装入多个程序。多个程序使用的数据需要如何区分？并且当一个程序运行暂停后，如何恢复到它之前执行的状态呢？</p>
<p>这个时候聪明的人们就发明了进程这个概念，用进程来表示每一个程序，每个进程对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程空间互不干扰。同时每个进程也保存了程序每个时刻的运行状态。这样就为程序间的切换提供了可能性。那么现在，当某个进程暂停时，操作系统会保存当前进程的状态（比如进程标识、进程的使用的资源等），在下一次重新切换回来时，便根据之前保存的状态进行恢复，然后继续执行。</p>
<p>进程的出现，让操作系统宏观上看起来同一时间段可以执行多个程序，同时也提高了资源的利用率与系统的吞吐量。</p>
<h4 id="线程的出现"><a href="#线程的出现" class="headerlink" title="线程的出现"></a>线程的出现</h4><p>在60年代，进程的出现确实提高了计算机的运行效率，在OS中能拥有资源和独立运行的基本单位是进程，但是随着人们对计算机的需求增大与计算机技术的发展。单单使用进程来处理程序的并发的弊端越来越明显。</p>
<ul>
<li>1、进程是资源的拥有者，在创建、撤销、切换操作中需要较大的时空开销，限制了并发程度的进一步提高。需要引入轻型进程。</li>
<li>2、由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。</li>
</ul>
<blockquote>
<p>SMP的全称是”对称多处理”（Symmetrical Multi-Processing）技术，是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。</p>
</blockquote>
<p>这里有可能有小伙伴对并发与并行的概念不是很清楚，所以这里额外对并发与并行在操作系统中的概念进行介绍：</p>
<blockquote>
<p><strong>并发</strong>：当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(Concurrent)。<br><strong>并行</strong>：当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。</p>
</blockquote>
<p>所以，为了减少进程切换的开销。与提高单个程序执行多个任务的能力，在80年代，聪明的人儿们又进一步的发明了<code>线程</code>，通过CPU不断的切换时间片来切换不同的线程（线程的切换开销小于进程的开销），以此来提高程序的并发能力。</p>
<p>###高并发<br>80年代随着因特网（Internet）的盛起，计算机与计算机之间可以通信了。我们将总是提供数据的一方称为服务器，总是请求数据的一方称为客户端，那么我们可以得到如下模型。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-26eb93f49ed1b014.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="c/s模型.png"></p>
<blockquote>
<p>因特网（Internet）以相互交流信息资源为目的，基于一些共同的协议，并通过许多路由器和公共互联网而成，它是一个信息资源和资源共享的集合。</p>
</blockquote>
<p>现实生活中，一个服务器不可能单单处理一个客户端的请求，可能服务器会处理成百上千个请求。甚至上万上千万的请求。所以在传统的客户端与服务器通信模式下，我们可以得到如下模型：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-8c7aec4a3563fdcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多线程模型.png"></p>
<p>在上述模型中，会将每个客户端与服务器的连接建立一个线程。用户对资源数据的请求/读写，都是通过线程操作的。但是此模型会有一个问题，就是随着客户端与服务器建立的连接数，越来越多，那么服务器就会创建更多的线程来响应客户端的请求。而线程的创建是会有时空成本的（时空：时间、空间），CPU切换线程的时候也会花费很多的时间。因此我们不可能有多少客户端建立连接就创建多少个响应的线程。</p>
<p>所以为了减少线程的启动时间，减少线程的切换。我们可以采用线程池，预先启动一些线程。也就出现了下面的这种模型：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-acdf22f637cce60a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程池模型.png"></p>
<p>但是这种模型任然会有些问题。我们都知道在线程池中的活跃线程数目是有限制的。当请求数超过活跃数线程，那么剩余的请求任务就会在等待队列中等待。直到有其他的请求执行完成后，才能进行相应的操作。如果此时其他客户端的请求恰好是耗时的读写操作。那么在整个请求过程中。剩余请求任务等待服务器操作的时间远大于服务器处理数据的时间。</p>
<h3 id="传统io模型"><a href="#传统io模型" class="headerlink" title="传统io模型"></a>传统io模型</h3><h5 id="事件驱动与I0多复用"><a href="#事件驱动与I0多复用" class="headerlink" title="事件驱动与I0多复用"></a>事件驱动与I0多复用</h5><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>并发？并行？线程？</p>
<h4 id="Java中的线程实现"><a href="#Java中的线程实现" class="headerlink" title="Java中的线程实现"></a>Java中的线程实现</h4><h4 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h4><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/31410589" target="_blank" rel="noopener">事件驱动与协程：基本概念介绍</a><br><a href="https://www.jianshu.com/p/e38ee24dd004" target="_blank" rel="noopener">深入理解事件驱动与协程概念</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&amp;mid=2247483907&amp;idx=1&amp;sn=3d5e1384a36bd59f5fd14135067af1c2&amp;chksm=fb0be897cc7c61815a6a1c3181f3ba3507b199fd7a8c9025e9d8f67b5e9783bc0f0fe1c73903&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">NIO相关基础篇</a><br><a href="https://m.sohu.com/a/237171690_465221/?pvid=000115_3w_a" target="_blank" rel="noopener">漫画：什么是协程？</a><br><a href="https://www.cnblogs.com/wjlstation/p/8972895.html" target="_blank" rel="noopener">Netty原理解析</a><br><a href="https://www.cnblogs.com/ynuo/p/5600882.html" target="_blank" rel="noopener">java线程与进程的由来</a><br>《深入理解JVM虚拟机 JVM高级特性与实践》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/从ButterKnife-kt-了解Kotlin-委托与扩展/" data-id="cjsheb86b000hdsr7v1z8u68d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Gradle系列-引导篇（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Gradle系列-引导篇（一）/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-6fb4a4059228244a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle.png"></p>
<blockquote>
<p>题外话：其实本来不想取这个名字的，但是感觉不取这个名字感觉没有几个人看啊。大家肯定觉得这个名字比较高大上吧！哈哈哈哈。好了，收。</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在平时Android开发中我们常常使用Gradle来构建我们的项目，我相信大家都可能遇到以下问题：</p>
<ul>
<li>开启项目提示界面一直显示Gradle Build Running </li>
<li>Gradle传递性依赖冲突</li>
<li>多渠道打包</li>
<li>…..等</li>
</ul>
<p>相信大家在平时使用的时候，遇到问题都通过搜索引擎来解决，有些小伙伴可定会想,”<code>作为一个Android开发者，我没有必要去详细的了解Gradle到底去这么使用，平时开发任务本来就比较重，哪里有时间有精力来学习呢</code>“ 但是个人觉得对Gradle的了解，对于我们平时开发项目有很重要的帮助。</p>
<h3 id="Java项目的构建"><a href="#Java项目的构建" class="headerlink" title="Java项目的构建"></a>Java项目的构建</h3><p>要知道Gradle是什么以及其作用。我们需要从整个Java项目的构建说起，看下图：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-3f62357c67fc183d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle-java-builds.png"></p>
<p>从上图中我们可以看出在平时Java项目的构建流程，或多或少我们会涉及以下操作：</p>
<ul>
<li>通过<code>javac</code>命令将一些Java源文件编译为class文件。</li>
<li>将类文件和资源文件（图像和字符串的资源）压缩为Jar包。</li>
<li>通过<code>javadoc</code>命令提取Java源文件的中的注释。生成文档。</li>
<li>运行一些单元测试，或程序验收测试。</li>
<li>将Jar文件部署到资源库中。</li>
</ul>
<p>既然Java项目的构建会经历以上或更多的步骤，那么我们接下来看看Android项目的构建流程。</p>
<h3 id="Android项目的构建"><a href="#Android项目的构建" class="headerlink" title="Android项目的构建"></a>Android项目的构建</h3><p>对于Android项目的构建，主要会经历和解决下面这些问题：</p>
<ul>
<li>Android对于Java源文件<code>并未按照标准Java字节码编译</code>，但可为Android运行时自定义字节码。</li>
<li>Android具有三种资源类型（R.java、Application source code、JavaInterfaces)，且按照不同的方式打包。</li>
<li>还有一个难题就是你定义的资源需要与所包括的资源库中的资源进行汇集，在编译其他任何程序之前，需要知道所有这些资源的识别符。</li>
<li>Android应用多数情况下会对应用进行加密。</li>
</ul>
<p>那么汇集所有的资源以及情况后，整个Android的构建流程看起来是这个样子：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-eb33e56f256fe391.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android构建流程图.png"></p>
<p>为了方便大家理解这里对其中主要的构建过程进行描述(<code>上图中绿色椭圆部分</code>)：</p>
<ul>
<li>aapt：aapt(Android Asset Packaging Tool)工具会打包应用中的资源文件，如AndroidManifest.xml、layout布局中的xml等，并将xml文件编译为二进制形式，当然assets文件夹中的文件不会被编译，图片及raw文件夹中的资源也会保持原来的形态，(<code>需要注意的是raw文件夹中的资源也会生成资源id。AAPT编译完成之后会生成R.java文件</code>)。</li>
<li>aidl：AIDL工具会将所有的aidl接口转化为java接口。</li>
<li>Java Compiler(Java编译器)：当AAPT与AIDL工具将需要处理的数据处理好后，Java 编译器会将所有的java代码，包括R.java与aidl文件编译成<code>.class文件</code>。</li>
<li>dex：dex工具会将上述产生的.class文件及第三库及其他.class文件编译成<code>.dex文件</code>（dex文件是Dalvik虚拟机可以执行的格式），dex文件最终会被打包进APK文件。</li>
<li>apkbuilder：apkbuilder工具会将编译过的资源及未编译过的资源（如图片等）以及.dex文件打包成APK文件。</li>
<li>Jarsingner：生成APK文件后，需要对其签名才可安装到设备，平时测试时会使用debug keystore，当正式发布应用时必须使用release版的keystore对应用进行签名。Jarsigner工具会根据相应的keystore生成相应的签名APK文件。</li>
<li>zipalign(release mode)：zipalign工具，它能够对打包的应用程序进行优化。在你的应用程序上运行zipalign，使得在运行时Android与应用程序间的交互更加有效率。</li>
</ul>
<blockquote>
<p>在Android中，每个应用程序中储存的数据文件都会被多个进程访问：安装程序会读取应用程序的manifest文件来处理与之相关的权限问题；Home应用程序会读取资源文件来获取应用程序的名和图标；系统服务会因为很多种原因读取资源（例如，显示应用程序的Notification）。此外，就是应用程序自身用到的资源文件。<br>在Android中，当资源文件通过内存映射对齐到4字节边界时，访问资源文件的代码才是有效率的。但是，如果资源本身没有进行对齐处理（未使用zipalign工具），它就必须回到老路上，显式地读取它们——这个过程将会比较缓慢且会花费额外的内存。</p>
</blockquote>
<p>从整个Android项目的构建来看，我们会感叹“为啥我就简单的创建一个应用，为毛有非常多的事情需要做。”，所以为了方便处理这些，我们都会想是不是可以写一个能自动处理这些过程的程序化脚本呢？<code>所以Gradle出现了！！！！</code>。</p>
<h3 id="为毛选择Gradle？"><a href="#为毛选择Gradle？" class="headerlink" title="为毛选择Gradle？"></a>为毛选择Gradle？</h3><p>对于以前传统的项目构建工具，只是编译和打包源代码。而现在项目的构建需要负责更多的工作，它们会运行测试、从多个来源购买编码资源、生成文档、创建多个构建变种、发布应用程序和管理依赖性。而Gradle不仅具备这些能力与功能，还解决了Android开发人员面临的一些最棘手的问题，如下所示：</p>
<ul>
<li>如何自动构建和测试应用，以快速实现生产力？</li>
<li>如何管理依赖和变种。使专业开发人员只需要单击一次就能提取出其应用的数十个变种？</li>
<li>如何构建处理及处理非常大的应用？</li>
<li>…</li>
</ul>
<p>哎呀说这么多，<code>其实最大的原因是Google爸爸已经选择Gradle做为Android Studio的构建系统</code>，在Android Studio中将Android应用的整个流程指派给了Gradle。当我们点击<code>运行</code>按钮时，Android studio会在运行过程中设置Gradle，并在后台监控。通过学习有关Gradle知识。我们可以扩展此默认行为。以构建能力更强且经过适当测试的应用。</p>
<p><code>既然Gradle大法这么好，为毛我们不去学习呢？</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Gradle是项目的构建工具，解决了我们平时开发中，项目测试、项目打包、项目依赖等问题。</p>
<p>###最后<br>Gradle系列会继续写。如果大家喜欢我的写作风格的话。欢迎大家点赞。</p>
<p>最后，附上我写的一个基于Kotlin 仿开眼的项目<a href="https://github.com/AndyJennifer/SimpleEyes" target="_blank" rel="noopener">SimpleEyes</a>(ps: 其实在我之前，已经有很多小朋友开始仿这款应用了，但是我觉得要做就做好。所以我的项目和其他的人应该不同，不仅仅是简单的一个应用。但是，但是。但是。重要的话说三遍。还在开发阶段，不要打我)，欢迎大家follow和start</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Gradle系列-引导篇（一）/" data-id="cjsheb85j0003dsr7yzlvzgnt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-哈希表初识(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/哈希表初识(一)/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-01e4b20ee6720064.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="死侍.jpg"></p>
<blockquote>
<p>写这篇文章的时候，是大年三十，本来应该和家人一起看春节联欢晚会的，但是看了一个小时感觉没有什么劲，我想今年春晚又会被<strong>吐槽</strong>吧。哈哈哈哈。书归正传，还是按照我们的老规矩,走起。（PS:本来是早就应该写完的文章，发现自己还是太懒。到了现在真正的写完。反省反省….）</p>
</blockquote>
<p>在写这篇文章之前，看了很多关于HashMap解析的文章。对于大多数人来说，可了跟着别人的文章走一遍。大家都能了解HashMap的内部结构，使用方法以及注意事项。我还是觉得知道用是一回事。知道原理是另一回事。只有了解了其数据结构设计初衷。才能更好的使用它。<br> 此系列文章主要分为两个部分，具体目录如下：</p>
<ul>
<li>哈希表初识(一)</li>
<li>哈希表之 HashMap(二)</li>
</ul>
<p>其中第一篇是带领着大家理解为什么会设计此种数据结构，及其遇见的问题及解决办法。我相信通过阅读这篇文章后，你再去理解HashMap，我相信你会有一种豁然开朗的感觉。建议先阅读第一部分。</p>
<p>###前言<br>哈希表是我们程序员开发者经常会使用到的数据结构。我们都知道是其主要用于<strong>映射（键值对</strong>）关系的数据。哈希表<strong>在查找、删除、添加数据方面效率都比较高</strong>。既然哈希表有如此多的优点，那么我就带着大家从哈希表实际应用例子出发，通过相应例子，带领大家彻底的了解哈希表的使用情景及其遇到的问题，以及相应的解决方法。</p>
<p>###哈希表简介</p>
<blockquote>
<p>哈希表（Hash table，也叫散列表），是根据关键值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键键值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做哈希函数，存放记录的数组叫做哈希表。</p>
</blockquote>
<p>上文提到了两个比较重要的知识点。<strong>哈希表是基于数组且通过哈希函数来构建映射关系</strong>。接下来我们通过生活中的几个例子，来了解一下哈希表在实际使用中会出现的问题以及解决方案。</p>
<p>####学号作为键，存储学生信息<br>假如现在我们要做一个学校的学生信息记录。这个学校大概有1000人。学生的记录信息包括学号、年龄、性别等信息。假设学生的学号是从零开始的有序自增长，那么如果要求我们需要从快速检索某一个学生的信息。那我们应该使用什么样的数据结构呢？</p>
<p>我们可能首先想到的就是数组。即数组下标对应着相应学生信息，具体数据结构如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-5b39808f6cbe991f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="学生存储数组.png"></p>
<p>如果我们需要找到Jennifer这个学生。我们只需要通过数组下标拿到相应信息就行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student andy = StudentArray[2];</span><br></pre></td></tr></table></figure></p>
<p>如果我们需要增加一个Jack学生，我们只需要在数组的末尾添加新添加的学生信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StudentArray[storeNumber++] = new Student(&quot;Jack&quot;);</span><br></pre></td></tr></table></figure></p>
<p>我们发现通过上述结构设计，我们能很快的找到某个学生，或者删除一个学生，因为学生的信息是与学号进行关联的。同时每个学生的学号与数组的下标是相对应的。通过数组下标的操作。我们就能完成我们想要的数据操作。当然上述情况只是<strong>理想的数据情况</strong>，我们可以直接通过将学号作为数组的下标来作为键值对的映射关系。实际开发常见中，我们并不能遇到如此良好的数据映射关系的。</p>
<p>####字典作为键，查找英语单词<br>上文描述了理想情况下的数据映射关系，下面我们来看看<strong>“不良好”</strong>的数据关系。</p>
<p>假如，我们希望在我们的程序中存储100000个单词，如果我们考虑每个单词都占据一个数组单元，那么我们就需要创建一个容量为100000的数组，通过上述步骤，我们能快速的对单词进行存储。但是数组下标与单词有什么关系呢？我们如何能快速的找到某个单词的位置呢？</p>
<h5 id="把单词转换为数组下标"><a href="#把单词转换为数组下标" class="headerlink" title="把单词转换为数组下标"></a>把单词转换为数组下标</h5><p>因为数组中的数组单元与单词是没有关系的。为了达到映射关系，我们可以通过<strong>ASCII的编码思想</strong>来解决相应的问题，我们都知道ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。其中ASCII包含了所有的所有的大写和小写字母，数字0 到9、标点符号。其中小写英文字母的对应的十进制范围是97-122。<strong>那么我们可以采用简单的编码方式， 从字母a到z进行依次从1递增进行编码。</strong></p>
<p>例如单词 <strong>abandon</strong><br>其中<br><strong>a  = 1</strong><br><strong>b = 2</strong><br><strong>a = 1</strong><br><strong>n = 14</strong><br><strong>d = 4</strong><br><strong>o = 15</strong><br><strong>n = 14</strong></p>
<p>求和 <strong>1+2+1+14+4+15+14 = 51</strong></p>
<p>那么我们可以将<strong>abandon</strong>放入下标为51的数组中。</p>
<p>这样就能直接通过words数组下标进行访问了，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stirng words = words[51];</span><br></pre></td></tr></table></figure></p>
<p>但是通过这种方式来存储单词，会出现一个问题。假如我们规定单词的最大长度为10，那么对应的单词求的和就有260种可能，而我们总共的单词有100000个，那么每个数组单元要存储大约380个单词（10000除以260），那么我们可以考虑的是数组单元使用子数组或者链表的方式来存储数据，但是每个数组单元有380个单词，在对数据进行操作的时候，效率是不是很低下呢？所以我们能不能想一个办法。让每个数组单元的存储数据个数尽量减小。让数组单元存储的数据尽量分散呢？</p>
<h5 id="幂操作"><a href="#幂操作" class="headerlink" title="幂操作"></a>幂操作</h5><p>因为直接使用简单编码进行相加的方式会导致产生的数组下标较小（数据比较集中），数组单元个数太多的情况，所以我们采用幂的方式。<br>还是使用单词<strong>abandon</strong><br>其中<br> <strong>a = 10^0+1</strong><br><strong>b = 10^1+2</strong><br><strong>a= 10^2+1</strong><br> <strong>n= 10^3+14</strong><br> <strong>d = 10^4+4</strong><br> <strong>o = 10^5+15</strong><br> <strong>n = 10^6+14</strong></p>
<p>求和 <strong>1+12+101+1014+10004+100015+1000014 =1111161</strong><br>那我们是不是就可以直接将<strong>abandon</strong>放入下标为1111161的数组中？</p>
<p>不要忘了我们的单词的最大长度是10。那么我们数组中的最大下标为:<br><strong>10^0 + 10^1 +10^2 +10^3 +10^4 +10^5 +10^6 +10^7 +10^8 +10^9</strong><br>算都不用算，我们知道这是很大的数，我们不可能申请这么大容量的数组。</p>
<p>通过以上分析，我们如果如果采用第一种方案的话，产生数组的下标比较少（数据比较集中），如果使用第二种方案产生的数组下标会更多（数据比较分散），且申请了不必要的空间。那么为了将第二种方案的下标范围进行压缩，那么我们该使用什么样的解决方法呢？继续往下看。</p>
<p>###哈希函数</p>
<blockquote>
<p><strong>通过一种算法将一个大范围的数字转化一个小范围的数字，这个算法对应的函数称为哈希函数</strong></p>
</blockquote>
<p>如何将一个大范围的数字区间转换成一个小范围的数字区间，我们常用的方式是取余（也叫取模操作）。</p>
<p>我们都知道对于给定任意一个整数p,任意一个整数n,一定存在不等式：<br><strong>n= kp+r</strong><br>其中k、r是整数，且r大于等于0小于p ,r为n除以p的余数。</p>
<p>既然我们已经知道了一个数（n)在除以另一个数(p)是余数的取值范围(大于0且小于p减去1)。<br>那么我们把一个范围是0~199(bigerRange)的数据压缩到0~9(smallerRange)的范围。我们可以进行如下操作：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-fca74c109c89881f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缩小范围.png"></p>
<p>对应的伪代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">smallerRange = bigerRange % 10;</span><br><span class="line">arrayIndex = smallerRange;//arrayIndex 代表哈希化操作后，数据对应的数组下标</span><br></pre></td></tr></table></figure></p>
<p>同理对应我们上述提到的单词存储，我们也可以进行如下操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smallerRange = bigerRange % arraySize;</span><br></pre></td></tr></table></figure></p>
<p>###冲突<br>经过取余操作后，我们现在已经将单词从一个较大的范围压缩到了一个小的范围，但是细心的读者肯定会发现。假如通过这种方式进行单词的存储，<strong>假如某个单词和另一个单词进行幂操作后，进行取余的值是相同的，那么就会出现冲突的问题。也就是同一数组下标中存储了两份不同的数据。</strong> 列如上图中，数组中words[196]与words[6]。</p>
<p>既然出现了冲突的问题，一般我们会采用两种方式，第一种方式是找到数组的一个空位，并把这个单词填入，第二种方法创建一个存储链表的数组，数组内部不存储单词，产生的冲突的数据直接添加到这个数组下标所对应的链表的下一个节点。这两种方法分别对应着我们下文要讲的<strong>开发地址法</strong>与<strong>链地址法</strong>。</p>
<p>###开放地址法<br>当数据不能直接放入由哈希函数计算出来的下标对应相应的数组单元，我们需要获取数组中的其他的位置。根据获取新位置的计算方式的不同，开发地址法分为了三种方法。<strong>线性探测</strong>、<strong>二次探测</strong>、<strong>再哈希化</strong>。下面我们就来具体来讲讲这三种方式的分别实现以及一些问题。</p>
<p>####线性探测<br>线性探测是在产生冲突时，我们就顺势下推，寻找数组中空白的地址。列如，当前我们需要存储单词<strong>abandon</strong>,但是当前0下标对应的数组单元已经存储了数据(a)。那么我们就尝试使用1标，如果1下标对应的数组单元也同样存储了数据(apple)，那么我们继续判断数组下标2。这样通过依次递增的方式去寻找能够进行存储的数据单元。具体实现如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-162b29946bbe5413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性探测.png"></p>
<p>对应添加元素伪代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void insert(int key ,Word word)&#123;</span><br><span class="line">	int hashVal = hashMethod(key);//通过hash函数计算得到对应的数组下标</span><br><span class="line">	while(words[hashVal]!=null)&#123;</span><br><span class="line">		++hashVal;//对角标进行递增</span><br><span class="line">		hashVal %=words.size();</span><br><span class="line">	&#125;</span><br><span class="line">	words[hashVal]=word;//找到空数据单元，进行赋值操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####线性探测聚集问题<br>但是聪明的你，肯定会发现一个问题，就是当我我们的数据越插入的越来越多的时候，哈希表会变得越来越臃肿，这导致我们在插入新的元素的时候，会探测很长一段距离。当数组填的越满时，聚集就越可能发生。具体问题如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-2cc0af3047916351.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="聚集问题.png"></p>
<p>对应添加元素伪代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void insert(int key ,Word word)&#123;</span><br><span class="line">	int hashVal = hashMethod(key);//通过hash函数计算得到对应的数组下标</span><br><span class="line">	int step=0;</span><br><span class="line">	while(words[hashVal]!=null)&#123;</span><br><span class="line">		step = Math.pow(step,2);//获取步长</span><br><span class="line">		hashVal+=step;</span><br><span class="line">		hashVal %=words.size();</span><br><span class="line">		step++;</span><br><span class="line">	&#125;</span><br><span class="line">	words[hashVal]=word;//找到空数据单元，进行赋值操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上图来看，如果我们与数组0(a)产生冲突的时候，我们需要线性的向下寻找空白单元。当我们的数组数据存储比例（当前数组存储数据与数组容量的比例，也可以叫做<strong>装填因子</strong>）较高时。那么我们查询空白单元。所耗的时间也比较长。（这里先不讨论<strong>数组扩容</strong>的问题，下面我们才讨论扩容。）</p>
<p>####二次探测<br>上面我们讨论了，在使用线性探测时会出现聚集的问题，当数据量大时，查询空白数据单元的次数也会相应的增加。为了减少这种聚集的问题，我们可以采用二次探测。二次探测的原理就是尽量探测相对较远的数据单元，而不探测相邻的数据单元。</p>
<p>在线性探测中，如果通过计算获得的数组下标为<strong>x</strong>，则对应的线性探测步长就是<strong>x+1</strong>,<strong>x+2</strong>,<strong>x+3</strong>,那么在二次探测中，探测的步长为:<strong>x+1^2</strong>,<strong>x+2^2</strong>,<strong>x+3^2</strong>,也就是<strong>x+1</strong>,<strong>x+4</strong>,<strong>x+9</strong>。具体实现如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-088df76f5327b4d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二次探测.png"></p>
<h5 id="二次探测聚集问题"><a href="#二次探测聚集问题" class="headerlink" title="二次探测聚集问题"></a>二次探测聚集问题</h5><p>二次探测虽然消除了线性探测中产生的聚集问题，但是又出现了更细的聚集问题，出现这种更细的聚集问题是因为多个数据经过计算后，获得相同的数组下标，在探测空的数据单元的时候，所寻找的数据单元是相同的。<br>如现在我们需要将a,apple,abandon,access等4个单词插入哈希表中，假如它们计算后的数组下标都是一样的。那么假如已经插入a单词，那么当apple插入时（假设查询步长为1后，直接插入成功），所走的步长为1，abandon会先走1的步长，然后再走4的步长（假设走了4的步长后，直接插入成功），那么当access进行插入的时候，它会判断1,4对应步长下，是否可以插入数据，很明显当abandon与access进行插入的时候，他们都判断了1步长对应的数据。</p>
<p>####再哈希化<br>为了解决线性探测与二次探测带来的聚集问题。我们还可以使用再哈希法，从上文我们已经了解了，二次探测出现聚集问题的原因是因为所探测的步长是固定的。解决这个问题的最好办法就是是步长是变化的就行了。那么我们就可以另一哈希函数（用另一哈希函数的原因是，我们要限定始终在数组范围内进行查询）根据关键字(key),来动态的计算步长就行了。</p>
<p>注意：</p>
<ul>
<li>新的哈希函数必须与上一个哈希函数不同（相同，不是写了当没写吗？我直接乘以2就完了，对不对）</li>
<li>不能输出0（步长为0，我们还添加个毛线啊）。</li>
</ul>
<p>那么修改我们上面的伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void insert(int key ,Word word)&#123;</span><br><span class="line">	int hashVal = hashMethod(key);//通过hash函数计算得到对应的数组下标</span><br><span class="line">	int step= hashStep(key);</span><br><span class="line">	while(words[hashVal]!=null)&#123;</span><br><span class="line">		hashVal+=step;</span><br><span class="line">		hashVal %=words.size();</span><br><span class="line">	&#125;</span><br><span class="line">	words[hashVal]=word;//找到空数据单元，进行赋值操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//牛逼的计算步长的方法，其中constant是质数 且小于数组容量, 那么步长的范围为大于等于0小于等constant</span><br><span class="line">public int hashStep(Key key)&#123;</span><br><span class="line">	return constant -(key%constant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：这里又有同学要问了，为什么要使用质数，我们都知道质数在在大于1的自然数中，除了1和它本身以外不再有其他因数。试想，如果当前我们的数组长度为10，通过哈希计算后的数组下标是0，且我们计算后的步长为5，那么探测序列就是，0,5,10,0,5,10。程序会一直探测直到崩溃。</p>
<p>###链地址法<br>上面我们介绍了开放地址法，它们共同点是在数组中寻找空的数据单元进行新的数据插入，而链地址法是在每个数据单元中设置链表，当发生冲突时，直接将新的数据添加到链表中。具体实现如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-dd23932fde3e4d5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="链地址法.png"></p>
<p>因为链地址法是基于链表的，它是不需要进行探测序列的。因为我们可以直接将元素放在对应末尾。</p>
<h3 id="扩展数组"><a href="#扩展数组" class="headerlink" title="扩展数组"></a>扩展数组</h3><p>上面我们讨论了，开放地址法与链地址法。试想一种情况，当我们的数组快满时，增删查数据会变得很慢（因为要去探测空的数据单元），这个时候我们就需要对数组进行扩展，扩展的时机是什么呢？</p>
<p>还记得我们上文提到的<strong>装填因子（当前数组存储数据与数组容量的比例）</strong>，我们不可能等到数组快满时，才进行扩展操作，因为会影响效率。所以我们一般情况下会在装填因子大于或等于0.75的情况下进行数组的扩展（装填因子太小，扩展频率太快，装填因子太大，影响数据操作效率）。</p>
<p>注意：</p>
<ul>
<li><strong>在Java中，数组有固定的大小，不能进行扩展。只能创建一个更大容量的数组，将原来的数组放入较大容量数组中去。</strong></li>
<li><strong>我们不能直接将数组的元素直接复制到新的数组中去，也就是数据不能再新数组和老数组在相同的位置上。我们需要重新将元素添加进去，根据相应的哈希函数重新去计算在新的数组中数据所在的位置。</strong></li>
</ul>
<p>这里肯定有很多同学要问，我为啥不能复制到相同的位置上呢？如果你还记得，数据的位置我们是通过哈希函数来计算的，也就是我们对数组长度进行取余操。假如在新数组中我们需要对某个数据进行查找的时候。因为不是不同的数组长度。那么计算的位置肯定不同。我们就会找不到它，但是它又确实在数组中存在。所以就会造成数据混乱的情况。</p>
<blockquote>
<p>在写这篇文章之前，看了很多关于HashMap解析的文章。对于大多数人来说，可了跟着别人的文章走一遍。大家都能了解HashMap的内部结构，使用方法以及注意事项。我还是觉得知道用是一回事。知道原理是另一回事。只有了解了其数据结构设计初衷。才能更好的使用它。此系列文章主要分为两个部分，具体目录如下：</p>
</blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/345019b77571" target="_blank" rel="noopener">哈希表初识(一)</a></li>
<li>哈希表之HashMap(二)</li>
</ul>
<p>提示：该篇文章作为彻底理解哈希表的第二个部分。主要讲了HashMap在Java中基于JDK1.8(不同版本HashMap可能实现不同)的具体实现。如果你对哈希表还不算太熟，建议先阅读上一篇文章，我相信等你看完之后，在回来看这篇文章，会有一种<strong>飞翔的感觉</strong>。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Java中java.util包下，定义了Map接口来实现键值对的映射关系。常用的类为HashMap,LinkedHashMap,TreeMap。其主要的类关系如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-23a8b487bb761aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Map类关系图.png"></p>
<p>在平时项目的开发中，我们主要使用的是HashMap及其子类，那我们接下来就了解一下HashMap的主要特征。</p>
<ul>
<li>采用数组+链表的形式对数据进行存储。</li>
<li>根据hashCode值存储数据，访问速度较快。</li>
<li>有且只有一个key为null的数组。</li>
<li>遍历是无序的。</li>
<li>线程非安全。</li>
</ul>
<h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><p>既然上文提到了数组+链表的形式，大家是否想起我们上篇文章提到的<strong>链地址法</strong>呢？如果你忘记了链地址法的具体实现，没关系，让我们一起看看在Java中HashMap具体的内部结构,具体的结构如下图所示：(注意:<strong>在JDK1.8中如果链表的长度大于8时会将该链表转换为红黑树</strong>)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-2f97667065cd94e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内部结构.png"></p>
<p>从图中看出，HashMap底层存储的是<strong>Node</strong>节点，本质是一个映射（键值对）。上图中，每个<strong>黑色圆点</strong>就是一个<strong>Node</strong>对象。<strong>数组table</strong>对应Node&lt;K,V&gt;[] table。</p>
<p>查看Node对应源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       final int hash;</span><br><span class="line">       final K key;</span><br><span class="line">       V value;</span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       Node(int hash, K key, V value, HashMapEntry&lt;K,V&gt; next) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">       public final K getKey()       &#123;...&#125;</span><br><span class="line">       public final V getValue()      &#123;...&#125;</span><br><span class="line">       public final String toString() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">       public final int hashCode()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">       public final V setValue(V newValue) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">       public final boolean equals(Object o) &#123;...&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从代码中我们可以看出，<strong>Node</strong>是HashMap的一个内部类，实现了Map.Entry接口。该类中保存了当前存储数据的hash值，关键字、和当前存储数据、及下一个Node节点的引用。既然我们已经知道了HashMap到底存储的是什么东西，那么我们继续看看HashMap的初始化。</p>
<p>###HashMap初始化</p>
<p>在我们初始化HashMap实例对象的时候，我们默认调用是其参数为空的构造函数，查看具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public HashMap() &#123;</span><br><span class="line">	  //DEFAULT_LOAD_FACTOR = 0.75</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上，不知道大家看到熟悉的东西没<strong>loadFactor</strong>,还记得上篇文章我们提到的<strong>装载因子</strong>(我们不可能等到数组快满时，才进行扩容操作，因为会影响效率），我们发现默认情况下，HashMap初始容量为16，且装载因子为0.75，也就是当容量为12(当前数组容量*装载因子)时，进行下一次添加数据的时候，会对HashMap内部的数组进行扩容。</p>
<h3 id="HashMap放入键值对"><a href="#HashMap放入键值对" class="headerlink" title="HashMap放入键值对"></a>HashMap放入键值对</h3><h4 id="查看put方法"><a href="#查看put方法" class="headerlink" title="查看put方法"></a>查看put方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">       return putVal(hash(key), key, value, false, true);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在HashMap调用put方法，放入键值对时，会先调用hash方法计算当前key对象的哈希值，对应hash方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>hash方法内部会获取当前key的hashCode,通过当前hashCode与当前hashCode右移后的数字，进行异或运算得到哈希值。</p>
<h4 id="查看putVal方法"><a href="#查看putVal方法" class="headerlink" title="查看putVal方法"></a>查看putVal方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">         //第一步，如果当前table为空，则初始化</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        //第二步，如果当前数据未放入，则添加</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">                //第三步，如果当前key已存在，则进行覆盖操作</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">                //第四步，判断该链表是否是红黑树</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;//第五步，是否是链表</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        //如果当前链表长度大于等于8则转会红黑树处理</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果是链表中的key已存在，则进行覆盖操作</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                //第六步，是否覆盖已存在的key对应的value</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        //如果添加完后，当前数组容量大于临界值，对数组进行扩容。</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中我们可以看出，HashMap添加元素主要分为六个步骤。经过这六个步骤完成了相应的键值对的映射。下面我们将具体的来分析这六个步骤。</p>
<p>####（一）创建table数组<br>如果当前数组为空，会调用相应resize()方法。创建相应table数组。这里省略了扩容数组代码，因为其比较复杂，下面我们会单独进行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">       int oldThr = threshold;</span><br><span class="line">       int newCap, newThr = 0;</span><br><span class="line">       //判断当前数组是否被创建</span><br><span class="line">       if (oldCap &gt; 0) &#123;</span><br><span class="line">           if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               return oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           //如果当前数组到达临界值</span><br><span class="line">           //数组容量为原来的2倍</span><br><span class="line">           //新的临界值为原来的2倍</span><br><span class="line">           else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">       &#125;</span><br><span class="line">       else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       else &#123;            </span><br><span class="line">           //默认没有数据的情况下，初始化数组，与临界值</span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       if (newThr == 0) &#123;</span><br><span class="line">           float ft = (float)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (int)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       //设置当前临界值</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       </span><br><span class="line">    		....省略扩容代码</span><br><span class="line">    		</span><br><span class="line">    	 //返回新的数组</span><br><span class="line">       return newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码很好理解。判断当前数组是否为空，如果为空，则初始化当前数组，且当前数组容量为DEFAULT_INITIAL_CAPACITY（DEFAULT_INITIAL_CAPACITY = 16),且临界值为12（<br>DEFAULT_INITIAL_CAPACITY* DEFAULT_LOAD_FACTOR）DEFAULT_LOAD_FACTOR，我们已经知道默认为0.75。最后该方法会将创建的数组进行返回。</p>
<p>####（二）如果当前数据未放入，则添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">           tab[i] = newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure>
<p>上述代码，知根据当前key值计算出来的hash值。获取对应数组中的下标，如果当前数组单元没有放入数据，则添加数据到相应的数组单元中。</p>
<p>####（三）如果当前key已存在，则进行覆盖操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">       e = p;</span><br></pre></td></tr></table></figure>
<p>上面代码也是很好理解，如果当前数组单元有数据，且相同hash值且key值相同，那么就进行替换操作。</p>
<p>####（四）判断当前是否是红黑树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">else if (p instanceof TreeNode)</span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br></pre></td></tr></table></figure>
<p>如果当前数组单元对应的是红黑树，那么调用相应红黑树添加方法。这里我们不讨论红黑树，这里我们只要知道。在使用红黑树的时候，查找效率是要优于传统的链表就好了。</p>
<p>####（五）、（六）添加元素到链表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">               if ((e = p.next) == null) &#123;</span><br><span class="line">                   p.next = newNode(hash, key, value, null);</span><br><span class="line">                   if (binCount &gt;= TREEIFY_THRESHOLD - 1) </span><br><span class="line">                   	 //如果当前链表长度大于8，转换为红黑树</span><br><span class="line">                       treeifyBin(tab, hash);</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               //获取hash值相同与key值相同，直接返回当前节点。</span><br><span class="line">               if (e.hash == hash &amp;&amp;</span><br><span class="line">                   ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                   break;</span><br><span class="line">               p = e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (e != null) &#123; // existing mapping for key</span><br><span class="line">           V oldValue = e.value;</span><br><span class="line">           if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">               e.value = value;</span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">           return oldValue;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>这里我把第五步与第六部合并来讲解。从代码代码大家就可以理解。获取数组单元链表的长度，如果当前链表长度大于8，转换为红黑树，如果存在相同hash值或者key值相同的节点。直接替换对应的value,反之。添加键值对到相应链表中。</p>
<h3 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h3><p>上面我们省略了扩容代码的具体，下面我们来仔细探讨一下HashMap的扩容机制。<br>主要扩容代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//oldTab是原来的talble 数组</span><br><span class="line">if (oldTab != null) &#123;</span><br><span class="line">			  //遍历原来数组单元中对应的链表，oldCap是原来数组的容量</span><br><span class="line">          for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                  oldTab[j] = null;</span><br><span class="line">                  //如果数组单元只有一个节点则计算其新位置，</span><br><span class="line">                  if (e.next == null)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                  //如果是红黑树，特殊处理</span><br><span class="line">                  else if (e instanceof TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                  //获取数组单元中的链表中的节点，并且重新定义位置。</span><br><span class="line">                  else &#123; // preserve order</span><br><span class="line">                      Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      do &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          //原位置的节点</span><br><span class="line">                          if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                              if (loTail == null)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              else</span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          //原位置+oldCap的节点</span><br><span class="line">                          else &#123;</span><br><span class="line">                              if (hiTail == null)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              else</span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; while ((e = next) != null);</span><br><span class="line">                      //把原位置的节点放入</span><br><span class="line">                      if (loTail != null) &#123;</span><br><span class="line">                          loTail.next = null;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      //把新位置的节点放入</span><br><span class="line">                      if (hiTail != null) &#123;</span><br><span class="line">                          hiTail.next = null;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>直接去理解这段代码很难，根据上篇文章的经验，我们知道在数组进行扩容的时候，需要根据hash值去与新的数组长度进行取余运算（hash&amp;length -1),但是从上述代码中，我们没有发现进行取余的操作。这是怎么回事呢？没事大家一起来看下图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-6d1e5de02c67b206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="取余流程.png"></p>
<p>上图中，我们假设某个节点hash值为1111 1111 1111 1111 11111 0000 1011 1111，并且在添加该值时，数组进行了扩容操作（为原来的数组长度的2倍）。我们发现节点在重新计算角标的时候，因为数组的长度变为之前的两倍，所以在新数组中的bit位中，始终要比原来的高一位（图中红色以表示区分），那么我们就可以根据下图得知。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-c6b296754a7c63c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未命名表单.png"></p>
<p>从上图可以得知，只要我们通过<strong>e.hash &amp; oldCap==0</strong>，我们就可以得知，该节点的新位置是在原位置，还是在原来的位置基础上+oldCap。不得不说这段代码非常优雅与巧妙，提高的效率不是吹的（因为没有重新取余去计算角标）。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>站在巨人的肩膀上。可以看得更远。</p>
<p>[Java 8系列之重新认识HashMap]–美团技术团队</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后，附上我写的一个基于Kotlin 仿开眼的项目<a href="https://github.com/AndyJennifer/SimpleEyes" target="_blank" rel="noopener">SimpleEyes</a>(ps: 其实在我之前，已经有很多小朋友开始仿这款应用了，但是我觉得要做就做好。所以我的项目和其他的人应该不同，不仅仅是简单的一个应用。但是，但是。但是。重要的话说三遍。还在开发阶段，不要打我)，欢迎大家follow和start.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/哈希表初识(一)/" data-id="cjsheb878000xdsr7809w5y9t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android-Handler机制之Message的发送与取出" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Android-Handler机制之Message的发送与取出/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>该文章属于Android Handler系列文章，如果想了解更多，请点击<br><a href="https://www.jianshu.com/p/43bb31d8a742" target="_blank" rel="noopener">《Android Handler机制之总目录》</a></p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前面的文章中，我们已经大概了解了ThreadLocal的内部原理，以及Handler发消息的大概流程。如果小伙伴如果对Handler机制不熟，建议阅读《 Android Handler机制之ThreadLocal》与《Android Handler机制之MessageQueue Handler Looper》。该篇文章主要着重讲解Message的发送与取出的具体逻辑细节。在此之前，我们先回顾一下Handler发送消息的具体流程。<br><img src="https://upload-images.jianshu.io/upload_images/2824145-b3c798765233c278.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HandlerLooperMessage关系.png"></p>
<h3 id="消息的发送"><a href="#消息的发送" class="headerlink" title="消息的发送"></a>消息的发送</h3><p>我们都知道当调用Handler发送消息的时候，不管是调用sendMessage,sendEmptyMessage,sendMessageDelayed还是其他发送一系列方法。最终都会调用<strong>sendMessageDelayed(Message msg, long delayMillis)</strong>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</span><br><span class="line">  &#123;</span><br><span class="line">      if (delayMillis &lt; 0) &#123;</span><br><span class="line">          delayMillis = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>该方法会调用sendMessageAtTime()方法。其中第二个参数是执行消息的时间，是通过从开机到现在的毫秒数（手机睡眠的时间不包括在内）+ 延迟执行的时间。这里不使用System.currentTimeMillis() ，是因为该时间是可以修改的。会导致延迟消息等待时间不准确。该方法内部会调用sendMessageAtTime()方法，我们接着往下走。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">     MessageQueue queue = mQueue;</span><br><span class="line">     if (queue == null) &#123;</span><br><span class="line">         RuntimeException e = new RuntimeException(</span><br><span class="line">                 this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">         Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">     return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里获取到线程中的MessageQueue对象mQueue（在构造函数通过Looper获得的），并调用enqueueMessage()方法，enqueueMessage()方法最终内部会调用MessageQueue的enqueueMessage()方法,那现在我们就直接看MessageQueue中把消息加入消息队列中的方法。</p>
<h3 id="消息的加入"><a href="#消息的加入" class="headerlink" title="消息的加入"></a>消息的加入</h3><p>当通过handler调用一系列方法如sendMessage()、sendMessageDelayed()方法时，最终会调用MessageQueue的enqueueMessage()方法。现在我们就来看看，消息是怎么加入MessageQueue(消息队列)中去的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">        if (msg.target == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (msg.isInUse()) &#123;</span><br><span class="line">            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">	        //如果当前消息循环已经结束，直接退出</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = new IllegalStateException(</span><br><span class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;//头部消息</span><br><span class="line">            boolean needWake;</span><br><span class="line">            //如果队列中没有消息，或者当前进入的消息比消息队列中的消息等待时间短，那么就放在消息队列的头部</span><br><span class="line">            if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">                // New head, wake up the event queue if blocked.</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">	            //判断唤醒条件，当前当前消息队列头部消息是屏障消息，且当前插入的消息为异步消息</span><br><span class="line">	            //且当前消息队列处于无消息可处理的状态</span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                //循环遍历消息队列，把当前进入的消息放入合适的位置（比较等待时间）</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //将消息插入合适的位置</span><br><span class="line">                msg.next = p; </span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			//调用nativeWake，以触发nativePollOnce函数结束等待</span><br><span class="line">            if (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里大家肯定注意到了nativeWake()方法，这里先不对该方法进行详细的描述，下文会对其解释及介绍。</strong><br>其实通过代码大家就应该发现了，在将消息加入到消息队列中时，已经将消息按照等待时间进行了排序。排序分为两种情况（<strong>这里图中的message.when是与当前的系统的时间差</strong>）：</p>
<ul>
<li><p>第一种：如果队列中没有消息，或者当前进入的消息比消息队列中头部的消息等待时间短，那么就放在消息队列的头部</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-f6048cc7d22e098c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一种情况.png"></p>
</li>
</ul>
<ul>
<li>第二种：反之，循环遍历消息队列，把当前进入的消息放入合适的位置（比较等待时间）<br><img src="https://upload-images.jianshu.io/upload_images/2824145-09c5226cc93a80c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二种情况.png"></li>
</ul>
<p>综上，我们了解了在我们使用Handler发送消息时，当消息进入到MessageQueue(消息队列)中时，已经按照等待时间进行了排序，且其头部对应的消息是Loop即将取出的消息。</p>
<h4 id="获取消息"><a href="#获取消息" class="headerlink" title="获取消息"></a>获取消息</h4><p>我们都知道消息的取出，是通过Loooper.loop()方法，其中loop()方法内部会调用MessageQueue中的next()方法。那下面我们就直接来看next()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">    </span><br><span class="line">    //如果退出消息消息循环，那么就直接退出</span><br><span class="line">       final long ptr = mPtr;</span><br><span class="line">       if (ptr == 0) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">       int nextPollTimeoutMillis = 0;</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">               Binder.flushPendingCommands();</span><br><span class="line">           &#125;</span><br><span class="line">		</span><br><span class="line">		//执行native层消息机制层,</span><br><span class="line">		//timeOutMillis参数为超时等待时间。如果为-1，则表示无限等待，直到有事件发生为止。</span><br><span class="line">		//如果值为0，则无需等待立即返回。该方法可能会阻塞</span><br><span class="line">           nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               //获取系统开机到现在的时间，如果使用System.currentMillis()会有误差，</span><br><span class="line">               final long now = SystemClock.uptimeMillis();</span><br><span class="line">               Message prevMsg = null;</span><br><span class="line">               Message msg = mMessages;//头部消息</span><br><span class="line">            </span><br><span class="line">               //判断是否是栅栏，同时获取消息队列最近的异步消息</span><br><span class="line">               if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                   do &#123;</span><br><span class="line">                       prevMsg = msg;</span><br><span class="line">                       msg = msg.next;</span><br><span class="line">                   &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">               &#125;</span><br><span class="line">               //获取消息，判断等待时间，如果还需要等待则等待相应时间后唤醒</span><br><span class="line">               if (msg != null) &#123;</span><br><span class="line">                   if (now &lt; msg.when) &#123;//判断当前消息时间，是不是比当前时间大，计算时间差</span><br><span class="line">                       // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                       nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       // 不需要等待时间或者等待时间已经到了，那么直接返回该消息</span><br><span class="line">                       mBlocked = false;</span><br><span class="line">                       if (prevMsg != null) &#123;</span><br><span class="line">                           prevMsg.next = msg.next;</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           mMessages = msg.next;</span><br><span class="line">                       &#125;</span><br><span class="line">                       msg.next = null;</span><br><span class="line">                       if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                       msg.markInUse();</span><br><span class="line">                       return msg;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   //没有更多的消息了</span><br><span class="line">                   nextPollTimeoutMillis = -1;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Process the quit message now that all pending messages have been handled.</span><br><span class="line">               //判断是否已经退出了</span><br><span class="line">               if (mQuitting) &#123;</span><br><span class="line">                   dispose();</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // If first time idle, then get the number of idlers to run.</span><br><span class="line">               // Idle handles only run if the queue is empty or if the first message</span><br><span class="line">               // in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">               //获取空闲时处理任务的handler 用于发现线程何时阻塞等待更多消息的回调接口。</span><br><span class="line">               if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                       &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                   pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">               &#125;</span><br><span class="line">               //如果空闲时处理任务的handler个数为0，继续让线程阻塞</span><br><span class="line">               if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                   // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                   mBlocked = true;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">			//判断当前空闲时处理任务的handler是否是为空</span><br><span class="line">               if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                   mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //只有第一次迭代的时候，才会执行下面代码</span><br><span class="line">           for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">               final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">               mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">               boolean keep = false;</span><br><span class="line">               try &#123;</span><br><span class="line">                   keep = idler.queueIdle();</span><br><span class="line">               &#125; catch (Throwable t) &#123;</span><br><span class="line">                   Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">               &#125;</span><br><span class="line">			//如果不保存空闲任务，执行完成后直接删除</span><br><span class="line">               if (!keep) &#123;</span><br><span class="line">                   synchronized (this) &#123;</span><br><span class="line">                       mIdleHandlers.remove(idler);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 重置空闲的handler个数，因为不需要重复执行</span><br><span class="line">           pendingIdleHandlerCount = 0;</span><br><span class="line">		</span><br><span class="line">		//当执行完空闲的handler的时候，新的native消息可能会进入，所以唤醒Native消息机制层</span><br><span class="line">           nextPollTimeoutMillis = 0;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里大家直接看MessageQueue的next()法肯定会很懵逼。妈的，这个nativePollOnce()方法是什么鬼，为毛它会阻塞呢？这个msg.isAsynchronous()判断又是怎么回事？妈的这个逻辑有点乱理解不了啊。大家不要慌，让我们带着这几个问题来慢慢分析。</p>
<h3 id="Native消息机制"><a href="#Native消息机制" class="headerlink" title="Native消息机制"></a>Native消息机制</h3><p>其实在Android 消息处理机制中，不仅包括了Java层的消息机制处理，还包括了Native消息处理机制(与我们知道的Handler机制一样，也拥有Handler、Looper、MessageQueue)。这里我们不讲Native消息机制的具体代码细节，如果有兴趣的小伙伴，请查看—–&gt;<a href="https://blog.csdn.net/innost/article/details/47252865" target="_blank" rel="noopener">深入理解Java Binder和MessageQueue</a></p>
<p>这里我们用一张图来表示Native消息与Jave层消息的关系（这里为大家提供了<a href="https://pan.baidu.com/s/1hAcAxFylMU0Aspg2dP9dBA" target="_blank" rel="noopener">Android源码</a>，大家可以按需下载），具体细节如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-aebe13831a25a08e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Native消息机制.png"> (这里我用的别人的图，如有侵权，请联系我，马上删除)。</p>
<p>其实我们也可以从Java层中的MessageQueue中几个方法就可以看出来。其中声明了几个本地的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private native static long nativeInit();</span><br><span class="line">private native static void nativeDestroy(long ptr);</span><br><span class="line">private native void nativePollOnce(long ptr, int timeoutMillis);</span><br><span class="line">private native static void nativeWake(long ptr);</span><br><span class="line">private native static boolean nativeIsPolling(long ptr);</span><br><span class="line">private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events);</span><br></pre></td></tr></table></figure>
<p>特别是在MessageQueue构造方法中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();//mPtr 其实是Native消息机制中MessageQueue的地址。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Java层中MessageQueue在初始化的时候，会调用本地方法去创建Native MessageQueue。并通过mPrt保存了Native中的MessageQueue的地址。</p>
<h4 id="Native消息机制与Java层的消息机制有什么关系"><a href="#Native消息机制与Java层的消息机制有什么关系" class="headerlink" title="Native消息机制与Java层的消息机制有什么关系"></a>Native消息机制与Java层的消息机制有什么关系</h4><p>想知道有什么关系，我们需要查看frameworks\base\core\jni\android_os_MessageQueue.cpp文件，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();</span><br><span class="line">    if (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实nativeInit()方法很简单，初始化NativeMessageQueue对象然后返回其地址。现在我们继续查看NativeMessageQueue的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() :</span><br><span class="line">        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</span><br><span class="line">    mLooper = Looper::getForThread();</span><br><span class="line">    if (mLooper == NULL) &#123;</span><br><span class="line">        mLooper = new Looper(false);</span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哇，我们看见了我们熟悉的”<strong>Looper</strong>“,这段代码其实很好理解。Native Looper调用静态方法getForThread()，获取当前线程中的Looper对象。如果为空，则创建Native Looper对象。这里大家肯定会有个疑问。当前线程是指什么线程呢？想知道到底绑定是什么线程，我们需要进入Native Looper中查看setForThread()与getForThread()两个方法。</p>
<h4 id="getForThread-从线程中获取设置的变量"><a href="#getForThread-从线程中获取设置的变量" class="headerlink" title="getForThread()从线程中获取设置的变量"></a>getForThread()从线程中获取设置的变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the looper associated with the calling thread, or NULL if</span><br><span class="line"> * there is not one.</span><br><span class="line"> */</span><br><span class="line">sp&lt;Looper&gt; Looper::getForThread() &#123;</span><br><span class="line">    int result = pthread_once(&amp; gTLSOnce, initTLSKey);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;pthread_once failed&quot;);</span><br><span class="line">    return (Looper*)pthread_getspecific(gTLSKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里pthread_getspecific()机制类似于Java层的ThreadLocal中的get()方法,是从线程中获取key值对应的数据。其中通过我们可以通过注释就能明白,Native Looper是存储在本地线程中的，而对应的线程，就是调用它的线程，而我们是在主线程中调用的。故Native Looper与主线程产生了关联。那么相应的setForThread()也是对主线程进行操作的了。接着看setForThread()方法。</p>
<h4 id="setForThread-从线程中设置变量"><a href="#setForThread-从线程中设置变量" class="headerlink" title="setForThread()从线程中设置变量"></a>setForThread()从线程中设置变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Sets the given looper to be associated with the calling thread.</span><br><span class="line">  * If another looper is already associated with the thread, it is replaced. *</span><br><span class="line">  * If &quot;looper&quot; is NULL, removes the currently associated looper.</span><br><span class="line">  */ </span><br><span class="line">void Looper::setForThread(const sp&lt;Looper&gt;&amp; looper) &#123;</span><br><span class="line">    sp&lt;Looper&gt; old = getForThread(); // also has side-effect of initializing TLS</span><br><span class="line">    if (looper != NULL) &#123;</span><br><span class="line">        looper-&gt;incStrong((void*)threadDestructor);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_setspecific(gTLSKey, looper.get());</span><br><span class="line">    if (old != NULL) &#123;</span><br><span class="line">        old-&gt;decStrong((void*)threadDestructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里pthread_setspecific()机制类似于Java层的ThreadLocal中的set()方法。通过注释我们明白将Native looper放入调用线程，如果已经存在，就替换。如果为空就删除。</p>
<h4 id="nativePollOnce-方法为什么会导致主线程阻塞？"><a href="#nativePollOnce-方法为什么会导致主线程阻塞？" class="headerlink" title="nativePollOnce()方法为什么会导致主线程阻塞？"></a>nativePollOnce()方法为什么会导致主线程阻塞？</h4><p>经过上文的讨论与分析，大家现在已经知道了，在Android消息机制中不仅有 Java层的消息机制，还有Native的消息机制。既然要出里Native的消息机制。那么肯定有一个处理消息的方法。那么调用本地消息机制消息的方法必然就是nativePollOnce()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,</span><br><span class="line">        jlong ptr, jint timeoutMillis) &#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在nativePollOnce()方法中调用nativeMessageQueue的pollOnce()方法，我们接着走。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">    mPollObj = NULL;</span><br><span class="line">    mPollEnv = NULL;</span><br><span class="line"></span><br><span class="line">    if (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;Throw(mExceptionObj);</span><br><span class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</span><br><span class="line">        mExceptionObj = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现pollOnce(timeoutMillis)内部调用的是Natave looper中的 pollOnce(int timeoutMillis, int<em> outFd, int</em> outEvents, void** outData)方法。继续看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        while (mResponseIndex &lt; mResponses.size()) &#123;</span><br><span class="line">            const Response&amp; response = mResponses.itemAt(mResponseIndex++);</span><br><span class="line">            int ident = response.request.ident;</span><br><span class="line">            if (ident &gt;= 0) &#123;</span><br><span class="line">                int fd = response.request.fd;</span><br><span class="line">                int events = response.events;</span><br><span class="line">                void* data = response.request.data;</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</span><br><span class="line">                        &quot;fd=%d, events=0x%x, data=%p&quot;,</span><br><span class="line">                        this, ident, fd, events, data);</span><br><span class="line">#endif</span><br><span class="line">                if (outFd != NULL) *outFd = fd;</span><br><span class="line">                if (outEvents != NULL) *outEvents = events;</span><br><span class="line">                if (outData != NULL) *outData = data;</span><br><span class="line">                return ident;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (result != 0) &#123;</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);</span><br><span class="line">#endif</span><br><span class="line">            if (outFd != NULL) *outFd = 0;</span><br><span class="line">            if (outEvents != NULL) *outEvents = 0;</span><br><span class="line">            if (outData != NULL) *outData = NULL;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于篇幅的限制，这里就简单介绍一哈pollOnce()方法。<strong>该方法会一直等待Native消息，其中 timeOutMillis参数为超时等待时间。如果为-1，则表示无限等待，直到有事件发生为止。如果值为0，则无需等待立即返回。</strong> 那么既然nativePollOnce()方法有可能阻塞，那么根据上文我们讨论的MessageQueue中的enqueueMessage中的nativeWake()方法。大家就应该了然了。nativeWake()方法就是唤醒Native消息机制不再等待消息而直接返回。</p>
<h4 id="nativePollOnce-一直循环为毛不造成主线程的卡死？"><a href="#nativePollOnce-一直循环为毛不造成主线程的卡死？" class="headerlink" title="nativePollOnce()一直循环为毛不造成主线程的卡死？"></a>nativePollOnce()一直循环为毛不造成主线程的卡死？</h4><blockquote>
<p>到了这里，其实大家都会有个疑问，如果当前主线程的MessageQueue没有消息时，程序就会便阻塞在loop的queue.next()中的nativePollOnce()方法里，一直循环那么主线程为什么不卡死呢？这里就涉及到Linux pipe/epoll机制，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。–摘自<a href="https://www.zhihu.com/question/34652589/answer/90344494" target="_blank" rel="noopener">Gityuan知乎回答</a></p>
</blockquote>
<p>如果大家想消息了解Native 消息机制的处理机制，请查看—–&gt;<a href="https://blog.csdn.net/innost/article/details/47252865" target="_blank" rel="noopener">深入理解Java Binder和MessageQueue</a></p>
<p>###屏障消息与异步消息</p>
<h4 id="屏障消息"><a href="#屏障消息" class="headerlink" title="屏障消息"></a>屏障消息</h4><p>在next()方法中，有一个屏障的概念(message.target ==null为屏障消息)，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                  // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                  do &#123;</span><br><span class="line">                      prevMsg = msg;</span><br><span class="line">                      msg = msg.next;</span><br><span class="line">                  &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
<p>其实通过代码，当出现屏障的时候，会滤过同步消息，而是直接获取其中的异步消息并返回。如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-15c235ff4f8d9a97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏障与异步消息.png"></p>
<p><strong>在Hadnler无参的构造函数中，默认设置的消息都是同步的。</strong>那我们就可以知道在Android中消息分为了两种，一种是同步消息，另一种是异步消息。在官方的解释中，异步消息通常代表着中断，输入事件和其他信号，这些信号必须独立处理，即使其他工作已经暂停。</p>
<h4 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h4><p>要设置异步消息，直接调用Message的setAsynchronous()方法，方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Sets whether the message is asynchronous, meaning that it is not</span><br><span class="line"> * subject to &#123;@link Looper&#125; synchronization barriers.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Certain operations, such as view invalidation, may introduce synchronization</span><br><span class="line"> * barriers into the &#123;@link Looper&#125;&apos;s message queue to prevent subsequent messages</span><br><span class="line"> * from being delivered until some condition is met.  In the case of view invalidation,</span><br><span class="line"> * messages which are posted after a call to &#123;@link android.view.View#invalidate&#125;</span><br><span class="line"> * are suspended by means of a synchronization barrier until the next frame is</span><br><span class="line"> * ready to be drawn.  The synchronization barrier ensures that the invalidation</span><br><span class="line"> * request is completely handled before resuming.</span><br><span class="line"> * &lt;/p&gt;&lt;p&gt;</span><br><span class="line"> * Asynchronous messages are exempt from synchronization barriers.  They typically</span><br><span class="line"> * represent interrupts, input events, and other signals that must be handled independently</span><br><span class="line"> * even while other work has been suspended.</span><br><span class="line"> * &lt;/p&gt;&lt;p&gt;</span><br><span class="line"> * Note that asynchronous messages may be delivered out of order with respect to</span><br><span class="line"> * synchronous messages although they are always delivered in order among themselves.</span><br><span class="line"> * If the relative order of these messages matters then they probably should not be</span><br><span class="line"> * asynchronous in the first place.  Use with caution.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @param async True if the message is asynchronous.</span><br><span class="line"> *</span><br><span class="line"> * @see #isAsynchronous()</span><br><span class="line"> */</span><br><span class="line">public void setAsynchronous(boolean async) &#123;</span><br><span class="line">    if (async) &#123;</span><br><span class="line">        flags |= FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        flags &amp;= ~FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家可以看到，设置异步消息，官方文档对其有详细的说明，侧面体现出了异步消息的重要性，那下面我就带着大家一起来理一理官方的注释说明。</p>
<ul>
<li>如果设置了异步消息，异步消息将不会受到屏障的影响（从next()方法中，我们已经了解了，当出现屏障的时候，同步消息会直接被过滤。直接返回最近的异步消息）</li>
<li>在某些操作中，例如视图进行invalidation(视图失效，进行重绘)，会引入屏障消息（也就是将message.target ==null的消息放入消息队列中），已防止后续的同步消息被执行。同时同步消息的执行会等到视图重绘完成后才会执行。</li>
</ul>
<h4 id="有哪些操作是异步消息呢？"><a href="#有哪些操作是异步消息呢？" class="headerlink" title="有哪些操作是异步消息呢？"></a>有哪些操作是异步消息呢？</h4><p>这里我就直接通过ActivityThread中的几个异步消息给大家做一些简单介绍。这里我就不用代码展示了，用图片来表示更清晰明了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-8fae432825308828.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ActivityThread中的异步消息.png"><br>在ActivityThread中，有一个sendMessage()多个参数方法。我们明显的看出，有四个消息是设置为异步消息的。DUMP_SERVICE、DUMP_HEAP、DUMP_ACTIVITY、DUMP_PROVIDER。从字面意思就可以看出来。回收service、回收堆内存、回收Activity、回收Provider都属于异步消息。</p>
<h4 id="屏障消息发送的时机"><a href="#屏障消息发送的时机" class="headerlink" title="屏障消息发送的时机"></a>屏障消息发送的时机</h4><p>那么Android中在哪些情况下会发生屏障消息呢？其实最为常见的就是在我们界面进行绘制的时候，如在ViewRootImpl.scheduleTraversals（）中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">       if (!mTraversalScheduled) &#123;</span><br><span class="line">           mTraversalScheduled = true;</span><br><span class="line">           //发送屏障消息</span><br><span class="line">           mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">           mChoreographer.postCallback(</span><br><span class="line">                   Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">           if (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">               scheduleConsumeBatchedInput();</span><br><span class="line">           &#125;</span><br><span class="line">           notifyRendererOfFramePending();</span><br><span class="line">           pokeDrawLockIfNeeded();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在调用scheduleTraversals()方法时，我们发现会发生一个屏障过去。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private int postSyncBarrier(long when) &#123;</span><br><span class="line">      </span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">	        //记录屏障消息的个数</span><br><span class="line">            final int token = mNextBarrierToken++;</span><br><span class="line">            final Message msg = Message.obtain();</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            msg.arg1 = token;</span><br><span class="line">			</span><br><span class="line">			//按照消息队列的等待时间，将屏障按照顺序插入</span><br><span class="line">            Message prev = null;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            if (when != 0) &#123;</span><br><span class="line">                while (p != null &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (prev != null) &#123; // invariant: p == prev.next</span><br><span class="line">                msg.next = p;</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">            &#125;</span><br><span class="line">            return token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们直接将围栏放在了消息队列中，同时重要的是我们并没有直接设置target,也就是tartget =null。其实现在我们可以想象，我们当我们正在进行界面的绘制的时候，我们是不希望有其他操作的，这个时候，要排除同步消息操作，也是可能理解的。</p>
<h3 id="IdleHandler-MessageQueuqe空闲时执行的任务"><a href="#IdleHandler-MessageQueuqe空闲时执行的任务" class="headerlink" title="IdleHandler(MessageQueuqe空闲时执行的任务)"></a>IdleHandler(MessageQueuqe空闲时执行的任务)</h3><p>在MessageQueue中的next()方法，出现了<strong>IdleHandler</strong>(MessageQueuqe空闲时执行的任务)，查看MessageQueue中IdleHander接口的说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Callback interface for discovering when a thread is going to block</span><br><span class="line"> * waiting for more messages.</span><br><span class="line"> */</span><br><span class="line">public static interface IdleHandler &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Called when the message queue has run out of messages and will now</span><br><span class="line">     * wait for more.  Return true to keep your idle handler active, false</span><br><span class="line">     * to have it removed.  This may be called if there are still messages</span><br><span class="line">     * pending in the queue, but they are all scheduled to be dispatched</span><br><span class="line">     * after the current time.</span><br><span class="line">     */</span><br><span class="line">    boolean queueIdle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当线程正在等待更多消息时，会回调该接口，同时queueIdl（）方法，<strong>会在消息队列执行完所有的消息等待且在等待更多消息时会被调用</strong>，如果返回true,表示该任务会在消息队列等待更多消息的时候继续执行，如果为false，表示该任务执行完成后就会被删除，不再执行。</p>
<p>其中MessageQueue通过使用addIdleHandler(@NonNull IdleHandler handler) 方法添加空闲时任务。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void addIdleHandler(@NonNull IdleHandler handler) &#123;</span><br><span class="line">       if (handler == null) &#123;</span><br><span class="line">           throw new NullPointerException(&quot;Can&apos;t add a null IdleHandler&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           mIdleHandlers.add(handler);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>既然MessageQueue可以添加空闲时任务，那么我们就看看最为明显的ActivityThread中声明的GcIdler。在ActivityThread中的<strong>H</strong>收到<strong>GC_WHEN_IDLE</strong>消息后，会执行scheduleGcIdler，将GcIdler添加到MessageQueue中的空闲任务集合中。具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void scheduleGcIdler() &#123;</span><br><span class="line">       if (!mGcIdlerScheduled) &#123;</span><br><span class="line">           mGcIdlerScheduled = true;</span><br><span class="line">           //添加GC任务</span><br><span class="line">           Looper.myQueue().addIdleHandler(mGcIdler);</span><br><span class="line">       &#125;</span><br><span class="line">       mH.removeMessages(H.GC_WHEN_IDLE);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>ActivityThread中GcIdler的详细声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  //GC任务</span><br><span class="line">  final class GcIdler implements MessageQueue.IdleHandler &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public final boolean queueIdle() &#123;</span><br><span class="line">           doGcIfNeeded();</span><br><span class="line">           //执行后，就直接删除</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">// 判断是否需要执行垃圾回收。</span><br><span class="line">   void doGcIfNeeded() &#123;</span><br><span class="line">       mGcIdlerScheduled = false;</span><br><span class="line">       final long now = SystemClock.uptimeMillis();</span><br><span class="line">    //获取上次GC的时间</span><br><span class="line">       if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) &lt; now) &#123;</span><br><span class="line">           //Slog.i(TAG, &quot;**** WE DO, WE DO WANT TO GC!&quot;);</span><br><span class="line">           BinderInternal.forceGc(&quot;bg&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>GcIdler方法理解起来很简单、就是获取上次GC的时间，判断是否需要GC操作。如果需要则进行GC操作。这里ActivityThread中还声明了其他空闲时的任务。如果大家对其他空闲任务感兴趣，可以自行研究。</p>
<h3 id="什么时候唤醒主线程呢？"><a href="#什么时候唤醒主线程呢？" class="headerlink" title="什么时候唤醒主线程呢？"></a>什么时候唤醒主线程呢？</h3><p>通过上文的了解，大家已经知道了Native的消息机制可能会导致主线程阻塞，那么唤醒Native消息机制<strong>（让Native消息机制不在等待Native消息，也就是nativePollOnce（）方法返回）</strong>在整个Android的消息机制中尤为重要，这里放在这里给大家讲是因为唤醒的条件涉及到屏障消息与空闲任务。大家理解了这两个内容后再来理解唤醒的时机就相对容易一点了，这里我们分别对唤醒的两个时机进行讲解。</p>
<h4 id="在添加消息到消息队列中"><a href="#在添加消息到消息队列中" class="headerlink" title="在添加消息到消息队列中"></a>在添加消息到消息队列中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">	    ...省略部分代码</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">	      ...省略部分代码</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;//头部消息</span><br><span class="line">            boolean needWake;</span><br><span class="line">            //如果队列中没有消息，或者当前进入的消息比消息队列中的消息等待时间短，那么就放在消息队列的头部</span><br><span class="line">            if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">                // New head, wake up the event queue if blocked.</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">	            //判断唤醒条件，当前消息队列头部消息是屏障消息，且当前插入的消息为异步消息</span><br><span class="line">	            //且当前消息队列处于无消息可处理的状态</span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                //循环遍历消息队列，把当前进入的消息放入合适的位置（比较等待时间）</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //将消息插入合适的位置</span><br><span class="line">                msg.next = p; </span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			//调用nativeWake，以触发nativePollOnce函数结束等待</span><br><span class="line">            if (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码，我们很明显的看见Native消息机制的唤醒，受到<strong>needWake</strong>这个变量影响，<strong>needWake ==true</strong>是在两个条件下。</p>
<ul>
<li>第一个：如果当前消息按照等待时间排序是在消息队列的头部, <strong>needWake = mBlocked</strong>，且<strong>mBlocked</strong>会在当前消息队列中没有消息可以处理，且没有空闲任务的条件下为<strong>true</strong>（mBlocked变量的赋值会在下文讲解）。</li>
<li>第二个：如果当前<strong>mBlocked=true（第一个条件判断）</strong>，且消息队列头部消息是屏障消息，同时当前插入的消息为异步消息的条件。<strong>needWake = true</strong>。</li>
</ul>
<h4 id="在空闲任务完成的时候唤醒"><a href="#在空闲任务完成的时候唤醒" class="headerlink" title="在空闲任务完成的时候唤醒"></a>在空闲任务完成的时候唤醒</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">	 ...省略部分代码</span><br><span class="line">       int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">       int nextPollTimeoutMillis = 0;</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">         ...省略部分代码</span><br><span class="line">		//执行native层消息机制层,</span><br><span class="line">		//timeOutMillis参数为超时等待时间。如果为-1，则表示无限等待，直到有事件发生为止。</span><br><span class="line">		//如果值为0，则无需等待立即返回。该方法可能会阻塞</span><br><span class="line">           nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">             ...省略部分代码</span><br><span class="line">           </span><br><span class="line">               //获取空闲时处理任务的handler 用于发现线程何时阻塞等待更多消息的回调接口。</span><br><span class="line">               if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                       &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                   pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">               &#125;</span><br><span class="line">               if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">               //如果消息队列中没有消息可以处理，且没有空闲任务，那么就继续等待消息</span><br><span class="line">                   mBlocked = true;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">		   ...省略部分代码</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">        ...省略执行空闲任务代码</span><br><span class="line">        </span><br><span class="line">           // 重置空闲的handler个数，因为不需要重复执行</span><br><span class="line">           pendingIdleHandlerCount = 0;</span><br><span class="line">		</span><br><span class="line">		//当执行完空闲的handler的时候，新的native消息可能会进入，所以唤醒Native消息机制层</span><br><span class="line">           nextPollTimeoutMillis = 0;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到 <strong>mBlocked = true</strong>的条件是在消息队列中没有消息可以处理，且也没有空闲任务的情况下。也就是当前<strong>mBlocked = true</strong>会影响到MessageQueue中enqueueMessage()方法是否唤醒主线程。</p>
<p>如果当前空闲任务完成后，<strong>会将nextPollTimeoutMillis 置为0，</strong>如果nextPollTimeoutMillis =0，会导致nativePollOnce直接返回，也就是会直接唤醒主线程（唤醒Native消息机制层）。</p>
<h3 id="MessageQueue取出消息整体流程"><a href="#MessageQueue取出消息整体流程" class="headerlink" title="MessageQueue取出消息整体流程"></a>MessageQueue取出消息整体流程</h3><p>到目前为止，大家已经对整个消息的发送与取出有一个大概的了解了。这里我着重对MessageQueue取消息的流程画了一个简单的流程图。希望大家根据对取消息有个更好的理解。<br><img src="https://upload-images.jianshu.io/upload_images/2824145-be14464451c370f9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体流程.jpg"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Handler在发消息时，MessageQueue已经对消息<strong>按照了等待时间</strong>进行了排序。</li>
<li>MessageQueue<strong>不仅包含了Java层消息机制同时包含Native消息机制</strong></li>
<li>Handler消息分为<strong>异步消息</strong>与<strong>同步消息</strong>两种。</li>
<li>MessageQueue中存在<strong>“屏障消息“</strong>的概念，当出现屏障消息时，会执行最近的异步消息，同步消息会被过滤。</li>
<li>MessageQueue在执行完消息队列中的消息等待更多消息时，<strong>会处理一些空闲任务，如GC操作等。</strong></li>
</ul>
<h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4><p>站在巨人的肩膀上。可以看得更远。该篇文章参阅了一下几本图书与源码。我这里我给了百度云盘的下载链接。大家可以按需下载。</p>
<p><a href="https://pan.baidu.com/s/1g8-Hj7SykM5o-NrgigvhMA" target="_blank" rel="noopener">深入理解Android 卷1,2,3</a></p>
<p><a href="https://pan.baidu.com/s/1hAcAxFylMU0Aspg2dP9dBA" target="_blank" rel="noopener">Android源码</a></p>
<p><a href="https://pan.baidu.com/s/19M6xuFYekGXF0BSEM1Kh9w" target="_blank" rel="noopener">Android开发艺术探索</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Android-Handler机制之Message的发送与取出/" data-id="cjsheb877000vdsr7dlao86oq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LinkedList分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/LinkedList分析/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://upload-images.jianshu.io/upload_images/2824145-09c6c13397af88ee.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模仿游戏.jpeg"></p>
<p>上次我们分析了ArrayList,大家都已经了解了分析一个集合的步骤。那接下来，我们继续分析LinkedList。废话不不多说，直接整。</p>
<p>#查看LinkedLis成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 指针指向第一个节点</span><br><span class="line">    * 初始化: (first == null &amp;&amp; last == null) ||</span><br><span class="line">    *            (first.prev == null &amp;&amp; first.item != null)</span><br><span class="line">    */</span><br><span class="line">   transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 指针指向最后一个节点</span><br><span class="line">    * 初始化: (first == null &amp;&amp; last == null) ||</span><br><span class="line">    *            (last.next == null &amp;&amp; last.item != null)</span><br><span class="line">    */</span><br><span class="line">   transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<p>从LinkedList成员中，可以看出Lined内部有两个指针，first(指向第一个节点)与Last(指向最后一个节点)。查看相关Node类声明：</p>
<p>###Node类声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            this.item = element;</span><br><span class="line">            this.next = next;</span><br><span class="line">            this.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Node类中，保存了当前数据元素，上一个节点，及下一个节点。从这里，我们大概了解到了LinkedList的内部结构是链表。</p>
<p>##一、添加元素</p>
<p>###add(e)方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">       linkLast(e);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>add方法内部调用了linkLast(e),继续走linkLast(e)。</p>
<p>####查看linkLast（e)方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void linkLast(E e) &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;//last指向最后一个节点。</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">        last = newNode;</span><br><span class="line">        if (l == null)</span><br><span class="line">            first = newNode;//frist指向第一个添加元素</span><br><span class="line">        else</span><br><span class="line">            l.next = newNode;//不是第一次添加，上一个节点的next指向当前节点</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当该方法执行是，会初始化一个Node节点保存当前添加元素及上一个节点。如果是第一次执行，该方法，first与Last都会指向该节点。如果不是第一次执行。上个节点的next会指向新添加的节点，且last指向新添加的节点。</p>
<p>###addFist（e)方法<br>addFist（e)中方法直接调用了linkFrist(e)方法，我们直接查看LinkFirst方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">      final Node&lt;E&gt; f = first;</span><br><span class="line">      final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);</span><br><span class="line">      first = newNode;</span><br><span class="line">      if (f == null)</span><br><span class="line">          last = newNode;</span><br><span class="line">      else</span><br><span class="line">          f.prev = newNode;</span><br><span class="line">      size++;</span><br><span class="line">      modCount++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>linkFirst方法内部创建了一个新的节点。如果是第一次添加。新节点上个节点为null。如果不是,则新的节点的上个的节点为first原来指向的节点，first指向新添加的节点。</p>
<p>###addLast(e)方法原理与addFirst（e)原理差不多，这里就直接跳过了</p>
<h2 id="二、获取元素"><a href="#二、获取元素" class="headerlink" title="二、获取元素"></a>二、获取元素</h2><p>###get(Index)方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">        checkElementIndex(index);//判断是否操作存储的长度</span><br><span class="line">        return node(index).item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>get方法先判断时候在有效范围类，如果调用了node(index）方法返回相应元素，继续走node方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">        // assert isElementIndex(index);</span><br><span class="line">        if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            for (int i = 0; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            return x;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法内部先判断index的位置是否小于<strong>总长度的一半</strong>，如果是，则从链表前方遍历，如果不是，则从链表最末尾进行遍历。</p>
<p>##三、删除元素</p>
<p>###removeFirst()方法</p>
<figure class="highlight plain"><figcaption><span>E removeFirst() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    if (f == null)//如果first没有指向元素，抛出异常</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>removeFirst()方法，先判断当前frist时候为null,如果不是,将first作为参数传入unLinkFirst()方法，查看unLinkFirst方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">       // assert f == first &amp;&amp; f != null;</span><br><span class="line">       final E element = f.item;</span><br><span class="line">       final Node&lt;E&gt; next = f.next;</span><br><span class="line">       f.item = null;</span><br><span class="line">       f.next = null; // help GC</span><br><span class="line">       first = next;</span><br><span class="line">       if (next == null)</span><br><span class="line">           last = null;</span><br><span class="line">       else</span><br><span class="line">           next.prev = null;</span><br><span class="line">       size--;</span><br><span class="line">       modCount++;</span><br><span class="line">       return element;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>unLinkFirst方法将器node中数据置为null,且将frist节点，指向f的下一个节点。并将f的下一个节点的上个节点(也就是f)至为null。</p>
<p>###removeLast()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E removeLast() &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        if (l == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return unlinkLast(l);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>removeLast方法内把Last指向的节点，传入unLikeLast()方法，继续走unLinkLast方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">       // assert l == last &amp;&amp; l != null;</span><br><span class="line">       final E element = l.item;</span><br><span class="line">       final Node&lt;E&gt; prev = l.prev;</span><br><span class="line">       l.item = null;</span><br><span class="line">       l.prev = null; // help GC</span><br><span class="line">       last = prev;</span><br><span class="line">       if (prev == null)</span><br><span class="line">           first = null;</span><br><span class="line">       else</span><br><span class="line">           prev.next = null;</span><br><span class="line">       size--;</span><br><span class="line">       modCount++;</span><br><span class="line">       return element;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>unLinkLast方法内部获取last重写指向Last原节点的上一个节点，同时将Last原节点至为null.</p>
<p>总结</p>
<ul>
<li>LinkedList方法内部实现是链表，且内部有fist与last指针控制数据的增加与删除等操作</li>
<li>LinkedList内部元素是可以重复，且有序的。因为是按照链表进行存储元素的。</li>
<li>LinkedList线程不安全的，因为其内部添加、删除、等操作，没有进行同步操作。</li>
<li>LinkedList增删元素速度较快。</li>
</ul>
<p>最后，附上我写的一个基于Kotlin 仿开眼的项目SimpleEyes(ps: 其实在我之前，已经有很多小朋友开始仿这款应用了，但是我觉得要做就做好。所以我的项目和其他的人应该不同，不仅仅是简单的一个应用。但是，但是。但是。重要的话说三遍。还在开发阶段，不要打我)，欢迎大家follow和start</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/LinkedList分析/" data-id="cjsheb85m0006dsr7ldwwzvph" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RxJava网络请求封装（针对RxJava2)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/RxJava网络请求封装（针对RxJava2)/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-fbf38f9d1a229dfd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="漫长的婚约.jpg"></p>
<p>最近平时开发中，用到了RxJava进行网络请求的封装，其中遇到了一个问题与大家分享一下。在无网络的情况下，我的程序直接抛出了不能连接某某地址。就以登录请求为例，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void login(String userName, String password) &#123;</span><br><span class="line">       mModel.login(userName,passWord).subscribe(new Consumer&lt;UserLoginInfo&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void accept(UserLoginInfo loginInfo) throws Exception &#123;</span><br><span class="line">             //省略逻辑代码</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, new Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void accept(Throwable throwable) throws Exception &#123;</span><br><span class="line">           Toast.makeText(mContext, throwable.getMessage(), Toast.LENGTH_SHORT).show();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，我是直接将错误信息打印出来的。当网络情况下。程序会直接抛出<strong>java.net.ConnectException: Failed to connect to /192.168.1.107:8080</strong>，为了良好的用户体验，不应该将网络异常提示出来。用户看后也是<strong>一脸懵逼</strong>，所以必须将此异常进行处理。提示正常的信息。如<strong>网络异常，请检查网络重试</strong>。那下面我们就开始封装吧。</p>
<h4 id="处理异常信息"><a href="#处理异常信息" class="headerlink" title="处理异常信息"></a>处理异常信息</h4><p>既然程序出现异常的时候会走。相应的Consumer&lt; Throwable &gt;接口，那么我们直接自定义一个类。实现该接口。并对错误进行分类处理。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ConsumerError&lt;T extends Throwable&gt; implements Consumer&lt;T&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(T t) throws Exception &#123;</span><br><span class="line">        String errorMessage = &quot;&quot;;</span><br><span class="line">        int errorCode = 0;</span><br><span class="line">        if (t instanceof SocketException) &#123;//请求异常</span><br><span class="line">            errorMessage = &quot;网络异常，请检查网络重试&quot;;</span><br><span class="line">        &#125; else if (t instanceof UnknownHostException) &#123;//网络异常</span><br><span class="line">            errorMessage = &quot;请求失败，请稍后重试...&quot;;</span><br><span class="line">        &#125; else if (t instanceof SocketTimeoutException) &#123;//请求超时</span><br><span class="line">            errorMessage = &quot;请求超时&quot;;</span><br><span class="line">        &#125; else if (t instanceof ServerException) &#123;//服务器返回异常</span><br><span class="line">            errorMessage = t.getMessage();</span><br><span class="line">            errorCode = ((ServerException) t).getErrorCode();</span><br><span class="line">        &#125;</span><br><span class="line">        onError(errorCode, errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void onError(int errorCode, String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码我们可以发现。我们创建了一个抽象类。并且提供了一个<strong>onError</strong>抽象方法（参数1：错误码，参数2：错误信息）。当出现错误的时候，我们只需要创建匿名内部类，并<strong>实现onError方法</strong>就行了。细心的小伙伴可以看见这里出现了一个<strong>ServerException</strong>，这是什么鬼。那接下来，慢慢说。</p>
<h4 id="自定义服务器异常"><a href="#自定义服务器异常" class="headerlink" title="自定义服务器异常"></a>自定义服务器异常</h4><p>在网络请求中，服务器会返回一些错误。当我们收到服务器返回的这些错误信息的时候。可能会对错误信息进行一些相关的处理。说到服务器异常。那就必须要提到服务器返回的数据格式与网络请求。具体实现如下：</p>
<h4 id="服务器返回数据格式"><a href="#服务器返回数据格式" class="headerlink" title="服务器返回数据格式"></a>服务器返回数据格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Result&lt;T&gt; implements Serializable &#123;</span><br><span class="line">    public boolean result;</span><br><span class="line">    public int code;</span><br><span class="line">    public String message;</span><br><span class="line">    public T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体的网络请求："><a href="#具体的网络请求：" class="headerlink" title="具体的网络请求："></a>具体的网络请求：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Observable&lt;UserLoginInfo&gt; login(String userName, String password) &#123;</span><br><span class="line"> return Api.getDefault().login(userName,password).compose(RxHelper&lt;UserLoginInfo&gt;handleResult()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，请求地址与参数都可以不用管。直接查看compose()函数中<strong>RxHelper<boolean>handleResult())</boolean></strong>。这里有可能有些小伙伴不知道compose操作符。<a href="https://www.jianshu.com/p/3d0bd54834b0" target="_blank" rel="noopener">传送门</a></p>
<h5 id="RxHelper具体实现"><a href="#RxHelper具体实现" class="headerlink" title="RxHelper具体实现"></a>RxHelper具体实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class RxHelper &#123;</span><br><span class="line"></span><br><span class="line">      //处理请求结果 针对 有code message data 的json</span><br><span class="line">      //对请求状态吗进行分析，如果成功获取result 中的data</span><br><span class="line">      public static &lt;T&gt; ObservableTransformer&lt;Result&lt;T&gt;, T&gt; handleResult() &#123;</span><br><span class="line">        return upstream -&gt; upstream.flatMap(result -&gt; &#123;</span><br><span class="line">            if (result.code == HttpErrorCode.HTTP_NO_ERROR) &#123;</span><br><span class="line">                return createSuccessData(result.data);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return Observable.error(new ServerException(result.code, result.message));①</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	//处理没有data的Result</span><br><span class="line">    public static ObservableTransformer&lt;Result, Result&gt; handleOnlyResult() &#123;</span><br><span class="line">        return upstream -&gt; upstream.flatMap(result -&gt; &#123;</span><br><span class="line">            if (result.code == HttpErrorCode.HTTP_NO_ERROR) &#123;</span><br><span class="line">                return createSuccessData(result);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return Observable.error(new ServerException(result.code, result.message));②</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建成功返回的数据    </span><br><span class="line">    private static &lt;T&gt; Observable&lt;T&gt; createSuccessData(final T t) &#123;</span><br><span class="line">        return Observable.create(new ObservableOnSubscribe&lt;T&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(@NonNull ObservableEmitter&lt;T&gt; emitter) throws Exception &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    emitter.onNext(t);</span><br><span class="line">                    emitter.onComplete();</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                    emitter.onError(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RxHelper主要用于网络请求帮助类处理。对请求结果进行了判断，同时对请求与响应线程进行了处理，看①②处，发现如果当前数据返回状态码不是成功的话，程序就会直接抛出<strong>带有当前的状态码与错误信息的Error</strong>。程序抛出Error后，自然会走我们观察者中的Error方法（<strong>也就是我们自定义的ConsumerError中的error方法</strong>）。</p>
<p>这样到此。整个异常处理流程就完全清楚了。当然在服务器返回的错误中。你可以根据服务器返回的错误。定义相应的错误处理。</p>
<h4 id="错误信息封装"><a href="#错误信息封装" class="headerlink" title="错误信息封装"></a>错误信息封装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class HttpErrorCode &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 请求的服务不存在</span><br><span class="line">     */</span><br><span class="line">    public static final int ERROR_404 = 404;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 系统内部错误</span><br><span class="line">     */</span><br><span class="line">    public static final int ERROR_500 = 500;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 程序内部异常</span><br><span class="line">     */</span><br><span class="line">    public static final int ERROR_998 = 998;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 未知错误</span><br><span class="line">     */</span><br><span class="line">    public static final int ERROR_999 = 999;</span><br><span class="line">    /**</span><br><span class="line">     * 请求成功</span><br><span class="line">     */</span><br><span class="line">    public static final int HTTP_NO_ERROR = 200;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 自定义异常</span><br><span class="line">     */</span><br><span class="line">    public static final int USER_NOT_EXIT = 100000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="封装后具体代码"><a href="#封装后具体代码" class="headerlink" title="封装后具体代码"></a>封装后具体代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void login(String userName, String password) &#123;</span><br><span class="line">        mModel.login(userName,passWord).subscribe(new Consumer&lt;UserLoginInfo&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(UserLoginInfo loginInfo) throws Exception &#123;</span><br><span class="line">              //省略逻辑代码</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,new ConsumerError&lt;Throwable&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onError(int errorCode, String message) &#123;</span><br><span class="line">                      if(errorCode== HttpErrorCode.USER_NOT_EXIT)&#123;//根据具体错误，处理相应逻辑。</span><br><span class="line">                  </span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样我们的请求封装就完成啦。我们只要在ConsumerError中的onError根据不同的错误码，来处理相应的业务逻辑了。是不是很方便？</p>
<p>最后，附上我写的一个基于Kotlin 仿开眼的项目<a href="https://github.com/AndyJennifer/SimpleEyes" target="_blank" rel="noopener">SimpleEyes</a>(ps: 其实在我之前，已经有很多小朋友开始仿这款应用了，但是我觉得要做就做好。所以我的项目和其他的人应该不同，不仅仅是简单的一个应用。但是，但是。但是。重要的话说三遍。还在开发阶段，不要打我)，欢迎大家follow和start</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/RxJava网络请求封装（针对RxJava2)/" data-id="cjsheb85o0007dsr7tsi9i0ry" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android-Handler机制之总目录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Android-Handler机制之总目录/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-b52c19b7eff35733.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小花花.jpg"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Handler机制一直都是面试常问的一些知识点，如果想将其机制彻底弄懂，仍然需要花费不少的时间，但是想着准备面试，所以就想总结哈所有Handler机制可能会出现的考点。一是自己总结复写，而是给大家分享参考。</p>
<ul>
<li><p><a href="https://www.jianshu.com/p/2a34d30806d4" target="_blank" rel="noopener">《Android Handler机制之ThreadLocal》</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/7f02b832f4fe" target="_blank" rel="noopener">《Android Handler机制之Handler 、MessageQueue 、Looper》</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/219701879fe4" target="_blank" rel="noopener">《Android Handler机制之Message的发送与取出》</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/d0ef4edd4407" target="_blank" rel="noopener">《Android Handler机制之Message及Message回收机制 》</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/40659db0aafd" target="_blank" rel="noopener">《Android Handler机制之消息池的扩展 SimplePool与SynchronizedPool 》</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/db6601168622" target="_blank" rel="noopener">《Android Handler机制之循环消息队列的退出 》</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/b9fe1b5e5cbf" target="_blank" rel="noopener">《Android Handler机制之内存泄漏》</a></p>
</li>
<li>Android Handler机制之实现自己的消息队列(该篇文章会在Java并发系列文章写完之后，更新）。</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>希望大家通过这系列文章，能够彻底的理解Handler机制，因为博主能力有限，难免某些知识点不会讲解太清楚，如果大家发现错误或者遗漏的知识点，希望大家都给我指出。这里谢谢大家啦</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Android-Handler机制之总目录/" data-id="cjsheb8580000dsr7alcym9yl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android-Handler机制之Message及Message回收机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/Android-Handler机制之Message及Message回收机制/" class="article-date">
  <time datetime="2019-02-23T08:52:30.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2824145-93bba9f12e53bb0d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小松鼠.jpg"></p>
<blockquote>
<p>该文章属于Android Handler系列文章，如果想了解更多，请点击<br><a href="https://www.jianshu.com/p/43bb31d8a742" target="_blank" rel="noopener">《Android Handler机制之总目录》</a></p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前面的文章中我们讲解了Handler、Looper、MessageQueue的具体关系，了解了具体的消息循环的流程。下面将一起来探讨最为整个消息循环的消息载体Message。</p>
<h3 id="Message中可以携带的信息"><a href="#Message中可以携带的信息" class="headerlink" title="Message中可以携带的信息"></a>Message中可以携带的信息</h3><p>Message中可以携带的数据比较丰富，下面对一些常用的数据进行了分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用户定义的消息代码，以便当接受到消息是关于什么的。其中每个Hanler都有自己的命名控件，不用担心会冲突</span><br><span class="line"> */	</span><br><span class="line"> public int what;</span><br><span class="line">/**</span><br><span class="line"> * 如果你只想存很少的整形数据，那么可以考虑使用arg1与arg2,</span><br><span class="line"> * 如果需要传输很多数据可以使用Message中的setData(Bundle bundle)</span><br><span class="line"> */</span><br><span class="line"> public int arg1;</span><br><span class="line">/**</span><br><span class="line"> * 如果你只想存很少的整形数据，那么可以考虑使用arg1与arg2,</span><br><span class="line"> * 如果需要传输很多数据可以使用Message中的setData(Bundle bundle)</span><br><span class="line"> */</span><br><span class="line"> public int arg2;</span><br><span class="line">/**</span><br><span class="line"> * 发送给接受方的任意对象，在使用跨进程的时候要注意obj不能为null</span><br><span class="line"> */</span><br><span class="line"> public Object obj;</span><br><span class="line">/**</span><br><span class="line"> * 在使用跨进程通信Messenger时，可以确定需要谁来接收</span><br><span class="line"> */</span><br><span class="line"> public Messenger replyTo;</span><br><span class="line">/**</span><br><span class="line"> * 在使用跨进程通信Messenger时，可以确定需要发消息的uid</span><br><span class="line"> */</span><br><span class="line"> public int sendingUid = -1;</span><br><span class="line">/**</span><br><span class="line"> * 如果数据比较多，可以直接使用Bundle进行数据的传递</span><br><span class="line"> */</span><br><span class="line"> Bundle data;</span><br></pre></td></tr></table></figure></p>
<p>其中关于what的值为什么不会冲突的原因是，之前我们讲过的handler是与线程进行绑定的。也就是说不同消息循环消息的发送，处理的线程是不一样的。当然是不会冲突的。对于Messenger，因为涉及到Binder机制，这里就不过多的描述了，有兴趣的小伙伴可以自行查询相关资料学习。</p>
<h3 id="创建消息的方式"><a href="#创建消息的方式" class="headerlink" title="创建消息的方式"></a>创建消息的方式</h3><p>官方建议使用Message.obtain()系列方法来获取Message实例，因为其Message实例是直接从Handler的消息池中获取的，可以循环利用，不必另外开辟内存空间，效率比直接使用new Message（）创建实例要高。其中具体创建消息的方式，我已经为大家分好类了。具体分类如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//无参数</span><br><span class="line">public static Message obtain() &#123;...&#125;</span><br><span class="line">//带Messag参数</span><br><span class="line">public static Message obtain(Message orig) &#123;&#125;</span><br><span class="line">//带Handler参数</span><br><span class="line">public static Message obtain(Handler h) &#123;&#125;</span><br><span class="line">public static Message obtain(Handler h, Runnable callback)&#123;&#125;</span><br><span class="line">public static Message obtain(Handler h, int what)&#123;&#125;</span><br><span class="line">public static Message obtain(Handler h, int what, Object obj)&#123;&#125;</span><br><span class="line">public static Message obtain(Handler h, int what, int arg1, int arg2)&#123;&#125;</span><br><span class="line">public static Message obtain(Handler h, int what,int arg1, int arg2, Object obj) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中在Message的obtain带参数的方法中，内部都会调用无参的obtain()方法来获取消息后。然后并根据其传入的参数，对Message进行赋值。（关于具体的obtain方法会在下方消息池实现原理中具体描述）</p>
<h3 id="消息池实现原理"><a href="#消息池实现原理" class="headerlink" title="消息池实现原理"></a>消息池实现原理</h3><p>既然官方建议使用消息池来获取消息，那么在了解其内部机制之前，我们来看看Message中的消息池的设计。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final Object sPoolSync = new Object();//控制获取从消息池中获取消息。保证线程安全</span><br><span class="line">private static Message sPool;//消息池</span><br><span class="line">private static int sPoolSize = 0;//消息池中回收的消息数量</span><br><span class="line">private static final int MAX_POOL_SIZE = 50;//消息池最大容量</span><br></pre></td></tr></table></figure></p>
<p>从Message的消息池设计，我们大概能看出以下几点：</p>
<ol>
<li>该消息池在同一个消息循环中是共享的（sPool声明为static)，</li>
<li>消息池中的最大容量为50，</li>
<li>从消息池获取消息是线程安全的。</li>
</ol>
<h4 id="从消息池中获取消息"><a href="#从消息池中获取消息" class="headerlink" title="从消息池中获取消息"></a>从消息池中获取消息</h4><p>在上文中，我们已经知道了在使用消息池获得消息时，都会调用无参的obtain（）方法。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">       synchronized (sPoolSync) &#123;</span><br><span class="line">           if (sPool != null) &#123;</span><br><span class="line">               Message m = sPool;</span><br><span class="line">               sPool = m.next;</span><br><span class="line">               m.next = null;</span><br><span class="line">               m.flags = 0; //重新标识当前Message没有使用过</span><br><span class="line">               sPoolSize--;</span><br><span class="line">               return m;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return new Message();//如果为空直接返回</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述代码中，我们可以了解，也就是当前 消息池不为空（sPool !=null)的情况下，那么我们就可以从消息池中获取数据，相应的消息池中的消息数量会减少。<strong>消息池的内部实现是以链表的形式</strong>，其中spol指针指向当前链表的头结点，从消息池中获取消息是<strong>以移除链表中sPool所指向的节点的形式</strong>，具体原理如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-306faab2aad326ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取消息.png"></p>
<h4 id="回收消息到消息池"><a href="#回收消息到消息池" class="headerlink" title="回收消息到消息池"></a>回收消息到消息池</h4><p>在Meaage的消息回收中，消息的实际回收方法是recycleUnchecked（）方法，具体如下图所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> void recycleUnchecked() &#123;</span><br><span class="line">   //用于表示当前Message消息已经被使用过了</span><br><span class="line">      flags = FLAG_IN_USE;</span><br><span class="line">      //情况之前Message的数据</span><br><span class="line">      what = 0;</span><br><span class="line">      arg1 = 0;</span><br><span class="line">      arg2 = 0;</span><br><span class="line">      obj = null;</span><br><span class="line">      replyTo = null;</span><br><span class="line">      sendingUid = -1;</span><br><span class="line">      when = 0;</span><br><span class="line">      target = null;</span><br><span class="line">      callback = null;</span><br><span class="line">      data = null;</span><br><span class="line">//判断当前消息池中的数量是不是小于最大数量，其中 MAX_POOL_SIZE=50</span><br><span class="line">      synchronized (sPoolSync) &#123;</span><br><span class="line">          if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">              next = sPool;</span><br><span class="line">              sPool = this;</span><br><span class="line">              sPoolSize++;//记录当前消息池中的数量</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在recycleUnchecked（）方法中，大致分为三步，第一步将该条回收的消息状态设置为正在使用，第二步将Message所有的存储信息都变为初始值，第三步，如果当前消息池仍能够存储回收的消息，那么就将消息存储在消息池中。<strong>其中将回收消息加入消息池中是使用链表的形式</strong>，具体回收消息到消息池如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2824145-95edc85c2fec9e30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加入消息.png"></p>
<h3 id="Message-消息回收时机"><a href="#Message-消息回收时机" class="headerlink" title="Message 消息回收时机"></a>Message 消息回收时机</h3><p>这里为了方便大家梳理逻辑，我提前将几种会调用消息进行回收的情况都描述出来了，具体的情况如下所示：</p>
<h4 id="当Handler指定删除单条消息，或所有消息的时候"><a href="#当Handler指定删除单条消息，或所有消息的时候" class="headerlink" title="当Handler指定删除单条消息，或所有消息的时候"></a>当Handler指定删除单条消息，或所有消息的时候</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void removeMessages(Handler h, int what, Object object)</span><br><span class="line">void removeMessages(Handler h, Runnable r, Object object)</span><br><span class="line">void removeCallbacksAndMessages(Handler h, Object object)</span><br></pre></td></tr></table></figure>
<p>当使用Handler删除某条消息的时候，会分别调用MessageQueue的 removeMessages(Handler h, int what, Object object)与removeCallbacksAndMessages(Handler h, Object object) ，removeMessages(Handler h, Runnable r, Object object) 三个方法。这三个个方法逻辑比较类似。这里直接选取removeCallbacksAndMessages（）方法来进行讲解。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void removeCallbacksAndMessages(Handler h, Object object) &#123;</span><br><span class="line">       if (h == null) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           Message p = mMessages;</span><br><span class="line"></span><br><span class="line">           // 回收满足条件的第一条消息  第一步</span><br><span class="line">           while (p != null &amp;&amp; p.target == h</span><br><span class="line">                   &amp;&amp; (object == null || p.obj == object)) &#123;</span><br><span class="line">                //下面操作会将满足回收条件的消息，从消息队列中移除</span><br><span class="line">               Message n = p.next;</span><br><span class="line">               mMessages = n;</span><br><span class="line">               p.recycleUnchecked();</span><br><span class="line">               p = n;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 回收该条消息后面的满足条件的消息 第二步</span><br><span class="line">           while (p != null) &#123;</span><br><span class="line">               Message n = p.next;</span><br><span class="line">               if (n != null) &#123;</span><br><span class="line">                   if (n.target == h &amp;&amp; (object == null || n.obj == object)) &#123;</span><br><span class="line">                    //下面操作会将满足回收条件的消息，从消息队列中移除</span><br><span class="line">                       Message nn = n.next;</span><br><span class="line">                       n.recycleUnchecked();</span><br><span class="line">                       p.next = nn;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               p = n;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在removeCallbacksAndMessages(Handler h, Object object)方法中，在该方法中分成了两步，</p>
<ul>
<li>第一步：回收满足条件的第一条消息。同时将该消息从消息队列中移除。<code>并且将mMessages指向消息队列中的头节点</code>。<br>在第一步中，我们可以看出会循环遍历消息队列中的消息找到p.target == h&amp;&amp;（(object == null || p.obj == object)，然后进行回收，也就是说在第一步中，会移除对应的Handler。(<strong>在Handler机制中，多个handler对应同一个MessageQueue,对应同一个Looper，Handler与MessageQueue与Looper之间的关系是N：1：1</strong>)</li>
<li>第二步：回收<strong>已经回收的第一条消息之后</strong>所有满足条件的消息。同时将这些消息从消息队列中移除。</li>
</ul>
<blockquote>
<p>思考：为什么不直接走第二步回收消息就行了。反正满足条件的消息都会移除，为毛要先移除第一条，在接着移除后面的消息（这里如果大家感到困惑，请仔细观看第一步操作中的  其中一条语句<code>mMessages = n;</code>,之所以会走两次循环，主要目的是让mMessages指向消息队列中的头节点）。</p>
</blockquote>
<p>这里要大家要注意的是，如果<code>object==null</code>，那么就会移除消息队列中所有对应Handler发送的消息所有mesaage.object==null的消息。默认情况下，我们都是不会对Message.obj进行赋值的。所以默认情况下，如果你传入object =null，<strong>有可能</strong>会移除消息队列中的所有的消息。</p>
<h4 id="当Loooper取出消息时"><a href="#当Loooper取出消息时" class="headerlink" title="当Loooper取出消息时"></a>当Loooper取出消息时</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> public static void loop() &#123;</span><br><span class="line">//省略部分代码</span><br><span class="line">     for (;;) &#123;</span><br><span class="line">         Message msg = queue.next(); // might block</span><br><span class="line">         if (msg == null) &#123;</span><br><span class="line">             // No message indicates that the message queue is quitting.</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">//省略部分代码</span><br><span class="line">         try &#123;</span><br><span class="line">             msg.target.dispatchMessage(msg);</span><br><span class="line">             end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">         &#125; finally &#123;</span><br><span class="line">             if (traceTag != 0) &#123;</span><br><span class="line">                 Trace.traceEnd(traceTag);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">   //省略部分代码</span><br><span class="line">   </span><br><span class="line">   //回收消息</span><br><span class="line">         msg.recycleUnchecked();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们都知道消息的取出是通过Looper类中的loop方法。从代码中我们可以看出，当消息取出并执行相应操作后。最后会将消息回收。</p>
<h4 id="当Looper取消循环消息队列的时候"><a href="#当Looper取消循环消息队列的时候" class="headerlink" title="当Looper取消循环消息队列的时候"></a>当Looper取消循环消息队列的时候</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void quitSafely() &#123; mQueue.quit(true);&#125;</span><br><span class="line">public void quit() &#123; mQueue.quit(false); &#125;</span><br></pre></td></tr></table></figure>
<p>当退出消息队列的时候，也就是调用Loooper的quitSafely（）或quit（）方法，从代码中我们可以看出，会调用其内部的MessageQueue的quit(boolean safe)方法。我们继续跟踪代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void quit(boolean safe) &#123;</span><br><span class="line">     if (!mQuitAllowed) &#123;//注意，主线程是不能退出消息循环的</span><br><span class="line">         throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     synchronized (this) &#123;</span><br><span class="line">         if (mQuitting) &#123;//如果当前循环消息已经退出了，直接返回</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         mQuitting = true;</span><br><span class="line"></span><br><span class="line">         if (safe) &#123;//如果是安全退出</span><br><span class="line">             removeAllFutureMessagesLocked();</span><br><span class="line">         &#125; else &#123;//如果不是安全退出</span><br><span class="line">             removeAllMessagesLocked();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // We can assume mPtr != 0 because mQuitting was previously false.</span><br><span class="line">         nativeWake(mPtr);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在MessageQueue的quit(boolean safe)方法中，会将mQuitting （用于判断当前消息队列是否已经退出）置为true，同时会根据当前是否安全退出的标志 (safe)来走不同的逻辑,如果安全则走removeAllFutureMessagesLocked（）方法，如果不是安全退出则走removeAllMessagesLocked（）方法。下面分别对这两个方法进行讨论。</p>
<h5 id="非安全退出"><a href="#非安全退出" class="headerlink" title="非安全退出"></a>非安全退出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void removeAllMessagesLocked() &#123;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">        Message n = p.next;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line">        p = n;</span><br><span class="line">    &#125;</span><br><span class="line">    mMessages = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非安全退出其实很简单，就是将所有消息队列中的消息全部回收。具体示意图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-012dc5d65a9d84b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收全部消息.png"></p>
<h5 id="安全退出"><a href="#安全退出" class="headerlink" title="安全退出"></a>安全退出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void removeAllFutureMessagesLocked() &#123;</span><br><span class="line">     final long now = SystemClock.uptimeMillis();</span><br><span class="line">     Message p = mMessages;//当前队列中的头消息</span><br><span class="line">     if (p != null) &#123;</span><br><span class="line">         if (p.when &gt; now) &#123;//判断时间，如果Message的取出时间比当前时间要大直接移除</span><br><span class="line">             removeAllMessagesLocked();</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             Message n;</span><br><span class="line">             for (;;) &#123;//继续判断，取队列中所有大于当前时间的消息</span><br><span class="line">                 n = p.next;</span><br><span class="line">                 if (n == null) &#123;</span><br><span class="line">                     return;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (n.when &gt; now) &#123;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">                 p = n;</span><br><span class="line">             &#125;</span><br><span class="line">             p.next = null;</span><br><span class="line">             do &#123;//将所有所有大于当前时间的消息的消息回收</span><br><span class="line">                 p = n;</span><br><span class="line">                 n = p.next;</span><br><span class="line">                 p.recycleUnchecked();</span><br><span class="line">             &#125; while (n != null);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>观察上诉代码，在该方法中，会判断当前消息队列中的头消息的时间是否大于当前时间，如果大于当前时间就会removeAllMessagesLocked（）方法（也就是回收全部消息），反之，则回收部分消息，同时没有被回收的消息任然可以被取出执行。具体示意图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2824145-104a9f156f672df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收部分消息.png"></p>
<h4 id="当消息队列退出的，但是仍然发送消息过来的时候"><a href="#当消息队列退出的，但是仍然发送消息过来的时候" class="headerlink" title="当消息队列退出的，但是仍然发送消息过来的时候"></a>当消息队列退出的，但是仍然发送消息过来的时候</h4><p>在Looper调用quit()方法时，也就是Looper退出消息循环的时候，我们已经知道了其内部会调用MessageQueue的quit(boolean safe)方法。当MessageQueue退出的时候，会将mQuitting置为true。那么当对应的Handler发送消息时，我们都知道会调用MessageQueue的enqueueMessage（Message msg, long when）方法。那么现在我们观察下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">	   ...省略部分代码</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">          ...省略部分代码</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = new IllegalStateException(</span><br><span class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            ...省略部分代码</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>观察该代码我们得知，当循环消息退出的时候，如果这个时候Handler继续发送消息来。会将该消息回收。但是现在这里有个问题。既然我们的消息队列已经结束循环了。那么我们回收该消息又有什么用呢？我们又不能重新的开启消息循环。不知道Google这里为什么会这么设计。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>在使用Handler发消息时，建议使用Message.obtin()方法，从消息池中获取消息。</li>
<li>在Message中消息池是使用链表的形式来存储消息的。</li>
<li>在Message中消息池中最大允许存储50条的消息。</li>
<li>在使用Handler移除某条消息的时候，该消息有可能会被消息池回收。（会判断消息池是否仍然能存储消息）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/Android-Handler机制之Message及Message回收机制/" data-id="cjsheb85x0009dsr732079h5f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/23/RecyclerView-smoothScrollToPosition了解一下/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/RecyclerView滚动位置，滚动速度设置/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/从ButterKnife-kt-了解Kotlin-委托与扩展/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/Gradle系列-引导篇（一）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/02/23/哈希表初识(一)/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 AndyJennifer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
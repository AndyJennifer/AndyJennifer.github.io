---
title: Java泛型的前世今生
tags:
  - 泛型
categories:
  - 泛型
---

### 前言

在 Java 中 `泛型` 好像一直都是比较难啃的骨头，会用的人总是得心应手，不会用的人总是抓耳挠腮，望而却步。泛型就像高考数学的最后一道大题，有的人总是能轻松的做对，甚至还能提前半个小时交卷。有的人只能帅气的写一个“解”

>我什么都不会，我“解”写的贼帅~

![好无奈.png](https://upload-images.jianshu.io/upload_images/2824145-fc79f6d4cfd5022f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

泛型难吗？说难也不难，说简单也简单。难的是你不知道前因后果。难的是我们知其然而不知其所以然。一知半解的这种状态，我知道你的内心是不甘的。

>心有不甘的同学，请把`不甘`打在评论区中。

为了帮助大家彻头彻尾的了解并使用泛型，故呕心沥血总结了泛型系列文章。 整个系列分为如下三个部分。

- Java 泛型的前世今生：追本溯源，探究 Java 为什么采用”擦除式"实现泛型。
- Java 泛型详解：详解 Java 泛型的擦除机制，通配符，及常见知识误区。
- Kotlin 中的泛型：详解 Kotlin 中泛型与 Java 的异同点，reified 的使用及原理

如果看了上述三篇文章，你还是不懂泛型。那么请你来打我。

![我有医保的.jpg](https://upload-images.jianshu.io/upload_images/2824145-5a3d7ecb1dd78281.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 泛型是什么

“一般的类和方法，只能使用具体的类型，要么是基本数据类型，要么是自定义的类，如果要编写应用于多种类型的代码，这种刻板的限制对代码的束缚就很大。"

虽然在Java中，也提供了一种`”多态"`的泛化机制，例如，你可以将方法的参数类型定义设为基类，那么该方法就可以接受从这个基类导出的任何子类作为参数。你也可以将方法的参数类型定义为接口，那么任何实现了该接口的类都能满足该方法。

有时候，拘泥于多态机制，也会使程序受限很多。我们希望达到的目的是更通用的代码，要使代码能够应用于`“某种不具体，不确定的类型"`。故`泛型`就此诞生了。泛型通过解耦类或方法与所使用的类型之间的约束，使类或方法具有更广泛的表达能力。

>本段落取自与《Think in Java》

![说人话.jpg](https://upload-images.jianshu.io/upload_images/2824145-bb7466aa091cfe79.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上述概念可能晦涩难懂，简单一句话概括。**泛型是一种”不确定“的类型，当你希望代码能够跨多个类使用，且不局限与多态时，你需要考虑使用泛型。**

### 为什么需要泛型

了解泛型的是什么，可能有的小伙伴觉得，不使用泛型，也能很好的写出具有”泛化“的代码啊。就拿 Java 来说，任意对象难道我就不能直接使用 Object 进行封装吗，在需要明确对象的时候，强制转换就行了啊！！

试想如下场景：我声明了一个 Collection (内部使用 Object[] 实现)用于存储 Apple 🍎对象，但是当我把这个 Collection 提供给其他人使用时，他人往这个集合中存储了 Banana 🍌，那当我把香蕉当苹果取的时候，会发生什么呢？你会得到一个 `ClassCastException` 异常。

那么有了泛型之后呢？我们可以这样声明:

```java
Collection<Apple>
```

这样就能告知他人，我这个集合是用来装 Apple 🍎 的，你不要乱存东西啊，你乱存东西，编译都不过的啊。

或许你会说，我难道就不能声明一个 AppleCollection 吗？那如果我有很多不同类型的对象，难道你也要创建一个 XXXCollection 吗？

咦，这好像一点不优雅吧。泛型都有如下优点了，为什么不使用呢？

- 泛型能减少了强制类型转换时的异常( `ClassCastException` )。
- 泛型能使程序可读性与稳定性更高。

### Java是如何实现泛型的

我们都知道 Java 是在 Java5 时支持泛型的。在 Java5 之前的版本中，集合容器（如 ArrayList、HashMap)都是使用上述 Object[] 的方式来存储数据的。增加了泛型后。那么 Java 必然要解决一个问题。如何解决老版本容器的泛型迁移？


解决方式：

- 第一种方案：需要泛型化的类型（主要是容器类型），一起有的就保持不变，然后平行的加一套泛型化版本的新类型：

- 第二套方案:直接把已有的类型泛型化，让所有需要泛型化的已有类型原地泛型化，不添加任何平行于有类型的泛型版：


从两方面
一方面，之前的集合容器都是使用 Object 那一套来写的，现在`ArrayList<T>`了，那是否是我需要增加一套泛型版本的新容器集合呢？

- java.util.ArrayList
- java.util.generic.ArrayList

举例说明，找不到包的问题，不好意思找不到包

Java 的架构师，抽了一根烟想了想。

![1_7825270.jpg](https://upload-images.jianshu.io/upload_images/2824145-fbea75c0f7ae866e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


好像不行，有问题。不允许，Java都从1.0 到5.0了，老子自己的库都维护不过来，更别说其他人的 Lib  了。算了算了，不能改。改了程序员们要骂死我。到时候公司追责下来，我个人绩效3.25事小。公司倒闭了事大。这画面太美，让我都想跳基你太美

另一方面，那我是否可以直接把已有的类型泛型化呢？也就是在原有的类的基础上，直接在原有的包下改为这样:

```java
//👇Java老版本
class ArrayList{}
//👇Java5泛型的
class ArrayList<T>{}
```

那么同理，Java必须要解决另一件事情：

```java
//👇Java老版本             👇Java5泛型的
ArrayList list = new ArrayList<String>();
list.add(Integer.valueof(1));
list.add("AndyJennifer");
```

但是我他妈证明知道有些程序是否是这样使用的呢，万一他就喜欢往 Object瞎几把乱存东西呢。那规定了泛型之后，你把类型给我限制死了，那之前我他妈没升级就没问题啊。也就是说，之前没有的限制，不能因为升级，就不能用了啊？



为什么Java不采用第一套方案：

修改的东西太多了，Java1.05已经有很多程序在跑了

举一个例子 A依赖B，B升级泛型了，用的是第一套方案，那么A如果要支持泛型的话，也必须修改代码。


会出现的问题：就是下面的代码。

```java
ArrayList list = new ArrayList<String>
```


Java 是采用类型擦除来实现泛型的

```java

```

因为相应泛型信息在对应Class文件中，已经被擦除到了泛型的边界，在实际代码中，我们并不能通过，如下代码判断类型：

```java
public class Demo<T> {
  public static  void f(Object arg){
      if(arg instanceof T){}//Error
  }
}

```

因为在声明泛型的Class文件中，Java 并不能像其他语言动态获取确切类型的信息 所以 Java 泛型被称为伪泛型的主要原因。

#### 逼不得已的类型擦除


这意味着它们只在编译时执行类型约束，并在运行时丢弃（或擦除）它们的元素类型信息。

导致Java 5引入的泛型采用擦除式实现的根本原因是兼容的取舍，而不是实现不了的问题。


### Java的类型擦除



#### 为什么要使用擦除来实现泛型

#### 类型检查

什么是类型安全

必然要进行检查。也就是编译的时候，检查传入的数据是否是相应类型，在调用出强转（这属于下节的问题，）

所以在Java实现泛化编程的时候，顺便也解决了类型安全的问题。

自 Java 5 以来，泛型已经成为该语言的一部分。 在泛型之前，你必须转换从集合中读取的每个对象。 如果有人不小心插入了错误类型的对象，则在运行时可能会失败。 使用泛型，你告诉编译器在每个集合中允许哪些类型的对象。 编译器会自动插入强制转换，并在编译时告诉你是否尝试插入错误类型的对象。 这样做的结果是既安全又清晰的程序，但这些益处，不限于集合，是有代价的。 本章告诉你如何最大限度地提高益处，并将并发症降至最低。

泛型被引入到Java语言中，以便在编译时提供更严格的类型检查并支持泛型编程。为了实现泛型，Java编译器将类型擦除应用于：

```java


```

泛型在集合中，可以避免类型安全的问题。

- 先检查代码中的泛型
- 进行类型擦除，并插入自动转换。


### Java 泛型未来的展望及规划

Java是否能实现真的泛型，答案是有可能

https://www.zhihu.com/question/48061253/answer/108906072
![108_be961313427813fdfd8866eea43acb9d.png](https://upload-images.jianshu.io/upload_images/2824145-bb820ff036c98a69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)




### 知识问答


#### Java伪泛型伪在哪里

首先在文章之前，我们已经解释了泛型的语意以及其作用，通过全观Java中的泛型使用，我们能发现Java其实已经做到了“泛型”的基本要求，究其根本，很多人说Java是伪泛型，难道就是因为它的类型擦除吗？难道就因为我不能知道确切类型的信息，你就说我是伪的？

难道像C# 其他语言那样为参数化类型创建新类，就是真的泛型吗？

仔细一想，好像 Java 还少创建了中间类，减少了运行时的一些开销，难道这又是另一种优化？

首先在文章之前，我们已经解释了泛型的语意以及其作用，通过全观Java中的泛型使用，我们能发现Java其实已经做到了“泛型”的基本要求，究其根本，很多人说Java是伪泛型，难道就是因为它的类型擦除吗？难道就因为我不能知道确切类型的信息，你就说我是伪的？

难道像C# 其他语言那样为参数化类型创建新类，就是真的泛型吗？

仔细一想，好像 Java 还少创建了中间类，减少了运行时的一些开销，难道这又是另一种优化？


## 最后

站在巨人的肩膀上，才能看的更远~

- https://www.cnblogs.com/leyangzi/p/11379525.html
- https://juejin.im/post/5d6c6636f265da03c8153a03
- http://java.sun.com/docs/books/tutorial/java/generics/erasure.html
- http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html
- https://www.zhihu.com/question/28665443/answer/118148143
- 《Think in Java》
- 《Effective Java》

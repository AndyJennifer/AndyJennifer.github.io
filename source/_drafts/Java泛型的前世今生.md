---
title: Java泛型的前世今生
tags:
  - 泛型
categories:
  - 泛型
---

## 前言

在 Java 中泛型好像一直都是比较难啃的骨头，会用的人总是得心应手，不会用的人总是抓耳挠腮，望而却步。泛型就像高考数学的最后一道大题，有的人总是能轻松的做对，甚至还能提前半个小时交卷。有的人只能帅气的写一个“解”

>我什么都不会，我“解”写的贼帅~

![好无奈.png](https://upload-images.jianshu.io/upload_images/2824145-fc79f6d4cfd5022f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

泛型难吗？说难也不难，说简单也简单。难的是你不知道前因后果。难的是我们知其然而不知其所以然。一知半解的这种状态，我知道你的内心是不甘的。

>心有不甘的同学，请把`不甘`打在评论区中。

那现在现在机会来了，赶快上车。为了帮助大家彻头彻尾的了解并使用泛型，故呕心沥血总结了泛型系列文章。 整个系列分为如下三个部分。

- Java 泛型的前世今生
  - Java 是否可以实现真正的泛型
  - Java 为什么要使用擦除来实现泛型
  - Java 泛型未来的展望及规划
- Java 泛型详解
  - 详细讲解Java泛型的擦除机制
  - 讲解Java泛型的通配符
  - 讲解Java泛型中使用中一些比较难懂的知识点(泛型信息真的被擦除了吗？)
- Kotlin中的泛型
  - Kotlin 中泛型与Java的异同点。
  - Kotlin reified 的使用及原理

如果看了上述三篇文章，你还是不懂泛型。那么请你来打我。

![我有医保的.jpg](https://upload-images.jianshu.io/upload_images/2824145-5a3d7ecb1dd78281.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 泛型是什么

“一般的类和方法，只能使用具体的类型，要么是基本数据类型，要么是自定义的类，如果要编写应用于多种类型的代码，这种刻板的限制对代码的束缚就很大。"

虽然在Java中，也提供了一种`”多态"`的泛化机制，例如，你可以将方法的参数类型定义设为基类，那么该方法就可以接受从这个基类导出的任何子类作为参数。你也可以将方法的参数类型定义为接口，那么任何实现了该接口的类都能满足该方法。

有时候，拘泥于多态机制，也会使程序受限很多。我们希望达到的目的是更通用的代码，要使代码能够应用于`“某种不具体，不确定的类型"`。故`泛型`就此诞生了。泛型通过解耦类或方法与所使用的类型之间的约束，使类或方法具有更广泛的表达能力。

>本段落取至于《Think in Java》

当你希望代码能够跨多个类使用，且不局限与多态时，你需要考虑使用泛型。



首先在文章之前，我们已经解释了泛型的语意以及其作用，通过全观Java中的泛型使用，我们能发现Java其实已经做到了“泛型”的基本要求，究其根本，很多人说Java是伪泛型，难道就是因为它的类型擦除吗？难道就因为我不能知道确切类型的信息，你就说我是伪的？

难道像C# 其他语言那样为参数化类型创建新类，就是真的泛型吗？

仔细一想，好像 Java 还少创建了中间类，减少了运行时的一些开销，难道这又是另一种优化？


### 

第一种方案：
需要泛型化的类型（主要是容器类型），一起有的就保持不变，然后平行的加一套泛型化版本的新类型：

第二套方案:
直接把已有的类型泛型化，让所有需要泛型化的已有类型原地泛型化，不天剑任何平行于有类型的泛型版：


为什么Java不采用第一套方案：

修改的东西太多了，Java1.05已经有很多程序在跑了

举一个例子 A依赖B，B升级泛型了，用的是第一套方案，那么A如果要支持泛型的话，也必须修改代码。


会出现的问题：就是下面的代码。
```java
ArrayList list =new ArrayList<String>
```

### Java的类型擦除

### 为什么要采用擦除的方式实现泛型

导致Java 5引入的泛型采用擦除式实现的根本原因是兼容的取舍，而不是实现不了的问题。

### 什么是类型安全

  
所以在Java实现泛化编程的时候，顺便也解决了类型安全的问题。

自 Java 5 以来，泛型已经成为该语言的一部分。 在泛型之前，你必须转换从集合中读取的每个对象。 如果有人不小心插入了错误类型的对象，则在运行时可能会失败。 使用泛型，你告诉编译器在每个集合中允许哪些类型的对象。 编译器会自动插入强制转换，并在编译时告诉你是否尝试插入错误类型的对象。 这样做的结果是既安全又清晰的程序，但这些益处，不限于集合，是有代价的。 本章告诉你如何最大限度地提高益处，并将并发症降至最低。

泛型被引入到Java语言中，以便在编译时提供更严格的类型检查并支持泛型编程。为了实现泛型，Java编译器将类型擦除应用于：

```java


```

泛型在集合中，可以避免类型安全的问题。

- 先检查代码中的泛型
- 进行类型擦除，并插入自动转换。

这意味着它们只在编译时执行类型约束，并在运行时丢弃（或擦除）它们的元素类型信息。

  ### Java是否能实现真的泛型

## 最后

//    https://www.cnblogs.com/leyangzi/p/11379525.html
//    https://juejin.im/post/5d6c6636f265da03c8153a03
//    http://java.sun.com/docs/books/tutorial/java/generics/erasure.html

http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html

https://www.zhihu.com/question/28665443/answer/118148143
《Think in Java》
《Effective Java》
站在巨人的肩膀上，才能看的更远~

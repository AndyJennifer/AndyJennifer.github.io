---
title: 泛型的前世今生
tags:
  - 泛型
categories:
  - 泛型
---

## 前言

好像泛型一直是比较难啃的骨头，本文针对那些对泛型有疑惑，

- 解决泛型的错误认知。
- 会简单的使用泛型，但是不知道怎么约束。
- 泛型的内部实现原理

这篇文章是干什么的，解决了什么问题。对大家有什么帮助，还有其他什么内容扩展的

## 泛型是什么

“一般的类和方法，只能使用具体的类型，要么是基本数据类型，要么是自定义的类，如果要编写应用于多种类型的代码，这种刻板的限制对代码的束缚就很大。"

虽然在Java中，也提供了一种`”多态"`的泛化机制，例如，你可以将方法的参数类型定义设为基类，那么该方法就可以接受从这个基类导出的任何子类作为参数。你也可以将方法的参数类型定义为接口，那么任何实现了该接口的类都能满足该方法。

有时候，拘泥于多态机制，也会使程序受限很多。我们希望达到的目的是更通用的代码，要使代码能够应用于`“某种不具体，不确定的类型"`。故`泛型`就此诞生了。泛型通过解耦类或方法与所使用的类型之间的约束，使类或方法具有更广泛的表达能力。

>本段落取至于《Think in Java》

当你希望代码能够跨多个类使用，且不局限与多态时，你需要考虑使用泛型。

### 泛型相关术语

泛型的相关术语

类型参数：
泛型类或泛型接口：
泛型类型：泛型类和接口统称为泛型类型

泛型的整体结构：

每个泛型定义了一组参数化类型（parameterized types），它们由类或接口名称组成，后跟一个与泛型类型的形式类型参数[JLS，4.4,4.5] 相对应的实际类型参数的尖括号「<>」列表。 例如，List<String>（读作「字符串列表」）是一个参数化类型，表示其元素类型为 String 的列表

形式类型参数：
实际类型参数：

 （String 是与形式类型参 数 E 相对应的实际类型参数）。

|术语|中文含义|举例|
|:--:|:--:|:--:|
|Parameterized type|参数化类型|`List<String>`|
|Actual type parameter|实际类型参数|`String`|
|Generic type|泛型类型|`List<E>`|
|Formal type parameter|形式类型参数|`E`|
|Unbounded wildcard type|无限制通配符类型|`List<?>`|
|Raw type|原始类型|`List`|条目 26|
|Bounded type parameter|限制类型参数|`<E extends Number>`|
|Recursive type bound|递归类型限制|`<T extends Comparable<T>>`|
|Bounded wildcard type|限制通配符类型|`List<? extends Number>`|
|Generic method|泛型方法|`static <E> List<E> asList(E[] a)`|
|Type token|类型令牌|`String.class`|

### 简单的泛型理解

## Java中泛型的实现

在 Java 中泛型的实现，主要分为如下三个步骤：

- 将泛型类型中的类型参数信息擦除，使泛型类型转换为原始类型。
- 将类型参数擦除到它的第一个边界
- 对泛型类型传递出去的值进行自动转型。

下面会对这三个步骤进行详细的讲解。

### 类型擦除

这里所指的”类型擦除“其实是指在 Java 编译器在`编译期间`将`泛型类型`中的类型参数信息擦除，使 `泛型类型` 转换为 `原始类型` 。

>`原始类型(Raw type)`是指擦除了`泛型类型`擦除了`类型参数信息`，最后在字节码中的类型变量的真正类型。如 `List<Object>` 与 `List<String>` 其原始类型为 `List`。

![擦除到原始类型.png](https://upload-images.jianshu.io/upload_images/2824145-057039def77958bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

证明了，是擦除到原始类型。

👆上图中的类型擦除

```java
 Demo<String> 擦除为 Demo
```

### 擦除到边界

#### 非限制类型擦除

类型变量在未指定边界的情况下，将被擦除为Object

![擦除到Object.png](https://upload-images.jianshu.io/upload_images/2824145-92a1c1122e05a13c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

介绍一下字节码加载指令

字节码的泛型是反射和 debug 时用的（获取当然也只能通过反射），泛型擦除在编译器发生这个说法没问题，而且运行时 JVM 不会使用到 class 常量池中的泛型

#### 限制类型擦除与自动转换

<T extends String> 擦除到String，举例说明


讲讲自动插入的类型转换。

#### 自动类型转换

接着在自动类型转换。


因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？看下ArrayList和get方法：

最后，每个泛型定义了一个原始类型（raw type），它是没有任何类型参数的泛型类型的名称[JLS，4.8]。 例如，对应于 List<E> 的原始类型是 List。 原始类型的行为就像所有的泛型类型信息都从类型声明中被清除一样。 它们的存在主要是为了与没有泛型之前的代码相兼容。

有些人说Java是伪泛型，

首先在文章之前，我们已经解释了泛型的语意以及其作用，通过全观Java中的泛型使用，我们能发现Java其实已经做到了“泛型”的基本要求，究其根本，很多人说Java是伪泛型，难道就是因为它的类型擦除吗？难道就因为我不能知道确切类型的信息，你就说我是伪的？

难道像C# 其他语言那样为参数化类型创建新类，就是真的泛型吗？

仔细一想，好像 Java 还少创建了中间类，减少了运行时的一些开销，难道这又是另一种优化？

所以，不要在称Java 为伪泛型了。

#### 擦除后

泛型类型内部是无法获取有关泛型参数的类型信息

#### 仍然可以获取到泛型信息

需要注意的是这里的擦除只是对代码中的泛型类型擦除，对于实际上使用泛型类型的类其泛型信息仍然保留在对于的Class 文件中。只是这类信息是提供给 `Java 编译器` 及反射时使用的。具体规范官方有更详细的描述-->[Signatures](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.4)
只是对泛型类型的参数信息进行擦除，对使用泛型类型的类，可以通过反射，获取泛型的实际类型参数。

https://www.cnblogs.com/fanweisheng/p/11136868.html

## 为什么要擦除

兼容，方便？举例C#的列子


泛型出现原因及作用

导致泛型出现的原因有许多，但是最引入注入的原因是创建了”容器类",因为创建了容器类，所以我们无法持有其他类型的任何对象，没有必要为每个类型都编写一个新的类。

某些情况下，我们确实洗完容器同时持有多种类型的对象，但是通常而言，我们会使用容器来存储一种类型的对象，泛型的主要目的之一就是用来指定容器需要持有什么类型的对象，而且由编译器来保证类型的正确性。

这样做的目的，是减少了使用Object对象，强制类型导致的异常，将对象的检查放到了编译时期（将运行时异常，准换到了编译时异常）

类型安全？：指不会抛出强制转换异常，可以使用@SafeVararges

### 什么是类型安全

  
所以在Java实现泛化编程的时候，顺便也解决了类型安全的问题。

自 Java 5 以来，泛型已经成为该语言的一部分。 在泛型之前，你必须转换从集合中读取的每个对象。 如果有人不小心插入了错误类型的对象，则在运行时可能会失败。 使用泛型，你告诉编译器在每个集合中允许哪些类型的对象。 编译器会自动插入强制转换，并在编译时告诉你是否尝试插入错误类型的对象。 这样做的结果是既安全又清晰的程序，但这些益处，不限于集合，是有代价的。 本章告诉你如何最大限度地提高益处，并将并发症降至最低。

泛型被引入到Java语言中，以便在编译时提供更严格的类型检查并支持泛型编程。为了实现泛型，Java编译器将类型擦除应用于：

```java


```

泛型在集合中，可以避免类型安全的问题。

- 先检查代码中的泛型
- 进行类型擦除，并插入自动转换。

## 利用有界通配符来提升API的灵活性

https://github.com/sjsdfg/effective-java-3rd-chinese/blob/master/docs/notes/31. 使用限定通配符来增加API的灵活性.md

### 通配符

通配符只适用于变量，或方法参数，

#### 上界通配符(协变)

#### 下界通配符(逆变)

#### 无界通配符

? 与 ? extend  Object 的区别

List<?> 与List有什么区分，前者不能存null，

## 泛型与数组的关系

为什么不能创建一个泛型数组？？？

为什么创建一个泛型数组是非法的？ 因为它不是类型安全的。 如果这是合法的，编译器生成的强制转换程序在运行时可能会因为 ClassCastException 异常而失败。 这将违反泛型类型系统提供的基本保证。


```
T[] = new Int[];
```

数组和泛型之间的第二个主要区别是数组被具体化了（reified）[JLS，4.7]。 这意味着数组在运行时知道并强制执行它们的元素类型。 如前所述，如果尝试将一个 String 放入 Long 数组中，得到一个 ArrayStoreException 异常。 相反，泛型通过擦除（erasure）来实现[JLS，4.6]。 这意味着它们只在编译时执行类型约束，并在运行时丢弃（或擦除）它们的元素类型信息。 **擦除是允许泛型类型与不使用泛型的遗留代码自由互操作**（详见第 26 条），从而确保在 Java 5 中平滑过渡到泛型。

实际上引入泛型的主要目标有以下几点：

类型安全
泛型的主要目标是提高 Java 程序的类型安全
编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常
符合越早出错代价越小原则
消除强制类型转换
泛型的一个附带好处是，使用时直接得到目标类型，消除许多强制类型转换
所得即所需，这使得代码更加可读，并且减少了出错机会
潜在的性能收益
由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改
所有工作都在编译器中完成
编译器生成的代码跟不使用泛型（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已

## 总结

如果类型参数是无限的，则将泛型类型中的所有类型参数替换为其边界或对象。因此，生成的字节码只包含普通类、接口和方法。
必要时插入类型转换以保持类型安全。
生成桥方法以保留扩展泛型类型中的多态性。
类型擦除确保不会为参数化类型创建新类；因此，泛型不会产生运行时开销。当然这个是本文下节要描述的内容。

## Kotlin 相关知识点

kotlin中泛型不可忽略的，Java可以忽略，但是Kotlin必须要显示泛型

## 最后

//    https://www.cnblogs.com/leyangzi/p/11379525.html
//    https://juejin.im/post/5d6c6636f265da03c8153a03
//    http://java.sun.com/docs/books/tutorial/java/generics/erasure.html

《Think in Java》
《Effective Java》
站在巨人的肩膀上，才能看的更远~

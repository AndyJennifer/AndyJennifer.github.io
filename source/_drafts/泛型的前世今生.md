---
title: 泛型的前世今生
tags:
  - 泛型
categories:
  - 泛型
---

### 前言

### 泛型是什么

“一般的类和方法，只能使用具体的类型，要么是基本数据类型，要么是自定义的类，如果要编写应用于多种类型的代码，这种刻板的限制对代码的束缚就很大。"

虽然在Java中，也提供了一种`”多态"`的泛化机制，例如，你可以将方法的参数类型定义设为基类，那么该方法就可以接受从这个基类导出的任何子类作为参数。你也可以将方法的参数类型定义为接口，那么任何实现了该接口的类都能满足该方法。

有时候，拘泥于多态机制，也会使程序受限很多。我们希望达到的目的是更通用的代码，要使代码能够应用于`“某种不具体，不确定的类型"`。故`泛型`就此诞生了。泛型通过解耦类或方法与所使用的类型之间的约束，使类或方法具有更广泛的表达能力。

>本段落取至于《Think in Java》

当你希望代码能够跨多个类使用，且不局限与多态时，你需要考虑使用泛型。

这篇文章算对扔物线老师的《》文章的一些知识点的补充与扩展。

### 泛型相关是属于

http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/26. 不要使用原始类型


泛型的相关术语

类型参数：
泛型类或泛型接口：
泛型类型：泛型类和接口统称为泛型类型

泛型的整体结构：

每个泛型定义了一组参数化类型（parameterized types），它们由类或接口名称组成，后跟一个与泛型类型的形式类型参数[JLS，4.4,4.5] 相对应的实际类型参数的尖括号「<>」列表。 例如，List<String>（读作「字符串列表」）是一个参数化类型，表示其元素类型为 String 的列表

形式类型参数：
实际类型参数：

 （String 是与形式类型参数 E 相对应的实际类型参数）。

### 泛型出现原因及作用

导致泛型出现的原因有许多，但是最引入注入的原因是创建了”容器类",因为创建了容器类，所以我们无法持有其他类型的任何对象，没有必要为每个类型都编写一个新的类。


某些情况下，我们确实洗完容器同时持有多种类型的对象，但是通常而言，我们会使用容器来存储一种类型的对象，泛型的主要目的之一就是用来指定容器需要持有什么类型的对象，而且由编译器来保证类型的正确性。

这样做的目的，是减少了使用Object对象是，强制类型导致的异常，将对象的检查放到了编译时期（将运行时异常，准换到了编译时异常）

类型安全？：指不会抛出强制转换异常，可以使用@SafeVararges


### 什么是类型安全

在 Java SE5之前，我们可以使该类持有Object类型的对象。

　　自 Java 5 以来，泛型已经成为该语言的一部分。 在泛型之前，你必须转换从集合中读取的每个对象。 如果有人不小心插入了错误类型的对象，则在运行时可能会失败。 使用泛型，你告诉编译器在每个集合中允许哪些类型的对象。 编译器会自动插入强制转换，并在编译时告诉你是否尝试插入错误类型的对象。 这样做的结果是既安全又清晰的程序，但这些益处，不限于集合，是有代价的。 本章告诉你如何最大限度地提高益处，并将并发症降至最低。

```java

```

### 类型擦除

很多人把 ”泛型类型擦除"，称之为“泛型的擦除”。这种对Java的泛型的设计的描述是不符的。如果 Java 真的是在编译时期间将泛型擦除，那是怎么做到泛化类型编程的呢？

//    https://www.cnblogs.com/leyangzi/p/11379525.html

编译之前先擦除，然后再检查。

### 为什么称Java是伪泛型

有些人说Java是伪泛型，

首先在文章之前，我们已经解释了泛型的语意以及其作用，通过全观Java中的泛型使用，我们能发现Java其实已经做到了“泛型”的基本要求，究其根本，很多人说Java是伪泛型，难道就是因为它的类型擦除吗？难道就因为我不能知道确切类型的信息，你就说我是伪的？

难道像C# 其他语言那样为参数化类型创建新类，就是真的泛型吗？

仔细一想，好像 Java 还少创建了中间类，减少了运行时的一些开销，难道这又是另一种优化？

所以，不要在称Java 为伪泛型了。


#### 自动类型转换

接着在自动类型转换。


因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？看下ArrayList和get方法：

最后，每个泛型定义了一个原始类型（raw type），它是没有任何类型参数的泛型类型的名称[JLS，4.8]。 例如，对应于 List<E> 的原始类型是 List。 原始类型的行为就像所有的泛型类型信息都从类型声明中被清除一样。 它们的存在主要是为了与没有泛型之前的代码相兼容。

### 利用有界通配符来提升API的灵活性

https://github.com/sjsdfg/effective-java-3rd-chinese/blob/master/docs/notes/31. 使用限定通配符来增加API的灵活性.md

#### 通配符

#### 上界通配符(协变)

#### 下界通配符(逆变)

#### 无界通配符

? 与 ? extend  Object 的区别

List<?> 与List有什么区分，前者不能存null，

### 泛型与数组的关系

为什么不能创建一个泛型数组？？？


为什么创建一个泛型数组是非法的？ 因为它不是类型安全的。 如果这是合法的，编译器生成的强制转换程序在运行时可能会因为 ClassCastException 异常而失败。 这将违反泛型类型系统提供的基本保证。


```
T[] = new Int[];
```

数组和泛型之间的第二个主要区别是数组被具体化了（reified）[JLS，4.7]。 这意味着数组在运行时知道并强制执行它们的元素类型。 如前所述，如果尝试将一个 String 放入 Long 数组中，得到一个 ArrayStoreException 异常。 相反，泛型通过擦除（erasure）来实现[JLS，4.6]。 这意味着它们只在编译时执行类型约束，并在运行时丢弃（或擦除）它们的元素类型信息。 **擦除是允许泛型类型与不使用泛型的遗留代码自由互操作**（详见第 26 条），从而确保在 Java 5 中平滑过渡到泛型。

实际上引入泛型的主要目标有以下几点：

类型安全 
泛型的主要目标是提高 Java 程序的类型安全
编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常
符合越早出错代价越小原则
消除强制类型转换 
泛型的一个附带好处是，使用时直接得到目标类型，消除许多强制类型转换
所得即所需，这使得代码更加可读，并且减少了出错机会
潜在的性能收益 
由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改
所有工作都在编译器中完成
编译器生成的代码跟不使用泛型（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已



### 总结


泛型被引入到Java语言中，以便在编译时提供更严格的类型检查并支持泛型编程。为了实现泛型，Java编译器将类型擦除应用于：

如果类型参数是无限的，则将泛型类型中的所有类型参数替换为其边界或对象。因此，生成的字节码只包含普通类、接口和方法。
必要时插入类型转换以保持类型安全。
生成桥方法以保留扩展泛型类型中的多态性。
类型擦除确保不会为参数化类型创建新类；因此，泛型不会产生运行时开销。

### Kotlin 相关知识点

kotlin中泛型不可忽略的，Java可以忽略，但是Kotlin必须要显示泛型

### 最后

//    https://www.cnblogs.com/leyangzi/p/11379525.html
//    https://juejin.im/post/5d6c6636f265da03c8153a03
//    http://java.sun.com/docs/books/tutorial/java/generics/erasure.html

《Think in Java》
《Effective Java》
站在巨人的肩膀上，才能看的更远~

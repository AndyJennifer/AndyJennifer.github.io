---
title: ' Java并发编程之线程篇之线程简介(一)'
tags:
- 线程
categories:
- 线程篇
---

### 前言
集合Java内存模型，JVM中的程序计数器。

### 什么是进程和线程？
在了解协程之前，我们需要知道进程和线程的概念。

#### 进程
简单通俗的来讲，进程就是应用程序的启动实例。在操作系统中，用进程来表示每一个程序，每个进程对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程空间互不干扰。同时操作系统也为每个进程保存了程序每个时刻的运行状态。

这样就为程序间的切换提供了可能性。当某个进程暂停时，操作系统会保存当前进程的状态（比如进程标识、进程的使用的资源等），在下一次重新切换回来时，便根据之前保存的状态进行恢复，然后继续执行。

#### 线程
进程的出现确实提高了计算机的运行效率。但是单单使用进程来处理程序的并发的弊端越来越明显。

- 进程是资源的拥有者，在创建、撤销、切换操作中需要较大的时空开销，限制了并发程度的进一步提高。
- 进程在一个时间段内，只能做一件事情。如果一个进程有多个任务，只能逐个执行这些任务。

所以，为了解决这些弊端，聪明的人儿们又进一步的发明了更轻量级进程——`线程`。将进程的资源分布和执行调度分开，各个线程既可以共享进程资源（内存地址，文件	I/O等）又可以独立的被操作系统调度。进程与线程的关系如下图所示：
.
![进程线程的关系.png](https://upload-images.jianshu.io/upload_images/2824145-c9331166fee59a5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





#### 线程的实现方式
在操作系统中，实现线程主要有三种方式：使用内核线程实现，使用用户线程实现和使用用户线程加轻量级进程混合实现。在下文中，会着重讲解前两种的线程实现方式。

##### 使用内核线程实现
内核线程（Kernel-level Thread KLT)就是直接由操作系统内核(Kernel 下称内核)支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器（Scheduler)对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身。这样操作系统就有能力同时处理多件事件。支持多线程的内核就叫做多线程内核（Multi-Thread Kernel)。

程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程(Light Weight Process，LWP)，轻量级进程就是我们通常意义上所讲的线程。由于某个轻量级进程都有一个内核线程支持，因此只有先支持内核线程。才能有轻量级进程。这种轻量级进程和内核线程之间1:1的关系称为一对一的线程模型，如下图所示：

![轻量级进程与内核线程模型.png](https://upload-images.jianshu.io/upload_images/2824145-434cae9398a1c4d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

由于内核线程的支持，每个轻量级进程都会称为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程也有它的局限性。首先基于内核线程实现的。所以在线程操作，如创建、析构及同步，都需要进行系统调用，而系统调用的代价相对较高，需要在用户态和内核态中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。

##### 使用用户线程实现
从广义上讲，一个线程只要不是内核线程，就可以认为是用户线程，因此从这个定义上来讲，轻量级进程也属于用户线程，但轻量级进程的实现始终都是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制。而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到线程存在的实现，用户线程的建立、同步、销毁和调度完全建立在用户态中完成，而不需要内核的帮助。

如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低耗的。也可以支持规模更大的线程数量，这种进程和用户线程之间1：N的关系称为一对多的线程模型。

![用户线程模型.png](https://upload-images.jianshu.io/upload_images/2824145-32c77ec73ebbddf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

使用用户线程的优势在与不需要系统内核支援，劣势也在与没有系统内核的支持，所有的线程操作都需要用户程序自己处理。线程的创建、切换、和调度都是需要考虑的问题。

### 线程的应用场景

### 多线程一定快吗？
有了线程之后，大家可能会觉得，程序就应该跑的很快了。当我们需要执行多个任务的时候，我们完全可以创建多个线程来执行相应的任务就行了啊，时间肯定比一个线程执行来的快呢！具体情况如下图所示：

![单线程多线程执行情况.png](https://upload-images.jianshu.io/upload_images/2824145-ec46ccf2e62bfd82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
从上图来看，好像创建多个线程来执行任务确实是比一个线程串行执行任务所花费的时间短，但是并不是所有的情况都是启动更多的线程就能让程序最大的并发执行。虽然我们的初衷是多线程执行任务让程序运行的更快。但是这样任然又许多的问题需要处理。比如上下文切换的问题。

#### 上下文的切换

对于单核CPU来说（对于多核CPU，此时就理解为一个核），CPU在一个时刻只能运行一个线程。CPU为了实现多线程的机制，通过时间片分配算法来循环执行任务时，当前线程执行一个时间片后会切换到下一个线程，但是在切换前会保持上一个线程的状态。以便下次切换回这个线程时，可以获取这个线程的状态，所以线程从保存再到加载到过程就是一次上下文切换。


>时间片是cpu分配给每个线程执行的时间，因为时间非常短，所以CPU通过不断的切换线程执行，让我们感觉到多个线程是同时执行的。时间片一般是几十毫秒每秒。

为了让大家实际了解线程的上下文的切换的开销。那么下面我们就看下面的这个例子：
```
class ConcurrencyTest {

    private static final long count = 100000000;

    public static void main(String[] args) throws InterruptedException {
        concurrency();
        serial();

    }

    private static void concurrency() throws InterruptedException {
        long start = System.nanoTime();
        //任务1
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                int a = 0;
                for (long i = 0; i < count; i++) {
                    a += 5;
                }
            }
        });
        thread.start();

        //任务2
        int b = 0;
        for (long i = 0; i < count; i++) {
            b--;
        }
        thread.join();//当前main线程等待thread线程终止之后才从thread.join()返回

        //计算时间
        long time = System.nanoTime() - start;
        System.out.println("concurrency :" + time + "ns,b=" + b);
    }

    private static void serial() {
        long start = System.nanoTime();
        int a = 0;
        for (long i = 0; i < count; i++) {
            a += 5;
        }
        int b = 0;
        for (long i = 0; i < count; i++) {
            b--;
        }
        long time = System.nanoTime() - start;
        System.out.println("serial:" + time + "ns,b=" + b + ",a=" + a);
    }
}
```
在上述代码中，我将两个for循环中的内容，分别定义为任务1与任务2。我动态的修改循环的次数，可以得到图表：

![测试结果.png](https://upload-images.jianshu.io/upload_images/2824145-4be2939ed81c8e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从上表中我们可以看出，当循环次数不超过一百万次时，串行的执行速度始终比并发执行的速度快。也就验证了线程的创建和上下文的切换确实是有开销的。

### 如何解决上下文切换的开销？
在多线程的情况下，因为有线程的上下文切换。可能多线程的执行速度还没有串行执行的快。那么我们有不有办法解决这个问题呢？终于到我们的重头戏了，那就是使用协程，使用协程后，我们可以在单线程的模型下，实现多任务的调度，并在单线程里维持多个任务的切换。那使用协程就能减少线程上下文的开销了？你个糟老头，坏的很。你告诉我协程到底是什么东西啊！不急不急，在了解协程原理之前，我们要先了解操作系统中的线程实现方式。


### 最后
站在巨人的肩膀上，才能看的更远~

[线程的发展历史](https://segmentfault.com/a/1190000017252672)
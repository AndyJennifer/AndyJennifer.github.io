---
title: Android-æ³¨è§£ç³»åˆ—ä¹‹EventBusç´¢å¼•ç±»ï¼ˆäº”ï¼‰
tags:
  - null
categories:
  - null
---

### å‰è¨€

>å¯¹ APT æŠ€æœ¯ä¸ç†Ÿæ‚‰çš„å°ä¼™ä¼´ï¼Œå¯ä»¥æŸ¥çœ‹æ–‡ç« Android-æ³¨è§£ç³»åˆ—ä¹‹APTå·¥å…·(ä¸‰) æ–‡ç« ç†Ÿæ‚‰çš„è¯ï¼Œ


### å…³é”®ä»£ç 

```java
   private SubscriberInfo getSubscriberInfo(FindState findState) {
        if (findState.subscriberInfo != null && findState.subscriberInfo.getSuperSubscriberInfo() != null) {
            SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();
            if (findState.clazz == superclassInfo.getSubscriberClass()) {
                return superclassInfo;
            }
        }
        //å¦‚æœç´¢å¼•ç±»ä¸ä¸ºnull,é‚£ä¹ˆä¼šè·å–ç´¢å¼•ç±»ä¸­çš„ä¿¡æ¯
        if (subscriberInfoIndexes != null) {
            for (SubscriberInfoIndex index : subscriberInfoIndexes) {
                SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
                if (info != null) {
                    return info;
                }
            }
        }
        return null;
    }

```

å…¶å®è¿™é‡ŒEventBus é€šè¿‡ APT æŠ€æœ¯ï¼Œåœ¨ç¨‹åºç¼–è¯‘æœŸé—´å¯¹ æºæ–‡ä»¶ä¸­çš„æ³¨è§£è¿›è¡Œäº†è§£æï¼Œè¿™æ ·å°±çœå»äº†åå°„æ—¶ï¼ŒæŸ¥æ‰¾å¯¹åº”æ–¹æ³•æ‰€äº§ç”Ÿçš„è€—æ—¶å•¦ã€‚


```java
@Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
        Messager messager = processingEnv.getMessager();
        try {
            String index = processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX);
            if (index == null) {
                messager.printMessage(Diagnostic.Kind.ERROR, "No option " + OPTION_EVENT_BUS_INDEX +
                        " passed to annotation processor");
                return false;
            }
            verbose = Boolean.parseBoolean(processingEnv.getOptions().get(OPTION_VERBOSE));
            int lastPeriod = index.lastIndexOf('.');
            String indexPackage = lastPeriod != -1 ? index.substring(0, lastPeriod) : null;

            round++;
            if (verbose) {
                messager.printMessage(Diagnostic.Kind.NOTE, "Processing round " + round + ", new annotations: " +
                        !annotations.isEmpty() + ", processingOver: " + env.processingOver());
            }
            if (env.processingOver()) {
                if (!annotations.isEmpty()) {
                    messager.printMessage(Diagnostic.Kind.ERROR,
                            "Unexpected processing state: annotations still available after processing over");
                    return false;
                }
            }
            if (annotations.isEmpty()) {
                return false;
            }

            if (writerRoundDone) {
                messager.printMessage(Diagnostic.Kind.ERROR,
                        "Unexpected processing state: annotations still available after writing.");
            }
            collectSubscribers(annotations, env, messager);
            checkForSubscribersToSkip(messager, indexPackage);

            if (!methodsByClass.isEmpty()) {
                createInfoIndexFile(index);
            } else {
                messager.printMessage(Diagnostic.Kind.WARNING, "No @Subscribe annotations found");
            }
            writerRoundDone = true;
        } catch (RuntimeException e) {
            // IntelliJ does not handle exceptions nicely, so log and print a message
            e.printStackTrace();
            messager.printMessage(Diagnostic.Kind.ERROR, "Unexpected error in EventBusAnnotationProcessor: " + e);
        }
        return true;
    }
```

```java
    private void createInfoIndexFile(String index) {
        BufferedWriter writer = null;
        try {
            JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(index);
            int period = index.lastIndexOf('.');
            String myPackage = period > 0 ? index.substring(0, period) : null;
            String clazz = index.substring(period + 1);
            writer = new BufferedWriter(sourceFile.openWriter());
            if (myPackage != null) {
                writer.write("package " + myPackage + ";\n\n");
            }
            writer.write("import org.greenrobot.eventbus.meta.SimpleSubscriberInfo;\n");
            writer.write("import org.greenrobot.eventbus.meta.SubscriberMethodInfo;\n");
            writer.write("import org.greenrobot.eventbus.meta.SubscriberInfo;\n");
            writer.write("import org.greenrobot.eventbus.meta.SubscriberInfoIndex;\n\n");
            writer.write("import org.greenrobot.eventbus.ThreadMode;\n\n");
            writer.write("import java.util.HashMap;\n");
            writer.write("import java.util.Map;\n\n");
            writer.write("/** This class is generated by EventBus, do not edit. */\n");
            writer.write("public class " + clazz + " implements SubscriberInfoIndex {\n");
            writer.write("    private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;\n\n");
            writer.write("    static {\n");
            writer.write("        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();\n\n");
            //ğŸ‘‡è¿™é‡Œæ˜¯å…³é”®çš„ä»£ç 
            writeIndexLines(writer, myPackage);
            writer.write("    }\n\n");
            writer.write("    private static void putIndex(SubscriberInfo info) {\n");
            writer.write("        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);\n");
            writer.write("    }\n\n");
            writer.write("    @Override\n");
            writer.write("    public SubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {\n");
            writer.write("        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);\n");
            writer.write("        if (info != null) {\n");
            writer.write("            return info;\n");
            writer.write("        } else {\n");
            writer.write("            return null;\n");
            writer.write("        }\n");
            writer.write("    }\n");
            writer.write("}\n");
        } catch (IOException e) {
            throw new RuntimeException("Could not write source for " + index, e);
        } finally {
            if (writer != null) {
                try {
                    writer.close();
                } catch (IOException e) {
                    //Silent
                }
            }
        }
    }
```

```java
    private void writeIndexLines(BufferedWriter writer, String myPackage) throws IOException {
        for (TypeElement subscriberTypeElement : methodsByClass.keySet()) {
            if (classesToSkip.contains(subscriberTypeElement)) {
                continue;
            }

            String subscriberClass = getClassString(subscriberTypeElement, myPackage);
            if (isVisible(myPackage, subscriberTypeElement)) {
                writeLine(writer, 2,
                        "putIndex(new SimpleSubscriberInfo(" + subscriberClass + ".class,",
                        "true,", "new SubscriberMethodInfo[] {");
                List<ExecutableElement> methods = methodsByClass.get(subscriberTypeElement);
                //ğŸ‘‡å…³é”®ä»£ç 
                writeCreateSubscriberMethods(writer, methods, "new SubscriberMethodInfo", myPackage);
                writer.write("        }));\n\n");
            } else {
                writer.write("        // Subscriber not visible to index: " + subscriberClass + "\n");
            }
        }
    }
```


```java
 private void writeCreateSubscriberMethods(BufferedWriter writer, List<ExecutableElement> methods,
                                              String callPrefix, String myPackage) throws IOException {
        for (ExecutableElement method : methods) {
            List<? extends VariableElement> parameters = method.getParameters();
            TypeMirror paramType = getParamTypeMirror(parameters.get(0), null);
            TypeElement paramElement = (TypeElement) processingEnv.getTypeUtils().asElement(paramType);
            String methodName = method.getSimpleName().toString();
            String eventClass = getClassString(paramElement, myPackage) + ".class";

            Subscribe subscribe = method.getAnnotation(Subscribe.class);
            List<String> parts = new ArrayList<>();
            parts.add(callPrefix + "(\"" + methodName + "\",");
            String lineEnd = "),";
            if (subscribe.priority() == 0 && !subscribe.sticky()) {
                if (subscribe.threadMode() == ThreadMode.POSTING) {
                    parts.add(eventClass + lineEnd);
                } else {
                    parts.add(eventClass + ",");
                    parts.add("ThreadMode." + subscribe.threadMode().name() + lineEnd);
                }
            } else {
                parts.add(eventClass + ",");
                parts.add("ThreadMode." + subscribe.threadMode().name() + ",");
                parts.add(subscribe.priority() + ",");
                parts.add(subscribe.sticky() + lineEnd);
            }
            writeLine(writer, 3, parts.toArray(new String[parts.size()]));

            if (verbose) {
                processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "Indexed @Subscribe at " +
                        method.getEnclosingElement().getSimpleName() + "." + methodName +
                        "(" + paramElement.getSimpleName() + ")");
            }

        }
    }
```

### æ··æ·†ç›¸å…³

åœ¨ä½¿ç”¨EventBusçš„æ—¶å€™ï¼Œå¦‚æœä½ çš„é¡¹ç›®é‡‡ç”¨äº†æ··æ·†ï¼Œéœ€è¦æ³¨æ„keepä»¥ä¸‹ç±»åŠæ–¹æ³•ã€‚å®˜æ–¹ä¸­å·²ç»ç»™äº†ä½¿ç”¨EventBusåº“ä¸­éœ€è¦keepçš„ç±»ï¼Œå…·ä½“å¦‚ä¸‹æ‰€ç¤ºï¼š

```java
-keepattributes *Annotation*
-keepclassmembers class * {
    @org.greenrobot.eventbus.Subscribe <methods>;
}
-keep enum org.greenrobot.eventbus.ThreadMode { *; }

# Only required if you use AsyncExecutor
-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent {
    <init>(java.lang.Throwable);
}
```

```java
    @Subscribe(threadMode = ThreadMode.MAIN)
    public void onMessageEvent(MessageEvent event) {
        System.out.println("hello");
    }
```

```java
public class EventBusIndex implements SubscriberInfoIndex {
    private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;

    static {
        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();

        putIndex(new SimpleSubscriberInfo(Activity1.class, true, new SubscriberMethodInfo[] {
            new SubscriberMethodInfo("onMessageEvent", MessageEvent.class, ThreadMode.MAIN),
        }));

    }

    private static void putIndex(SubscriberInfo info) {
        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
    }

    @Override
    public SubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {
        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
        if (info != null) {
            return info;
        } else {
            return null;
        }
    }
}
```

 å› ä¸ºé€šè¿‡APTç”Ÿæˆçš„ä»£ç è®°å½•çš„è®¢é˜…è€…çš„å›è°ƒæ–¹æ–¹æ³•æ˜¯åœ¨ä»£ç æ··æ·†ä¹‹å‰çš„åç§°ï¼Œå¦‚ä¸Šè¿°ä»£ç ä¸­çš„onMessageEvent()æ–¹æ³•ã€‚å½“é€šè¿‡æ··æ·†åï¼Œè¯¥æ–¹æ³•åç§°æœ‰å¯èƒ½å‘ç”Ÿæ”¹å˜äº†ï¼Œé‚£ä¹ˆå®ƒæœ‰å¯èƒ½å«a,å«bï¼Œå«cã€‚é‚£ä¹ˆé€šè¿‡

```java
public class SimpleSubscriberInfo extends AbstractSubscriberInfo {

    private final SubscriberMethodInfo[] methodInfos;

    public SimpleSubscriberInfo(Class subscriberClass, boolean shouldCheckSuperclass, SubscriberMethodInfo[] methodInfos) {
        super(subscriberClass, null, shouldCheckSuperclass);
        this.methodInfos = methodInfos;
    }

    @Override
    public synchronized SubscriberMethod[] getSubscriberMethods() {
        int length = methodInfos.length;
        SubscriberMethod[] methods = new SubscriberMethod[length];
        for (int i = 0; i < length; i++) {
            SubscriberMethodInfo info = methodInfos[i];
            methods[i] = createSubscriberMethod(info.methodName, info.eventType, info.threadMode,
                    info.priority, info.sticky);
        }
        return methods;
    }
}
```

```java
    protected SubscriberMethod createSubscriberMethod(String methodName, Class<?> eventType, ThreadMode threadMode,
                                                      int priority, boolean sticky) {
        try {
            Method method = subscriberClass.getDeclaredMethod(methodName, eventType);
            return new SubscriberMethod(method, eventType, threadMode, priority, sticky);
        } catch (NoSuchMethodException e) {
            throw new EventBusException("Could not find subscriber method in " + subscriberClass +
                    ". Maybe a missing ProGuard rule?", e);
        }
    }
```

å› ä¸ºæ˜¯é€šè¿‡è®°å½•çš„å®é™…åç§°æ¥å¯»æ‰¾ç›¸åº”çš„æ–¹æ³•çš„ï¼Œå› ä¸ºæ··æ·†è¿‡åï¼Œè®¢é˜…è€…çš„æ–¹æ³•å‘ç”Ÿäº†æ”¹å˜ï¼ˆonMessageEventæœ‰å¯èƒ½æ”¹ä¸ºa()ï¼Œæˆ–b()æ–¹æ³•ã€‚æ‰€ä»¥è¿™ä¸ªæ—¶å€™æ˜¯æ‰¾ä¸åˆ°ç›¸å…³çš„è®¢é˜…è€…çš„æ–¹æ³•çš„ ï¼Œå°±ä¼šæŠ›å‡º`Could not find subscriber method in  + subscriberClass + Maybe a missing ProGuard rule?`çš„å¼‚å¸¸ï¼Œæ‰€ä»¥åœ¨æ··æ·†çš„æ—¶å€™æˆ‘ä»¬éœ€è¦ä¿ç•™è®¢é˜…è€…æ‰€æœ‰åŒ…å«`@Subscribe`æ³¨è§£çš„æ–¹æ³•ã€‚




é¦–å…ˆï¼Œå› ä¸ºEventBus 3å¼ƒç”¨äº†åå°„çš„æ–¹å¼å»å¯»æ‰¾å›è°ƒæ–¹æ³•ï¼Œæ”¹ç”¨æ³¨è§£çš„æ–¹å¼ã€‚ä½œè€…çš„æ„æ€æ˜¯åœ¨æ··æ·†æ—¶å°±ä¸ç”¨å†keepä½ç›¸åº”çš„ç±»å’Œæ–¹æ³•ã€‚ä½†æ˜¯æˆ‘ä»¬åœ¨è¿è¡Œæ—¶ï¼Œå´ä¼šæŠ¥java.lang.NoSuchFieldError: No static field POSTINGã€‚ç½‘ä¸Šç»™å‡ºçš„è§£å†³åŠæ³•æ˜¯keepä½æ‰€æœ‰eventbusç›¸å…³çš„ä»£ç ï¼š

-keep class de.greenrobot.** {*;}
å…¶å®æˆ‘ä»¬ä»”ç»†åˆ†æï¼Œå¯ä»¥çœ‹åˆ°æ˜¯å› ä¸ºåœ¨SubscriberMethodFinderçš„findUsingReflectionæ–¹æ³•ä¸­ï¼Œåœ¨è°ƒç”¨Method.getAnnotation()æ—¶è·å–ThreadModeè¿™ä¸ªenumå¤±è´¥äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦keepä½è¿™ä¸ªenumå°±å¯ä»¥äº†ï¼ˆå¦‚ä¸‹ï¼‰ã€‚

-keep public enum org.greenrobot.eventbus.ThreadMode { public static *; }


### æœ€å

ä¸ºä»€ä¹ˆæšä¸¾ç±»ï¼Œä¸èƒ½è¢«æ··æ·†ï¼Œå› ä¸ºæšä¸¾ç±»ï¼Œæœ€ç»ˆä¼šè‡ªåŠ¨ç”Ÿæˆï¼Œè€Œæ³¨è§£ä¹Ÿæ˜¯è‡ªåŠ¨ç”Ÿæˆçš„æ˜¯å…¨é™å®šåç§°
å®˜æ–¹ä½œè€…ï¼š

http://androiddevblog.com/eventbus-3-droidcon/

https://blog.kaush.co/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/


https://www.jianshu.com/p/61631134498e
ç«™åœ¨å·¨äººçš„è‚©è†€ä¸Šï¼Œæ‰èƒ½çœ‹çš„æ›´è¿œ~

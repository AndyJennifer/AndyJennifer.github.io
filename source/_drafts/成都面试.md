---
title: 成都面试
categories: 面试
---

### 软通动力
公司类型：人员外包到咪咕，12薪，无年终奖
面试题目：
1. Activity的生命周期
2. Service的两种启动方式及其生命周期
3. Android事件分发机制
4. Andoird事件冲突的处理
5. 自定义View的过程
6. ButterKnife的原理
7. Handler机制

整体回顾：
- 问题1:主要问了A Activity跳转到 B Activity时双方的生命周期的问题。如果B Activity非透明的话，那么B的生命周期为 onPause->onStop->onDestory A的生命周期为onRestart onStart onResume
- 问题5:一般的自定义View的过程 判断是否需要自定义属性，注意OnMeasure方法支持wrap_content，在onDraw方法中注意padding
- 问题6:ButterKnife主要使用了APT技术，通过该技术可以通过解析源文件中的注解，生成新的文件并与源文件共同编译。如我们在Activity A中 添加了ButterKnife中自定义的注解，那么通过APT技术，我们可以生成一个 AActivityBinding的类，同时在该类中对Activity中的控件进行了查找与赋值。那么当我们通过ButterKnife绑定控件的时候，会通过反射调AActivityBinding的构造函数，完成对ActivityA的控件数据的绑定。减少了样板的代码。

### 诚迈科技
公司类型：人员外包到oppeo，
面试题目：
1. 应用启动白屏
2. 线程池的使用，及参数说明
3. View的工作流程
4. 内存泄露和检查工具
5. 内存泄露的场景
6. HashMap与HashTable的区别
7. 自定义View需要注意的事项

整体回顾：

- 问题3：
View的工作流程
activity创建的时候会将DecorView会与ViewRootImpl类进行关联。

measure过程：viewRootImpl preformMeasure()-> ViewGroup measure()->ViewGroup  onMeasure()->循环遍历其中的子类，调用其
子类的measure方法。如果是viewGroup，那么就重复上面的操作，如果是view，(会根据当前view的布局参数与父容器的规则生成自己的测量规则）那么view measure()-> view  onMeausre()

layout过程： viewRootImpl preformLayout()-> ViewGroup layout()-> viewGroup onLayout()->循环遍历其中的子类，调用其子类的layout方法，如果是viewGroup，那么就重复上面的操作，如果是view (会根据当前view的布局参数，确定当前vieww的位置)，那么view layout()-> view onlayout()

draw过程 viewRootImpl performDraw()-> viewGroup draw() -> viewGroup onDraw()-> ViewGroup dispatchDraw()（循环遍历其中的子类，调用其draw()方法。

- 问题6：
#### HashTable 
默认初始容量：11，扩容范围：当前数组长度的2倍+1
特点：不允许Key/Value为null。
hash算法：当前key的hashCode%当前数组长度
线程安全： 是线程安全的

#### HashMap1.7版
默认初始容量：16，为2的平方，主要是为了取模与扩容的优化  处理过后的hash& (len-1)等价与与len进行取模操作。操作效率要快


#### HashMap1.8版

- 优化方面：优化了取模算法，增加了红黑树。扩容进行了优化。
- 取模算法优化：hashCode的高16位与低16为进行异或运算（key.hashCode^key.hashCode>>>16)&(len -1),其中len为数组长度，主要原因：在数组长度较小的时候，hashCode的高16位与低16都能参加hash运算。
- 红黑树优化：当链表中的节点相对较长时时间复杂度为,(On)，转换为红黑树，主要是为了优化查询的效率。


#### HashTable 与 HashMap CocurrentHashMap的选择
多线程：考虑cocurrentHashMap因为效率比HashTable高
单线程：考虑HashMap 1.8


#### 艾欧比
机试题目：简单的布局搭建
面试题目：
1. 内存泄露常见的情况
2. Activity显示启动和隐士启动，且隐式启动的规则
3. Activity的启动过程
4. Activity A 启动Activity B时，两个Activity的生命周期。

问题1：针对内存泄露有下面的几种情况
1. 静态变量导致的内存泄露
2. 单例模式导致的内存泄露，原因是单例模式生命周期与Application是一致的。
3. 属性动画导致的内存泄露，原因是动画一直在执行，那么该公话会一直持有view,view又持有Activity。

问题2：Activity可以通过显示启动与隐式启动
显示启动：被启动对象的组件信息，包括包名和类名
隐士启动：通过IntentFilter来过滤消息，过滤信息分为 action ,category,data
action匹配规则:只要和任意中的一个action相同就可以了，区分大小写
category匹配规则：只要和任意中的一个category相同就可以了，必须是IntentFilter中定义的category。
data匹配规则，只要和任意中的一个data相同就可以了，url(schemea 默认为content和file)其中加mimetype

问题3：Activity的启动过程。
![Activity创建过程.png](https://upload-images.jianshu.io/upload_images/2824145-3e1b19601f0ef983.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


主要过程为下面主要步骤：
当发起启动Activity的请求时，会通过Instrumentation来处理，然后它通过Binder向AMS发送请求，AMS内部维护者通过ActivityStackSupervisor中维护的ActivityStack来管理栈内Activity的状态同步，AMS通过ActivityThread中的ApplicationThread去同步Activity的状态从而完成生命周期方法的调用。

问题4：
整个生命周期调用顺序为 A->onPause B->onCreate B->onStart B->onResume A->OnStop(判断B是否透明，是否为对话框依照情况来调用)

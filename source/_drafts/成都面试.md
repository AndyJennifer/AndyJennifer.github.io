---
title: 成都面试
categories: 面试
---

### 软通动力

公司类型：人员外包到咪咕，12薪，无年终奖

面试题目：

1. Activity的生命周期
2. Service的两种启动方式及其生命周期
3. Android事件分发机制
4. Andoird事件冲突的处理
5. 自定义View的过程
6. ButterKnife的原理
7. Handler机制

整体回顾：

#### 问题1:
主要问了A Activity跳转到 B Activity时双方的生命周期的问题。如果B Activity非透明的话，那么B的生命周期为 onPause->onStop->onDestory A的生命周期为onRestart onStart onResume
#### 问题5:
一般的自定义View的过程 判断是否需要自定义属性，注意OnMeasure方法支持wrap_content，在onDraw方法中注意padding
#### 问题6:
ButterKnife主要使用了APT技术，通过该技术可以通过解析源文件中的注解，生成新的文件并与源文件共同编译。如我们在Activity A中 添加了ButterKnife中自定义的注解，那么通过APT技术，我们可以生成一个 AActivityBinding的类，同时在该类中对Activity中的控件进行了查找与赋值。那么当我们通过ButterKnife绑定控件的时候，会通过反射调AActivityBinding的构造函数，完成对ActivityA的控件数据的绑定。减少了样板的代码。

### 诚迈科技
公司类型：人员外包到oppo，

#### 初试
面试题目：
1. 应用启动白屏
2. 线程池的使用，及参数说明
3. View的工作流程
4. 内存泄露和检查工具
5. 内存泄露的场景
6. HashMap与HashTable的区别
7. 自定义View需要注意的事项


整体回顾：

##### 问题3：
- View的工作流程：
activity创建的时候会将DecorView会与ViewRootImpl类进行关联。
- measure过程：viewRootImpl preformMeasure()-> ViewGroup measure()->ViewGroup  onMeasure()->循环遍历其中的子类，调用其
子类的measure方法。如果是viewGroup，那么就重复上面的操作，如果是view，(会根据当前view的布局参数与父容器的规则生成自己的测量规则）那么view measure()-> view  onMeausre()

- layout过程： viewRootImpl preformLayout()-> ViewGroup layout()-> viewGroup onLayout()->循环遍历其中的子类，调用其子类的layout方法，如果是viewGroup，那么就重复上面的操作，如果是view (会根据当前view的布局参数，确定当前vieww的位置)，那么view layout()-> view onlayout()。

- draw过程 viewRootImpl performDraw()-> viewGroup draw() -> viewGroup onDraw()-> ViewGroup dispatchDraw()（循环遍历其中的子类，调用其draw()方法。

##### 问题6：

- HashTable 
默认初始容量：11，扩容范围：当前数组长度的2倍+1
特点：不允许Key/Value为null。
hash算法：当前key的hashCode%当前数组长度
线程安全： 是线程安全的

- HashMap1.7版
默认初始容量：16，为2的平方，主要是为了取模与扩容的优化  处理过后的hash& (len-1)等价与与len进行取模操作。操作效率要快

- HashMap1.8版
    1. 优化方面：优化了取模算法，增加了红黑树。扩容进行了优化。
    2. 取模算法优化：hashCode的高16位与低16为进行异或运算（key.hashCode^key.hashCode>>>16)&(len -1),其中len为数组长度，主要原因：在数组长度较小的时候，hashCode的高16位与低16都能参加hash运算。
    3. 红黑树优化：当链表中的节点相对较长时时间复杂度为,(On)，转换为红黑树，主要是为了优化查询的效率。

- ConcurrentHashMap 1.7
默认初始容量16，不允许key/value为null。
并发性：并发级别为16。使用votatile变量协调读线程间的内存可见性。当发生指令重排序是加锁重读。
hash算法：先确定在segement中的角标位置，在通过Hash算法计算在segment中HashMap对于的数组角标位置。

- ConcurrentHashMap 1.8
put操作：通过CAS+synchronized 
读操作；通过volatile

- HashTable 与 HashMap ConcurrentHashMap的选择

    1. 多线程：考虑concurrentHashMap因为效率比HashTable高    2. 单线程：考虑HashMap 1.8


#### 复试
1. View绘制流程 relativeLayout LinearLayout绘制测量的区别
2. synchronized原理
3. ReentrantLock与synchronized的区别
4. CAS与Volatile原理
5. Rxjava切换线程原理
6. EventBus原理

##### 复试问题2
java中一个对象对应一个监视器(monitor)，synchronized加锁，是通过monitorEnter与monitorExit两个指令，当一个线程获取一个成功干获取监视器对象的时候，这个其他线程执行monitorExit会失败，那么这个时候会将该线程放入同步队列中，当获取锁的线程执行完成后，并且执行完monitorExit指令后(也就是是释放锁)，那么这个时候会唤醒在等待队列中的线程去获取锁。

##### 复试问题3
ReentrantLock与synchronized的区别
- 锁的获取与释放不再是隐式的
- ReenTrantLock支持线程中断，当某个线程获取锁后，如果中断，会抛出异常，并释放所获取的锁
- 支持超时获取

##### 复试问题4
cas原理Volatile原理
- cas原理 比较主内存中的值与工作内存中的值是否相等，如果相等，则用新值去更新主内存与工作内存中的值
- volatile修饰的变量时，会多生成一个Lock指令，该指令会坐两件事情，
    1. 将当前处理器中的缓冲行直接写到主内存中。
    2. 这个写回主内存的操作会使其他CPU里缓冲了的该地址的数据无效，会重新从系统内存中把数据读到处理器缓冲中。

##### 复试问题5
Rxjava切换线程的原理
当调用subscribeOn的时候会创建一个观察者与被观察者的包装类，在被观察者中的包装类中调用onNext、onError、等发送事件时，会根据设置的perform。来确定发送事件时对应的线程。在调用observerOn的时候也会创建观察者与被观察者的包装类，只不过相应回调方法是根据观察者设置的observerOn设置的perform设置的线程，来回调相应的OnNext，onError方法。

##### 复试问题6
- register
Eventbus原理，某个类通过register注册监听的时候，会获取该类上订阅的方法（SubscriberMethod)集合，通过反射获取的方式获取方法上的注解信息构建SubsciberMethod信息，然后会添加到Eventbus中对于的集合中区。如果是有对应的粘性事件，
- post
通过获取EventBus获取对应事件类型中的订阅的方法集合，根据订阅方法的线程模式。判断到底是线程的模式，判断到底是通过handler机制调用Method.invoke方法，还是通过创建线程池添加任务的方式来处理Method.invoke方法，
- 索引类的作用
因为之前是通过反射获取方法，然后通过获取该方法上的注解的形式来获取SubscriberMethod。为了提升效率，采用Apt技术，直接获取原文件中的注解信息，生成索引类文件（其中该类文件中对SubscriberMethod)，这样索引类文件就能和原文件一同编译了，节约了一次反射的时间。


### 艾欧比
机试题目：简单的布局搭建

面试题目：

1. 内存泄露常见的情况
2. Activity显示启动和隐士启动，且隐式启动的规则
3. Activity的启动过程
4. Activity A 启动Activity B时，两个Activity的生命周期。
5. 广播的静态注册和动态注册的区别，以及广播的种类
6. 线程的几个参数的理解，核心线程与最大线程数怎么配置的。

整体回顾：

#### 问题1：
1. 静态变量导致的内存泄露
2. 单例模式导致的内存泄露，原因是单例模式生命周期与Application是一致的。
3. 属性动画导致的内存泄露，原因是动画一直在执行，那么该公话会一直持有view,view又持有Activity。
4. 非静态内部类
5. leakCannary原理

#### 问题2：
- 显示启动：被启动对象的组件信息，包括包名和类名
- 隐士启动：通过IntentFilter来过滤消息，过滤信息分为 action ,category,data
action匹配规则:只要和任意中的一个action相同就可以了，区分大小写
category匹配规则：只要和任意中的一个category相同就可以了，必须是IntentFilter中定义的category。
data匹配规则，只要和任意中的一个data相同就可以了，url(schemea 默认为content和file)其中加mimetype

#### 问题3：
![Activity创建过程.png](https://upload-images.jianshu.io/upload_images/2824145-3e1b19601f0ef983.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

主要过程为下面主要步骤：
当发起启动Activity的请求时，会通过Instrumentation来处理，然后它通过Binder向AMS发送请求，AMS内部维护者通过ActivityStackSupervisor中维护的ActivityStack来管理栈内Activity的状态同步，AMS通过ActivityThread中的ApplicationThread去同步Activity的状态从而完成生命周期方法的调用。

#### 问题4：
整个生命周期调用顺序为 A->onPause B->onCreate B->onStart B->onResume A->OnStop(判断B是否透明，是否为对话框依照情况来调用)

#### 问题5：
- 广播的定义：四大组件之一，分为广播发送者与广播接受者。
- 作用：监听/接受App或系统发出的广播消息，并作出响应，主要用于不同组件的通信。
- 运行线程：默认运行在主线程，所以不能执行一些耗时操作。
- 注册方式：
  1. 动态注册：需要通过代码调用Context.registerReceiver()方法。
  2. 静态注册：在清单文件中用Reciver标签注册，当应用启动时，系统会自动实例化mBroadcastReceiver,并注册到系统中。

- 广播的类型：
  1. 普通广播
  2. 系统广播
  3. 有序广播
  4. 粘性广播
  5. 本地广播 

#### 问题6：
线程池主要由几个参数，核心线程数，同步队列，最大线程数，饱和策略，非核心线程或核心线程保存时间。
线程池执行步骤：
1. 判断当前是否大于核心线程数，如果没有超过则创建线程执行任务
2. 在1条件不满足的情况下，判断队列中的任务数，是否已满，如果不满，则放入等待队列中
3. 在2条件不满足的情况下，判断是否超过最大线程数，如果没超过，则创建非核心线程执行任务
4. 在3条件不满足的情况下，根据饱和策略执行相应的操作。

核心线程数与最大线程数最大的配置：
1. IO密集型： 尽可能多 2Ncpu个
2. CPU密集型：尽量小 Ncpu+1个

### 龙炎

面试题目：

1. View绘制原理
2. 事件分发机制
3. String为什么是final类型
4. HashMap原理
5. 八大基本数据类型
6. AsyncTask原理

#### 问题1
View的绘制流程是从ViewRoot的perfromTraversals方法开始的，performTraversals方法中会依次调用performMeasure、performLayout,performDraw、三个方法。其中在sheduleMeasure方法中会调用最外层ViewGroup的measure方法。在measure方法中又会调用onMeasure方法。onMeasure方法是抽象方法，根据不同的父控件来实现相应方法，在onMeasure方法中，会根据当前父控件的measureSpec和当前子view的布局参数生成测量规则，对所有的子元素进行measure过程。接着子view会重复复父view的measure过程，如此反复，完成整个view树的绘制。

performLayout和performDraw方法是类似的。perfromLayout会调用layout，在layout方法中会确定View本身的位置，接着该方法内部会调用onLayout方法来确定所有子元素在viewGoup中位置。

perfromDraw方法中，会先绘制背景，然后调用本身的onDraw方法绘制自己，然后会调用dispathDraw()绘制所有的子view。绘制装饰
#### 问题2
事件分发机制，当一个事件产生的时候，它的分发顺序为Activity->Window->View,对于根ViewGroup会调用dispatchTouchEvent方法会调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true，表示它将要拦截事件，接着事件就会交个这个ViewGroup处理，及它的onTouchEvent方法就会调用，如果这个时候ViewGroup的onInterceptTouchEvent方法返回false,就表示它不拦截当前事件，这个时候会遍历
ViewGroup的所有的子元素，判断子元素是否能够接受到事件，如果子元素能够接受事件，那么就调用子元素的dispatchTouchEvent方法。如果子元素的dispatchTouchEvent返回true，那么事件就交给该子元素处理。如果子元素的dispatchTouchEvent返回false,ViewGroup就会把事件分发给下一个元素。

如果这个时候，所有的子元素的dispatchTouchEvent都返回false,或者该ViewGroup没有子元素，那么会调用ViewGroup的方法处理事件。

对与View处理事件的过程：
调用dispatchTouchEvent方法。会先判断是否设置了OnTouchListener,如果onTouch方法返回true,那么不会调用OnTouchEvent方法。


#### 问题3
String类被修饰为final类型主要为以下三点需求
- 为了实现字符串常量池，对于字面值相同的String变量所指向的内存空间是相同的，节约了内存空间
- 为了线程安全，在多线程进行操作的时候，因为String是不可变的。就不会出现数据不同步的问题。
- 为了实现String可以创建HashCode不可变性。因为String是不可变的。且对于字面值相同的String变量所指向的内存空间是相同的。那么在使用Map等集合时，所得到的hashCode值是相同的。所以就保证了不会出现同一Key值，但是对应value不同的情况。

> 被final修饰的类，是不能继承的。且在String类中有一个 private final char[]数组用于存储字面值，

#### 问题5
八大基本数据类型，byte short int long、float double ,boolean  char 
#### 问题6
AsyncTask 异步任务是Google提供的一个异步跟新UI的一个类，该类中为我们提供了，doInBackground，onPreExecute、onPostExecute方法。内部原理是线程池+Handler,当我们使用无惨构造函数，创建异步时候的时候，会将doInbackground中的方法封装到为FutureTask提供给线程池执行，当任务执行完毕的时候，会通过与主线程关联的handler发送消息给主线程，将onPostExecute方法切换到主线程中运行。


### 鸿神每日问题

- 问题1：谈谈对intent理解，说一下intent匹配规则，对于Intent启动activity,service,boardcast有无注意事项，以及区别。
- 问题2：intent最大传递数据有限制嘛，限制为多少，如果有限制，有什么好的解决方案
- 问题3：JDK8之前，匿名内部类访问的局部变量为什么必须要用final修饰
- 问题4：viewgroup中有个generateLayoutParams方法，什么情况下我们会考虑复写，具体有什么用。
- 问题5：为什么需要multidex，multidex对启动速度有什么影响，需要做什么优化，multidex默认支持哪些配置。

#### 问题1
activity可以有多个intent-fileter 只要有一个intent-filter满足就可以了，其中intent-filter中匹配action（可以多个，只要匹配任意的一个就行了，区分大小写）,category（可以多个，只要在intent-filter存在就行了）,data类型（miniType,url)。
启动activity分为显示启动，及其隐士启动，service启动分文startService,bindService.boardcast为sendBoardcast

#### 问题2
intent 携带信息的大小是受Binder限制的，通常是1MB，解决方法，在activity放入静态数据，如果是文件或图片，直接通过url的形式传递

#### 问题3
也就是说匿名内部类之所以可以访问局部变量，是因为在底层将这个局部变量的值传入到了匿名内部类中，并且以匿名内部类的成员变量的形式存在，这个值的传递过程是通过匿名内部类的构造器完成的。被final修饰的话，保证了局部变量中的值与匿名内部类中的成员变量保持一致。

#### 问题4
generateLayoutParams其实就是定义父控件所有的子控件需要哪些布局参数，比如Relativelayout中，alight_top to_left_of

#### 问题5
- 第一种方式规避64k可限制，检测您的项目应用的直接依赖和传递性依赖项。 通过proGuard移除没有使用的代码，
mulitedex 支持每个dex支持的最大数目，支持主dex需要打包的类



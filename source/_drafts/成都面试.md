---
title: 成都面试
categories: 面试
---

### 软通动力

公司类型：人员外包到咪咕，12薪，无年终奖
面试题目：
1. Activity的生命周期
2. Service的两种启动方式及其生命周期
3. Android事件分发机制
4. Andoird事件冲突的处理
5. 自定义View的过程
6. ButterKnife的原理
7. Handler机制

整体回顾：

#### 问题1:
主要问了A Activity跳转到 B Activity时双方的生命周期的问题。如果B Activity非透明的话，那么B的生命周期为 onPause->onStop->onDestory A的生命周期为onRestart onStart onResume
#### 问题5:
一般的自定义View的过程 判断是否需要自定义属性，注意OnMeasure方法支持wrap_content，在onDraw方法中注意padding
#### 问题6:
ButterKnife主要使用了APT技术，通过该技术可以通过解析源文件中的注解，生成新的文件并与源文件共同编译。如我们在Activity A中 添加了ButterKnife中自定义的注解，那么通过APT技术，我们可以生成一个 AActivityBinding的类，同时在该类中对Activity中的控件进行了查找与赋值。那么当我们通过ButterKnife绑定控件的时候，会通过反射调AActivityBinding的构造函数，完成对ActivityA的控件数据的绑定。减少了样板的代码。

### 诚迈科技
公司类型：人员外包到oppo，

#### 初试
面试题目：
1. 应用启动白屏
2. 线程池的使用，及参数说明
3. View的工作流程
4. 内存泄露和检查工具
5. 内存泄露的场景
6. HashMap与HashTable的区别
7. 自定义View需要注意的事项


整体回顾：

##### 问题3：
- View的工作流程：
activity创建的时候会将DecorView会与ViewRootImpl类进行关联。
- measure过程：viewRootImpl preformMeasure()-> ViewGroup measure()->ViewGroup  onMeasure()->循环遍历其中的子类，调用其
子类的measure方法。如果是viewGroup，那么就重复上面的操作，如果是view，(会根据当前view的布局参数与父容器的规则生成自己的测量规则）那么view measure()-> view  onMeausre()

- layout过程： viewRootImpl preformLayout()-> ViewGroup layout()-> viewGroup onLayout()->循环遍历其中的子类，调用其子类的layout方法，如果是viewGroup，那么就重复上面的操作，如果是view (会根据当前view的布局参数，确定当前vieww的位置)，那么view layout()-> view onlayout()。

- draw过程 viewRootImpl performDraw()-> viewGroup draw() -> viewGroup onDraw()-> ViewGroup dispatchDraw()（循环遍历其中的子类，调用其draw()方法。

##### 问题6：

- HashTable 
默认初始容量：11，扩容范围：当前数组长度的2倍+1
特点：不允许Key/Value为null。
hash算法：当前key的hashCode%当前数组长度
线程安全： 是线程安全的

- HashMap1.7版
默认初始容量：16，为2的平方，主要是为了取模与扩容的优化  处理过后的hash& (len-1)等价与与len进行取模操作。操作效率要快

- HashMap1.8版
    1. 优化方面：优化了取模算法，增加了红黑树。扩容进行了优化。
    2. 取模算法优化：hashCode的高16位与低16为进行异或运算（key.hashCode^key.hashCode>>>16)&(len -1),其中len为数组长度，主要原因：在数组长度较小的时候，hashCode的高16位与低16都能参加hash运算。
    3. 红黑树优化：当链表中的节点相对较长时时间复杂度为,(On)，转换为红黑树，主要是为了优化查询的效率。

- HashTable 与 HashMap CocurrentHashMap的选择

    1. 多线程：考虑cocurrentHashMap因为效率比HashTable高    2. 单线程：考虑HashMap 1.8


#### 复试
1. View绘制流程 relativeLayout LinearLayout绘制测量的区别
2. synchronized原理
3. ReentrantLock与synchronized的区别
4. CAS与Volatile原理
5. Rxjava切换线程原理
6. EventBus原理

##### 复试问题2
java中一个对象对应一个监视器(monitor)，synchronized加锁，是通过monitorEnter与monitorExit两个指令，当一个线程获取一个成功干获取监视器对象的时候，这个其他线程执行monitorExit会失败，那么这个时候会将该线程放入同步队列中，当获取锁的线程执行完成后，并且执行完monitorExit指令后(也就是是释放锁)，那么这个时候会唤醒在等待队列中的线程去获取锁。

##### 复试问题3
ReentrantLock与synchronized的区别
- 锁的获取与释放不再是隐式的
- ReenTrantLock支持线程中断，当某个线程获取锁后，如果中断，会抛出异常，并释放所获取的锁
- 支持超时获取

##### 复试问题4
cas原理Volatile原理
- cas原理 比较主内存中的值与工作内存中的值是否相等，如果相等，则用新值去更新主内存与工作内存中的值
- volatile修饰的变量时，会多生成一个Lock指令，该指令会坐两件事情，
    1. 将当前处理器中的缓冲行直接写到主内存中。
    2. 这个写回主内存的操作会使其他CPU里缓冲了的该地址的数据无效，会重新从系统内存中把数据读到处理器缓冲中。

##### 复试问题5


##### 复试问题6


### 艾欧比
机试题目：简单的布局搭建
面试题目：
1. 内存泄露常见的情况
2. Activity显示启动和隐士启动，且隐式启动的规则
3. Activity的启动过程
4. Activity A 启动Activity B时，两个Activity的生命周期。
5. 广播的静态注册和动态注册的区别，以及广播的种类
6. 线程的几个参数的理解，核心线程与最大线程数怎么配置的。

整体回顾：

#### 问题1：
1. 静态变量导致的内存泄露
2. 单例模式导致的内存泄露，原因是单例模式生命周期与Application是一致的。
3. 属性动画导致的内存泄露，原因是动画一直在执行，那么该公话会一直持有view,view又持有Activity。
4. 非静态内部类
5. leakCannary原理

#### 问题2：
- 显示启动：被启动对象的组件信息，包括包名和类名
- 隐士启动：通过IntentFilter来过滤消息，过滤信息分为 action ,category,data
action匹配规则:只要和任意中的一个action相同就可以了，区分大小写
category匹配规则：只要和任意中的一个category相同就可以了，必须是IntentFilter中定义的category。
data匹配规则，只要和任意中的一个data相同就可以了，url(schemea 默认为content和file)其中加mimetype

#### 问题3：
![Activity创建过程.png](https://upload-images.jianshu.io/upload_images/2824145-3e1b19601f0ef983.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

主要过程为下面主要步骤：
当发起启动Activity的请求时，会通过Instrumentation来处理，然后它通过Binder向AMS发送请求，AMS内部维护者通过ActivityStackSupervisor中维护的ActivityStack来管理栈内Activity的状态同步，AMS通过ActivityThread中的ApplicationThread去同步Activity的状态从而完成生命周期方法的调用。

#### 问题4：
整个生命周期调用顺序为 A->onPause B->onCreate B->onStart B->onResume A->OnStop(判断B是否透明，是否为对话框依照情况来调用)

#### 问题5：
- 广播的定义：四大组件之一，分为广播发送者与广播接受者。
- 作用：监听/接受App或系统发出的广播消息，并作出响应，主要用于不同组件的通信。
- 运行线程：默认运行在主线程，所以不能执行一些耗时操作。
- 注册方式：
  1. 动态注册：需要通过代码调用Context.registerReceiver()方法。
  2. 静态注册：在清单文件中用Reciver标签注册，当应用启动时，系统会自动实例化mBroadcastReceiver,并注册到系统中。

- 广播的类型：
  1. 普通广播
  2. 系统广播
  3. 有序广播
  4. 粘性广播
  5. 本地广播 

#### 问题6：
线程池主要由几个参数，核心线程数，同步队列，最大线程数，饱和策略，非核心线程或核心线程保存时间。
线程池执行步骤：
1. 判断当前是否大于核心线程数，如果没有超过则创建线程执行任务
2. 在1条件不满足的情况下，判断队列中的任务数，是否已满，如果不满，则放入等待队列中
3. 在2条件不满足的情况下，判断是否超过最大线程数，如果没超过，则创建非核心线程执行任务
4. 在3条件不满足的情况下，根据饱和策略执行相应的操作。

核心线程数与最大线程数最大的配置：
1. IO密集型： 尽可能多 2Ncpu个
2. CPU密集型：尽量小 Ncpu+1个


常见的线程池类型：



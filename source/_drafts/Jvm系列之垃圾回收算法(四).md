---
title: Jvm系列之垃圾回收算法
tags:
- Jvm
categories:
- Jvm
---

### 可达性分析算法

找到GC Roots对象，以Gc Roots对象为起点，寻找与GC Roots没有任何引用链的对象。这些对象将会被判定是否是可回收的对象。

可作为GC Roots对象的为下面几种：

- 虚拟机栈（帧栈中的本地变量表）中引用的对象
- 方法区中，静态与常量属性引用的对象。
- 本地方法栈中所引用的对象。Í

### GC算法

- 标记-清除算法
- 复制算法
- 标记整理算法
- 分代搜集算法

#### 标记-清除算法

- 算法思想：标记出所有需要被回收的对象，在标记完成后统一清除所有被标记的对象。
- 主要问题：一个是效率问题，标记和清除两个过程的效率都不高。另一个问题是空间问题。标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象是，无法找到足够的连续的内存而不得不触发另一次垃圾收集动作。

#### 复制算法

- 算法思想：将内存大小分为相等的两块，每次使用其中一块，当使用的这块内存用完了，就将还存活的对象复制到另一个块内存上面，然后再把已使用过的内存空间一次清理掉。
- 优点：解决了标记清除算法效率低的问题。因为该算法每次都回收内存的一半区域
- 缺点：使用的内存缩小为了一半，当对象存活率较高的情况下需要做很多复制操作。效率会相对较低。

#### 标记整理算法

- 算法思想：标记出所有需要回收的对象，然后将所有存活的对象都向一端移动。最后清除掉边界以外的内存。
- 优点：解决了标记-清除效率低，其内存空间不连续的问题。

#### 分代收集算法

- 算法思想：根据对象存活的周期的不同将内存划分为几块。一般是将Java对分为新生代和老年代，然后根据不同年代的特点采用合适的收集算法。

> 新生代中，每次垃圾收集时都会有大批对象死去，只有少量存活，那就选用复制算法。
> 老年代中，因为对象存活率较高，没有额外空间进行分担担保，所以采用标记-清理，或标记-整理算法来进行

### 内存分配与回收策略

#### 新生代

#### 老年代

#### 分配策略

- 对象优先在eden分配,如果内存不够，则GC一次，如果还不够直接放入老年代。
- 大对象直接进入老年代
- 长期存活的对象将进入老年代
